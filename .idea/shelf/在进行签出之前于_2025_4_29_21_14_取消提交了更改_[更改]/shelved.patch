Index: src/main/java/com/renyigesai/immortalers_delight/ImmortalersDelightMod.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight;\r\n\r\nimport com.mojang.logging.LogUtils;\r\nimport com.renyigesai.immortalers_delight.block.ancient_stove.AncientStoveBlockEntity;\r\nimport com.renyigesai.immortalers_delight.client.renderer.AncientStoveBlockEntityRenderer;\r\nimport com.renyigesai.immortalers_delight.client.renderer.ImmortalersBoatRenderer;\r\nimport com.renyigesai.immortalers_delight.client.renderer.ImmortalersDelightHangingSignRenderer;\r\nimport com.renyigesai.immortalers_delight.client.renderer.ImmortalersDelightSignRenderer;\r\nimport com.renyigesai.immortalers_delight.init.*;\r\nimport com.renyigesai.immortalers_delight.screen.EnchantalCoolerScreen;\r\nimport com.renyigesai.immortalers_delight.screen.overlay.*;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.gui.screens.MenuScreens;\r\nimport net.minecraft.client.renderer.entity.EntityRenderers;\r\nimport net.minecraft.world.level.block.Block;\r\nimport net.minecraft.world.level.block.Blocks;\r\nimport net.minecraftforge.api.distmarker.Dist;\r\nimport net.minecraftforge.client.event.EntityRenderersEvent;\r\nimport net.minecraftforge.common.MinecraftForge;\r\nimport net.minecraftforge.event.server.ServerStartingEvent;\r\nimport net.minecraftforge.eventbus.api.IEventBus;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.ModLoadingContext;\r\nimport net.minecraftforge.fml.common.Mod;\r\nimport net.minecraftforge.fml.config.ModConfig;\r\nimport net.minecraftforge.fml.event.lifecycle.FMLClientSetupEvent;\r\nimport net.minecraftforge.fml.event.lifecycle.FMLCommonSetupEvent;\r\nimport net.minecraftforge.fml.javafmlmod.FMLJavaModLoadingContext;\r\nimport net.minecraftforge.registries.DeferredRegister;\r\nimport net.minecraftforge.registries.ForgeRegistries;\r\nimport org.slf4j.Logger;\r\n\r\nimport java.util.Locale;\r\n\r\n// The value here should match an entry in the META-INF/mods.toml file\r\n@Mod(ImmortalersDelightMod.MODID)\r\npublic class ImmortalersDelightMod {\r\n\r\n    public static final String MODID = \"immortalers_delight\";\r\n    public static final Logger LOGGER = LogUtils.getLogger();\r\n\r\n    public ImmortalersDelightMod() {\r\n        MinecraftForge.EVENT_BUS.register(this);\r\n        IEventBus bus = FMLJavaModLoadingContext.get().getModEventBus();\r\n\r\n        ImmortalersDelightItems.REGISTER.register(bus);\r\n        ImmortalersDelightBlocks.register(bus);\r\n        ImmortalersDelightBlockEntityTypes.TILES.register(bus);\r\n        ImmortalersDelightBlocks.BLOCK_ENTITY_REGISTRY.register(bus);\r\n        ImmortalersDelightGroup.CREATIVE_TABS.register(bus);\r\n        ImmortalersDelightMobEffect.REGISTRY.register(bus);\r\n        ImmortalersDelightParticleTypes.REGISTRY.register(bus);\r\n        ImmortalersDelightMenuTypes.MENUS.register(FMLJavaModLoadingContext.get().getModEventBus());\r\n\r\n        ImmortalersDelightEntities.ENTITY_TYPES.register(bus);\r\n\r\n        ModLoadingContext.get().registerConfig(ModConfig.Type.COMMON, Config.SPEC);\r\n    }\r\n\r\n    private void commonSetup(final FMLCommonSetupEvent event) {\r\n        // Some common setup code\r\n        LOGGER.info(\"HELLO FROM COMMON SETUP\");\r\n        LOGGER.info(\"DIRT BLOCK >> {}\", ForgeRegistries.BLOCKS.getKey(Blocks.DIRT));\r\n\r\n        if (Config.logDirtBlock) LOGGER.info(\"DIRT BLOCK >> {}\", ForgeRegistries.BLOCKS.getKey(Blocks.DIRT));\r\n\r\n        LOGGER.info(Config.magicNumberIntroduction + Config.magicNumber);\r\n\r\n        Config.items.forEach((item) -> LOGGER.info(\"ITEM >> {}\", item.toString()));\r\n    }\r\n    @SubscribeEvent\r\n    public void onServerStarting(ServerStartingEvent event) {\r\n        // Do something when the server starts\r\n        LOGGER.info(\"HELLO from server starting\");\r\n    }\r\n\r\n    // You can use EventBusSubscriber to automatically register all static methods in the class annotated with @SubscribeEvent\r\n    @Mod.EventBusSubscriber(modid = MODID, bus = Mod.EventBusSubscriber.Bus.MOD, value = Dist.CLIENT)\r\n    public static class ClientModEvents {\r\n\r\n        @SubscribeEvent\r\n        public static void onRegisterRenderers(EntityRenderersEvent.RegisterRenderers event) {\r\n            event.registerBlockEntityRenderer(ImmortalersDelightBlockEntityTypes.SIGN.get(), ImmortalersDelightSignRenderer::new);\r\n            event.registerBlockEntityRenderer(ImmortalersDelightBlockEntityTypes.HANGING_SIGN.get(), ImmortalersDelightHangingSignRenderer::new);\r\n            event.registerBlockEntityRenderer(ImmortalersDelightBlocks.ANCIENT_STOVE_ENTITY.get(), AncientStoveBlockEntityRenderer::new);\r\n        }\r\n\r\n        @SubscribeEvent\r\n        public static void onClientSetup(FMLClientSetupEvent event) {\r\n            EntityRenderers.register(ImmortalersDelightEntities.HIMEKAIDO_BOAT.get(), pContext -> new ImmortalersBoatRenderer(pContext, false));\r\n            EntityRenderers.register(ImmortalersDelightEntities.HIMEKAIDO_CHEST_BOAT.get(), pContext -> new ImmortalersBoatRenderer(pContext, true));\r\n\r\n            MenuScreens.register(ImmortalersDelightMenuTypes.ENCHANTAL_COOLER_MENU.get(), EnchantalCoolerScreen::new);\r\n            // Some client setup code\r\n            LOGGER.info(\"HELLO FROM CLIENT SETUP\");\r\n            LOGGER.info(\"MINECRAFT NAME >> {}\", Minecraft.getInstance().getUser().getName());\r\n            WeakWitherHealthOverlay.init();\r\n            WeakPoisonHealthOverlay.init();\r\n            AftertasteHungerOverlay.init();\r\n            KeepFastHungerOverlay.init();\r\n            BurnTheBoatsHealthOverlay.init();\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/ImmortalersDelightMod.java b/src/main/java/com/renyigesai/immortalers_delight/ImmortalersDelightMod.java
--- a/src/main/java/com/renyigesai/immortalers_delight/ImmortalersDelightMod.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/ImmortalersDelightMod.java	
@@ -1,7 +1,6 @@
 package com.renyigesai.immortalers_delight;
 
 import com.mojang.logging.LogUtils;
-import com.renyigesai.immortalers_delight.block.ancient_stove.AncientStoveBlockEntity;
 import com.renyigesai.immortalers_delight.client.renderer.AncientStoveBlockEntityRenderer;
 import com.renyigesai.immortalers_delight.client.renderer.ImmortalersBoatRenderer;
 import com.renyigesai.immortalers_delight.client.renderer.ImmortalersDelightHangingSignRenderer;
@@ -30,8 +29,6 @@
 import net.minecraftforge.registries.ForgeRegistries;
 import org.slf4j.Logger;
 
-import java.util.Locale;
-
 // The value here should match an entry in the META-INF/mods.toml file
 @Mod(ImmortalersDelightMod.MODID)
 public class ImmortalersDelightMod {
Index: src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightBlockEntityTypes.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.init;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.block.hanging_sign.ImmortalersDelightHangingSignBlockEntity;\r\nimport com.renyigesai.immortalers_delight.block.sign.ImmortalersDelightSignBlockEntity;\r\nimport net.minecraft.world.level.block.Block;\r\nimport net.minecraft.world.level.block.entity.BlockEntityType;\r\nimport net.minecraft.world.level.block.entity.HangingSignBlockEntity;\r\nimport net.minecraftforge.registries.DeferredRegister;\r\nimport net.minecraftforge.registries.ForgeRegistries;\r\nimport net.minecraftforge.registries.RegistryObject;\r\n\r\npublic class ImmortalersDelightBlockEntityTypes{\r\n\r\n    public static final DeferredRegister<BlockEntityType<?>> TILES =  DeferredRegister.create(ForgeRegistries.BLOCK_ENTITY_TYPES, ImmortalersDelightMod.MODID);\r\n    public static final RegistryObject<BlockEntityType<ImmortalersDelightSignBlockEntity>> SIGN = TILES.register(\"sign\", () ->\r\n            BlockEntityType.Builder.of(ImmortalersDelightSignBlockEntity::new,\r\n                    new Block[]{\r\n                            ImmortalersDelightBlocks.HIMEKAIDO_SIGN.get(),\r\n                            ImmortalersDelightBlocks.HIMEKAIDO_WALL_SIGN.get(),\r\n                            ImmortalersDelightBlocks.LEISAMBOO_SIGN.get(),\r\n                            ImmortalersDelightBlocks.LEISAMBOO_WALL_SIGN.get()\r\n            }).build(null));\r\n    public static final RegistryObject<BlockEntityType<ImmortalersDelightHangingSignBlockEntity>> HANGING_SIGN = TILES.register(\"hanging_sign\", () ->\r\n            BlockEntityType.Builder.of(ImmortalersDelightHangingSignBlockEntity::new,\r\n                    new Block[]{\r\n                            ImmortalersDelightBlocks.HIMEKAIDO_HANGING_SIGN.get(),\r\n                            ImmortalersDelightBlocks.HIMEKAIDO_WALL_HANGING_SIGN.get(),\r\n                            ImmortalersDelightBlocks.LEISAMBOO_HANGING_SIGN.get(),\r\n                            ImmortalersDelightBlocks.LEISAMBOO_WALL_HANGING_SIGN.get()\r\n            }).build(null));\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightBlockEntityTypes.java b/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightBlockEntityTypes.java
--- a/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightBlockEntityTypes.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightBlockEntityTypes.java	
@@ -5,7 +5,6 @@
 import com.renyigesai.immortalers_delight.block.sign.ImmortalersDelightSignBlockEntity;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.entity.BlockEntityType;
-import net.minecraft.world.level.block.entity.HangingSignBlockEntity;
 import net.minecraftforge.registries.DeferredRegister;
 import net.minecraftforge.registries.ForgeRegistries;
 import net.minecraftforge.registries.RegistryObject;
Index: src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightItems.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.init;\r\n\r\nimport com.google.common.collect.Sets;\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.entities.ImmortalersBoat;\r\nimport com.renyigesai.immortalers_delight.entities.ImmortalersChestBoat;\r\nimport com.renyigesai.immortalers_delight.item.*;\r\nimport com.renyigesai.immortalers_delight.util.datautil.worlddata.BaseImmortalWorldData;\r\nimport net.minecraft.world.food.FoodProperties;\r\nimport net.minecraft.world.item.*;\r\nimport net.minecraft.world.level.block.Block;\r\nimport net.minecraftforge.registries.DeferredRegister;\r\nimport net.minecraftforge.registries.ForgeRegistries;\r\nimport net.minecraftforge.registries.RegistryObject;\r\nimport vectorwing.farmersdelight.common.item.ConsumableItem;\r\nimport vectorwing.farmersdelight.common.item.DrinkableItem;\r\n\r\nimport java.util.LinkedHashSet;\r\nimport java.util.function.Supplier;\r\n\r\n\r\npublic class ImmortalersDelightItems {\r\n\r\n\r\n    public static final DeferredRegister<Item> REGISTER = DeferredRegister.create(ForgeRegistries.ITEMS, ImmortalersDelightMod.MODID);\r\n    public static LinkedHashSet<RegistryObject<Item>> CREATIVE_TAB_ITEMS = Sets.newLinkedHashSet();\r\n    public static final RegistryObject<Item> HIMEKAIDO_LOG;\r\n    public static final RegistryObject<Item> HIMEKAIDO_WOOD;\r\n    public static final RegistryObject<Item> STRIPPED_HIMEKAIDO_WOOD;\r\n    public static final RegistryObject<Item> STRIPPED_HIMEKAIDO_LOG;\r\n    public static final RegistryObject<Item> HIMEKAIDO_FRUITED_LEAVES;\r\n    public static final RegistryObject<Item> HIMEKAIDO_FLOWERING_LEAVES;\r\n    public static final RegistryObject<Item> HIMEKAIDO_LEAVES;\r\n    public static final RegistryObject<Item> HIMEKAIDO_PLANKS;\r\n    public static final RegistryObject<Item> HIMEKAIDO_STAIRS;\r\n    public static final RegistryObject<Item> HIMEKAIDO_SLAB;\r\n    public static final RegistryObject<Item> HIMEKAIDO_DOOR;\r\n    public static final RegistryObject<Item> HIMEKAIDO_TRAPDOOR;\r\n    public static final RegistryObject<Item> HIMEKAIDO_FENCE;\r\n    public static final RegistryObject<Item> HIMEKAIDO_FENCE_GATE;\r\n    public static final RegistryObject<Item> HIMEKAIDO_PRESSURE_PLATE;\r\n    public static final RegistryObject<Item> HIMEKAIDO_BUTTON;\r\n    public static final RegistryObject<Item> HIMEKAIDO_CABINET;\r\n    public static final RegistryObject<Item> HIMEKAIDO_BOAT;\r\n    public static final RegistryObject<Item> HIMEKAIDO_CHEST_BOAT;\r\n    public static final RegistryObject<Item> MILLENIAN_BAMBOO;\r\n    public static final RegistryObject<Item> STEWED_ROTTEN_MEAT_POT;\r\n    public static final RegistryObject<Item> BRAISED_SPIDER_EYES_BLOCK;\r\n    public static final RegistryObject<Item> EVOLUTCORN_GRAIN_BAG;\r\n    public static final RegistryObject<Item> HIMEKAIDO_CRATE;\r\n    public static final RegistryObject<Item> PEARLIP_CRATE;\r\n    public static final RegistryObject<Item> EVOLUTCORN_BLOCK;\r\n    public static final RegistryObject<Item> HIMEKAIDO_SIGN;\r\n    public static final RegistryObject<Item> HIMEKAIDO_HANGING_SIGN;\r\n    public static final RegistryObject<Item> LEISAMBOO_PLANKS;\r\n    public static final RegistryObject<Item> LEISAMBOO_STAIRS;\r\n    public static final RegistryObject<Item> LEISAMBOO_SLAB;\r\n    public static final RegistryObject<Item> LEISAMBOO_FENCE;\r\n    public static final RegistryObject<Item> LEISAMBOO_FENCE_GATE;\r\n    public static final RegistryObject<Item> LEISAMBOO_PRESSURE_PLATE;\r\n    public static final RegistryObject<Item> LEISAMBOO_BUTTON;\r\n    public static final RegistryObject<Item> LEISAMBOO_SIGN;\r\n    public static final RegistryObject<Item> LEISAMBOO_HANGING_SIGN;\r\n    public static final RegistryObject<Item> ANCIENT_FIBER;\r\n    public static final RegistryObject<Item> BOWL_OF_MILLENIAN_BAMBOO;\r\n    public static final RegistryObject<Item> PITCHER_POD_PETAL;\r\n    /*\r\n    玉米系列物品\r\n    */\r\n    public static final RegistryObject<Item> EVOLUTCORN;\r\n    public static final RegistryObject<Item> ROAST_EVOLUTCORN;\r\n    public static final RegistryObject<Item> EVOLUTCORN_GRAINS;\r\n    public static final RegistryObject<Item> ROAST_EVOLUTCORN_CHOPS;\r\n    public static final RegistryObject<Item> POPOLUTCORN;\r\n    public static final RegistryObject<Item> CRETACEOUS_ZEA_BALL;\r\n    public static final RegistryObject<Item> COLORFUL_GRILLED_SKEWERS;\r\n    public static final RegistryObject<Item> ZEA_PANCAKE;\r\n    public static final RegistryObject<Item> ZEA_PANCAKE_SLICE;\r\n    public static final RegistryObject<Item> EVOLUTCORN_PIE_CRUST;\r\n    public static final RegistryObject<Item> EVOLUTCORN_BEER;\r\n    /*\r\n    香蕉系列物品\r\n    */\r\n    public static final RegistryObject<Item> PEARLIP;\r\n    public static final RegistryObject<Item> PEARLIP_SHELL;\r\n    public static final RegistryObject<Item> PEARLIPEARL;\r\n    public static final RegistryObject<Item> PEATIC_MUSA_SALAD;\r\n    public static final RegistryObject<Item> PEARLIP_MILK_SHAKE;\r\n    public static final RegistryObject<Item> PEARLIP_PUMPKIN_PIE;\r\n    public static final RegistryObject<Item> PEARLIPEARL_TART;\r\n    public static final RegistryObject<Item> PEARLIPEARL_EGGSTEAM;\r\n    public static final RegistryObject<Item> PEARLIP_JELLY;\r\n    public static final RegistryObject<Item> PEARLIP_PIE;\r\n    public static final RegistryObject<Item> PEARLIP_PIE_SLICE;\r\n    public static final RegistryObject<Item> ICE_PEARLIP;\r\n    public static final RegistryObject<Item> CHOCOLATE_PEARLIP_STICKS;\r\n    /*\r\n    姬海棠系列物品\r\n     */\r\n    public static final RegistryObject<Item> MASHED_POTATOES;\r\n    public static final RegistryObject<Item> MASHED_POISONOUS_POTATO;\r\n    public static final RegistryObject<Item> MASHED_POTATO_WITH_JAM;\r\n    public static final RegistryObject<Item> MASHED_POISONOUS_POTATO_WITH_JAM;\r\n    public static final RegistryObject<Item> ROTTEN_FLESH_CUTS;\r\n    public static final RegistryObject<Item> HIMEKAIDO_JELLY;\r\n    public static final RegistryObject<Item> YOGURT;\r\n    public static final RegistryObject<Item> HIMEKAIDO;\r\n    public static final RegistryObject<Item> BAKED_POISONOUS_POTATO;\r\n    public static final RegistryObject<Item> BRAISED_SPIDER_EYES_IN_GRAVY;\r\n    public static final RegistryObject<Item> DIPPED_ROTTEN_FLESH;\r\n    public static final RegistryObject<Item> CRISPY_YOGURT_ROTTEN_FLESH;\r\n    public static final RegistryObject<Item> MEATY_ROTTEN_TOMATO_BROTH;\r\n    public static final RegistryObject<Item> STUFFED_POISONOUS_POTATO;\r\n    public static final RegistryObject<Item> PUFFERFISH_ROLL;\r\n    public static final RegistryObject<Item> GOLDEN_HIMEKAIDO;\r\n    public static final RegistryObject<Item> ENCHANTED_GOLDEN_HIMEKAIDO;\r\n    public static final RegistryObject<Item> HIMEKAIDO_SEED;\r\n    public static final RegistryObject<Item> BOWL_OF_STEWED_ROTTEN_MEAT_IN_CLAY_POT;\r\n    public static final RegistryObject<Item> TARTARE_CHICKEN;\r\n    public static final RegistryObject<Item> ENCHANTAL_COOLER;\r\n    public static final RegistryObject<Item> ANCIENT_STOVE;\r\n    public static final RegistryObject<Item> OXIDIZED_ANCIENT_STOVE;\r\n    public static final RegistryObject<Item> HIMEKAIDO_YOGURT_PIE;\r\n    public static final RegistryObject<Item> HIMEKAIDO_YOGURT_PIE_SLICE;\r\n    public static final RegistryObject<Item> DREUMK_WINE;\r\n    /*\r\n    古木相关\r\n    */\r\n    public static final RegistryObject<Item> ANCIENT_WOOD_LOG;\r\n    public static final RegistryObject<Item> STRIPPED_ANCIENT_WOOD_LOG;\r\n    public static final RegistryObject<Item> ANCIENT_WOOD;\r\n    public static final RegistryObject<Item> STRIPPED_ANCIENT_WOOD;\r\n    public static final RegistryObject<Item> ANCIENT_WOOD_PLANKS;\r\n    public static final RegistryObject<Item> ANCIENT_WOOD_CABINET;\r\n    public static final RegistryObject<Item> ANCIENT_WOOD_STAIRS;\r\n    public static final RegistryObject<Item> ANCIENT_WOOD_SLAB;\r\n    public static final RegistryObject<Item> ANCIENT_WOOD_DOOR;\r\n    public static final RegistryObject<Item> ANCIENT_WOOD_TRAPDOOR;\r\n    public static final RegistryObject<Item> ANCIENT_WOOD_FENCE;\r\n    public static final RegistryObject<Item> ANCIENT_WOOD_FENCE_GATE;\r\n    public static final RegistryObject<Item> ANCIENT_WOOD_PRESSURE_PLATE;\r\n    public static final RegistryObject<Item> ANCIENT_WOOD_BUTTON;\r\n\r\n    /*\r\n     溪竹相关物品\r\n     */\r\n    public static final RegistryObject<Item> LEAF_TEA;\r\n    public static final RegistryObject<Item> CONTAINS_TEA_LEISAMBOO;\r\n    public static final RegistryObject<Item> EMPTY_BAMBOO_CUP;\r\n    public static final RegistryObject<Item> LEISAMBOO_TEA;\r\n    public static final RegistryObject<Item> ICED_BLACK_TEA;\r\n    public static final RegistryObject<Item> PEARLIPEARL_MILK_TEA;\r\n    public static final RegistryObject<Item> PEARLIPEARL_MILK_GREEN;\r\n    public static final RegistryObject<Item> STOVE_BLACK_TEA;\r\n    public static final RegistryObject<Item> LEAF_GREEN_TEA;\r\n    public static final RegistryObject<Item> BRITISH_YELLOW_TEA;\r\n    public static final RegistryObject<Item> LEISAMBOO_TEA_CAKE;\r\n\r\n    /*\r\n    瓦斯麦相关物品\r\n    */\r\n    public static final RegistryObject<Item> KWAT_WHEAT_SEEDS;\r\n    public static final RegistryObject<Item> KWAT_WHEAT;\r\n    public static final RegistryObject<Item> KWAT_WHEAT_DOUGH;\r\n    public static final RegistryObject<Item> KWAT_WHEAT_PASTE;\r\n    public static final RegistryObject<Item> KWAT_WHEAT_DOUFU;\r\n    public static final RegistryObject<Item> FRY_KWAT_WHEAT_DOUFU;\r\n    public static final RegistryObject<Item> SUTFFED_KWAT_WHEAT_DOUFU;\r\n    public static final RegistryObject<Item> JADE_AND_RUBY_SOUP;\r\n    public static final RegistryObject<Item> KWAT_WHEAT_TOAST;\r\n    public static final RegistryObject<Item> KWAT_WHEAT_TOAST_SLICE;\r\n    public static final RegistryObject<Item> NETHER_BREAD_CREAM_SOUP;\r\n    public static final RegistryObject<Item> NETHER_CREAM_SOUP;\r\n    public static final RegistryObject<Item> NETHER_CREAM_BREAD;\r\n    /*\r\n    火把花相关物品\r\n    */\r\n    public static final RegistryObject<Item> TORCHFLOWER_MUSTARD;\r\n    public static final RegistryObject<Item> HOT_HI_SOUP;\r\n    public static final RegistryObject<Item> INCANDESCENCE_SUSHI;\r\n    public static final RegistryObject<Item> TORCHFLOWER_CAKE;\r\n    public static final RegistryObject<Item> TORCHFLOWER_CURRY_RICE;\r\n    public static final RegistryObject<Item> EXTRA_SPICY_PASTA;\r\n    public static final RegistryObject<Item> TORCHFLOWER_COOKIE;\r\n\r\n\r\n    public static final RegistryObject<Item> PITCHER_PLANT_BARBECUE;\r\n    public static final RegistryObject<Item> POD_SHELL_BURGER_MEAT;\r\n    public static final RegistryObject<Item> POD_SHELL_BURGER_MEAT_CUBE;\r\n\r\n    public static final RegistryObject<Item> GOLDEN_FABRIC;\r\n    public static final RegistryObject<Item> GOLDEN_FABRIC_VEIL;\r\n    public static final RegistryObject<Item> RAW_SNIFFER_SLICE;\r\n    public static final RegistryObject<Item> COOKED_SNIFFER_SLICE;\r\n    public static final RegistryObject<Item> RAW_SNIFFER_STEAK;\r\n    public static final RegistryObject<Item> COOKED_SNIFFER_STEAK;\r\n    public static final RegistryObject<Item> SNIFFER_HIDE;\r\n    public static final RegistryObject<Item> CLEAR_WATER_VODKA;\r\n    public static final RegistryObject<Item> SNIFFER_ROTATING_ROAST_MEAT;\r\n    public static final RegistryObject<Item> VULCAN_COKTAIL;\r\n    public static final RegistryObject<Item> NETHER_KVASS;\r\n    public static final RegistryObject<Item> PURGATORY_ALE;\r\n    //public static final RegistryObject<Item> TEST_DAMAGE_ITEM;\r\n\r\n\r\n    static {\r\n\r\n        ENCHANTAL_COOLER = block(ImmortalersDelightBlocks.ENCHANTAL_COOLER);\r\n\r\n        ANCIENT_STOVE = block(ImmortalersDelightBlocks.ANCIENT_STOVE);\r\n\r\n        OXIDIZED_ANCIENT_STOVE = block(ImmortalersDelightBlocks.OXIDIZED_ANCIENT_STOVE);\r\n\r\n        EVOLUTCORN_GRAIN_BAG = registerWithTab(\"evolutcorn_grain_bag\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.EVOLUTCORN_GRAIN_BAG.get(), basicItem()));\r\n\r\n        HIMEKAIDO_CRATE = registerWithTab(\"himekaido_crate\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.HIMEKAIDO_CRATE.get(), basicItem()));\r\n\r\n        PEARLIP_CRATE = registerWithTab(\"pearlip_crate\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.PEARLIP_CRATE.get(), basicItem()));\r\n\r\n        EVOLUTCORN_BLOCK = registerWithTab(\"evolutcorn_block\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.EVOLUTCORN_BLOCK.get(), basicItem()));\r\n\r\n        HIMEKAIDO_LOG = registerWithTab(\"himekaido_log\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.HIMEKAIDO_LOG.get(), basicItem()));\r\n        HIMEKAIDO_WOOD = registerWithTab(\"himekaido_wood\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.HIMEKAIDO_WOOD.get(), basicItem()));\r\n\r\n        STRIPPED_HIMEKAIDO_WOOD = registerWithTab(\"stripped_himekaido_wood\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.STRIPPED_HIMEKAIDO_WOOD.get(), basicItem()));\r\n\r\n        STRIPPED_HIMEKAIDO_LOG = registerWithTab(\"stripped_himekaido_log\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.STRIPPED_HIMEKAIDO_LOG.get(), basicItem()));\r\n\r\n        HIMEKAIDO_FRUITED_LEAVES = registerWithTab(\"himekaido_fruited_leaves\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.HIMEKAIDO_FRUITED_LEAVES.get(), basicItem()));\r\n\r\n        HIMEKAIDO_FLOWERING_LEAVES = registerWithTab(\"himekaido_flowering_leaves\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.HIMEKAIDO_FLOWERING_LEAVES.get(), basicItem()));\r\n\r\n        HIMEKAIDO_LEAVES = registerWithTab(\"himekaido_leaves\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.HIMEKAIDO_LEAVES.get(), basicItem()));\r\n\r\n        HIMEKAIDO_PLANKS = registerWithTab(\"himekaido_planks\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.HIMEKAIDO_PLANKS.get(), basicItem()));\r\n        HIMEKAIDO_CABINET = registerWithTab(\"himekaido_cabinet\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.HIMEKAIDO_CABINET.get(), basicItem()));\r\n        HIMEKAIDO_STAIRS = registerWithTab(\"himekaido_stairs\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.HIMEKAIDO_STAIRS.get(), basicItem()));\r\n\r\n        HIMEKAIDO_SLAB = registerWithTab(\"himekaido_slab\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.HIMEKAIDO_SLAB.get(), basicItem()));\r\n\r\n        HIMEKAIDO_DOOR = registerWithTab(\"himekaido_door\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.HIMEKAIDO_DOOR.get(), basicItem()));\r\n\r\n        HIMEKAIDO_TRAPDOOR = registerWithTab(\"himekaido_trapdoor\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.HIMEKAIDO_TRAPDOOR.get(), basicItem()));\r\n\r\n        HIMEKAIDO_FENCE = registerWithTab(\"himekaido_fence\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.HIMEKAIDO_FENCE.get(), basicItem()));\r\n\r\n        HIMEKAIDO_FENCE_GATE = registerWithTab(\"himekaido_fence_gate\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.HIMEKAIDO_FENCE_GATE.get(), basicItem()));\r\n\r\n        HIMEKAIDO_PRESSURE_PLATE = registerWithTab(\"himekaido_pressure_plate\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.HIMEKAIDO_PRESSURE_PLATE.get(), basicItem()));\r\n\r\n        HIMEKAIDO_BUTTON = registerWithTab(\"himekaido_button\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.HIMEKAIDO_BUTTON.get(), basicItem()));\r\n        HIMEKAIDO_SIGN = registerWithTab(\"himekaido_sign\",() ->\r\n                new SignItem((new Item.Properties()).stacksTo(16),\r\n                        ImmortalersDelightBlocks.HIMEKAIDO_SIGN.get(),\r\n                        ImmortalersDelightBlocks.HIMEKAIDO_WALL_SIGN.get()\r\n                        ));\r\n        HIMEKAIDO_HANGING_SIGN = registerWithTab(\"himekaido_hanging_sign\",() ->\r\n                new HangingSignItem(\r\n                        ImmortalersDelightBlocks.HIMEKAIDO_HANGING_SIGN.get(),\r\n                        ImmortalersDelightBlocks.HIMEKAIDO_WALL_HANGING_SIGN.get(),\r\n                        (new Item.Properties()).stacksTo(16)\r\n                ));\r\n        HIMEKAIDO_BOAT = registerWithTab(\"himekaido_boat\",()->\r\n                new ImmortalersBoatItem(ImmortalersBoat.Type.HIMEKAIDO, basicItem().stacksTo(1)));\r\n\r\n        HIMEKAIDO_CHEST_BOAT = registerWithTab(\"himekaido_chest_boat\",()->\r\n                new ImmortalersChestBoatItem(ImmortalersChestBoat.Type.HIMEKAIDO, basicItem().stacksTo(1)));\r\n\r\n        LEISAMBOO_PLANKS = registerWithTab(\"leisamboo_planks\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.LEISAMBOO_PLANKS.get(), basicItem()));\r\n\r\n        LEISAMBOO_STAIRS = registerWithTab(\"leisamboo_stairs\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.LEISAMBOO_STAIRS.get(), basicItem()));\r\n\r\n        LEISAMBOO_SLAB = registerWithTab(\"leisamboo_slab\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.LEISAMBOO_SLAB.get(), basicItem()));\r\n\r\n        LEISAMBOO_FENCE = registerWithTab(\"leisamboo_fence\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.LEISAMBOO_FENCE.get(), basicItem()));\r\n\r\n        LEISAMBOO_FENCE_GATE = registerWithTab(\"leisamboo_fence_gate\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.LEISAMBOO_FENCE_GATE.get(), basicItem()));\r\n\r\n        LEISAMBOO_PRESSURE_PLATE = registerWithTab(\"leisamboo_pressure_plate\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.LEISAMBOO_PRESSURE_PLATE.get(), basicItem()));\r\n\r\n        LEISAMBOO_BUTTON = registerWithTab(\"leisamboo_button\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.LEISAMBOO_BUTTON.get(), basicItem()));\r\n        LEISAMBOO_SIGN = registerWithTab(\"leisamboo_sign\",() ->\r\n                new SignItem((new Item.Properties()).stacksTo(16),\r\n                        ImmortalersDelightBlocks.LEISAMBOO_SIGN.get(),\r\n                        ImmortalersDelightBlocks.LEISAMBOO_WALL_SIGN.get()\r\n                ));\r\n        LEISAMBOO_HANGING_SIGN = registerWithTab(\"leisamboo_hanging_sign\",() ->\r\n                new HangingSignItem(\r\n                        ImmortalersDelightBlocks.LEISAMBOO_HANGING_SIGN.get(),\r\n                        ImmortalersDelightBlocks.LEISAMBOO_WALL_HANGING_SIGN.get(),\r\n                        (new Item.Properties()).stacksTo(16)\r\n                ));\r\n\r\n        /*\r\n        古木\r\n        */\r\n        ANCIENT_WOOD_LOG = block(ImmortalersDelightBlocks.ANCIENT_WOOD_LOG);\r\n        STRIPPED_ANCIENT_WOOD_LOG = block(ImmortalersDelightBlocks.STRIPPED_ANCIENT_WOOD_LOG);\r\n        ANCIENT_WOOD = block(ImmortalersDelightBlocks.ANCIENT_WOOD);\r\n        STRIPPED_ANCIENT_WOOD = block(ImmortalersDelightBlocks.STRIPPED_ANCIENT_WOOD);\r\n        ANCIENT_WOOD_PLANKS = block(ImmortalersDelightBlocks.ANCIENT_WOOD_PLANKS);\r\n        ANCIENT_WOOD_CABINET = block(ImmortalersDelightBlocks.ANCIENT_WOOD_CABINET);\r\n        ANCIENT_WOOD_SLAB = block(ImmortalersDelightBlocks.ANCIENT_WOOD_SLAB);\r\n        ANCIENT_WOOD_DOOR = block(ImmortalersDelightBlocks.ANCIENT_WOOD_DOOR);\r\n        ANCIENT_WOOD_TRAPDOOR = block(ImmortalersDelightBlocks.ANCIENT_WOOD_TRAPDOOR);\r\n        ANCIENT_WOOD_STAIRS = block(ImmortalersDelightBlocks.ANCIENT_WOOD_STAIRS);\r\n        ANCIENT_WOOD_FENCE = block(ImmortalersDelightBlocks.ANCIENT_WOOD_FENCE);\r\n        ANCIENT_WOOD_FENCE_GATE = block(ImmortalersDelightBlocks.ANCIENT_WOOD_FENCE_GATE);\r\n        ANCIENT_WOOD_PRESSURE_PLATE = block(ImmortalersDelightBlocks.ANCIENT_WOOD_PRESSURE_PLATE);\r\n        ANCIENT_WOOD_BUTTON = block(ImmortalersDelightBlocks.ANCIENT_WOOD_BUTTON);\r\n\r\n        ANCIENT_FIBER = registerWithTab(\"ancient_fiber\", () ->\r\n                new Item(basicItem()));\r\n        /*\r\n        材料类物品\r\n        */\r\n\r\n        EVOLUTCORN = registerWithTab(\"evolutcorn\", () ->\r\n                new Item(foodItem(ImmortalersDelightFoodProperties.EVOLUTCORN)));\r\n\r\n        ROAST_EVOLUTCORN = registerWithTab(\"roast_evolutcorn\", () ->\r\n                new Item(foodItem(ImmortalersDelightFoodProperties.ROAST_EVOLUTCORN)));\r\n\r\n        EVOLUTCORN_GRAINS = registerWithTab(\"evolutcorn_grains\", () ->\r\n                new ItemNameBlockItem(ImmortalersDelightBlocks.EVOLUTCORN.get(), new Item.Properties().food(ImmortalersDelightFoodProperties.EVOLUTCORN_GRAINS)));\r\n\r\n        ROAST_EVOLUTCORN_CHOPS = registerWithTab(\"roast_evolutcorn_chops\", () ->\r\n                new Item(foodItem(ImmortalersDelightFoodProperties.ROAST_EVOLUTCORN_CHOPS)));\r\n\r\n        PEARLIP = registerWithTab(\"pearlip\", () ->\r\n                new ItemNameBlockItem(ImmortalersDelightBlocks.PEARLIPEARL_BUNDLE.get(), new Item.Properties().food(ImmortalersDelightFoodProperties.PEARLIP)));\r\n\r\n        PEARLIPEARL = registerWithTab(\"pearlipearl\", () ->\r\n                new ItemNameBlockItem(ImmortalersDelightBlocks.PEARLIPEARL_STALK.get(), new Item.Properties().food(ImmortalersDelightFoodProperties.PEARLIPEARL)));\r\n\r\n        PEARLIP_SHELL = registerWithTab(\"pearlip_shell\", () ->\r\n                new Item(basicItem()));\r\n\r\n        CONTAINS_TEA_LEISAMBOO = registerWithTab(\"contains_tea_leisamboo\",()->\r\n                new ItemNameBlockItem(ImmortalersDelightBlocks.LEISAMBOO_CROP.get(),new Item.Properties()));\r\n\r\n        HIMEKAIDO_SEED = registerWithTab(\"himekaido_seed\", () ->\r\n                new ItemNameBlockItem(ImmortalersDelightBlocks.HIMEKAIDO_SHRUB.get(), new Item.Properties()));\r\n\r\n        ROTTEN_FLESH_CUTS = registerWithTab(\"rotten_flesh_cuts\", () ->\r\n                new Item(new Item.Properties()));\r\n\r\n        PITCHER_POD_PETAL = registerWithTab(\"pitcher_pod_petal\",()->\r\n                new Item(new Item.Properties()));\r\n\r\n        KWAT_WHEAT_SEEDS =  registerWithTab(\"kwat_wheat_seeds\",()->\r\n                new ItemNameBlockItem(ImmortalersDelightBlocks.KWAT_WHEAT.get(), new Item.Properties()));\r\n\r\n        KWAT_WHEAT = registerWithTab(\"kwat_wheat\", () ->\r\n                new GasToxicFoodItem(fantasticFoodItem(ImmortalersDelightFoodProperties.KWAT_WHEAT, Rarity.COMMON, false),true,false));\r\n\r\n        /*\r\n        玉米系列物品\r\n        */\r\n\r\n        CRETACEOUS_ZEA_BALL = registerWithTab(\"cretaceous_zea_ball\", () ->\r\n                new ConsumableItem(foodItem(ImmortalersDelightFoodProperties.CRETACEOUS_ZEA_BALL), true));\r\n\r\n        COLORFUL_GRILLED_SKEWERS = registerWithTab(\"colorful_grilled_skewers\", () ->\r\n                new Item(foodItem(ImmortalersDelightFoodProperties.COLORFUL_GRILLED_SKEWERS)));\r\n\r\n        POPOLUTCORN = registerWithTab(\"popolutcorn\", () ->\r\n                new ConsumableItem(new Item.Properties().food(ImmortalersDelightFoodProperties.POPOLUTCORN), true));\r\n\r\n        ZEA_PANCAKE = registerWithTab(\"zea_pancake\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.ZEA_PANCAKE.get(), basicItem()));\r\n\r\n        ZEA_PANCAKE_SLICE = registerWithTab(\"zea_pancake_slice\", () ->\r\n                new Item(foodItem(ImmortalersDelightFoodProperties.ZEA_PANCAKE_SLICE)));\r\n\r\n        EVOLUTCORN_PIE_CRUST = registerWithTab(\"evolutcorn_pie_crust\",()->\r\n                new Item(new Item.Properties()));\r\n\r\n        PEARLIP_PIE = block(ImmortalersDelightBlocks.PEARLIP_PIE);\r\n\r\n        PEARLIP_PIE_SLICE = foodItem(\"pearlip_pie_slice\",ImmortalersDelightFoodProperties.PEARLIP_PIE_SLICE);\r\n\r\n        PEATIC_MUSA_SALAD = registerWithTab(\"peatic_musa_salad\", () ->\r\n                new ConsumableItem(bowlFoodItem(ImmortalersDelightFoodProperties.PEATIC_MUSA_SALAD), true));\r\n\r\n        /*\r\n        香蕉系列物品\r\n        */\r\n\r\n        PEARLIP_MILK_SHAKE = registerWithTab(\"pearlip_milk_shake\", () ->\r\n                new DrinkableItem(new Item.Properties().craftRemainder(Items.GLASS_BOTTLE).stacksTo(16).food(ImmortalersDelightFoodProperties.PEARLIP_MILK_SHAKE), true, false));\r\n\r\n        PEARLIP_PUMPKIN_PIE = registerWithTab(\"pearlip_pumpkin_pie\", () ->\r\n                new Item(foodItem(ImmortalersDelightFoodProperties.PEARLIP_PUMPKIN_PIE)));\r\n\r\n        PEARLIPEARL_EGGSTEAM = registerWithTab(\"pearlipearl_eggsteam\", () ->\r\n                new ConsumableItem(foodItem(ImmortalersDelightFoodProperties.PEARLIPEARL_EGGSTEAM), true));\r\n\r\n        PEARLIP_JELLY = registerWithTab(\"pearlip_jelly\", () ->\r\n                new ConsumableItem(foodItem(ImmortalersDelightFoodProperties.PEARLIP_JELLY), true));\r\n\r\n        PEARLIPEARL_TART = registerWithTab(\"pearlipearl_tart\", () ->\r\n                new Item(foodItem(ImmortalersDelightFoodProperties.PEARLIPEARL_TART)));\r\n\r\n        ICE_PEARLIP = foodItem(\"ice_pearlip\",ImmortalersDelightFoodProperties.ICE_PEARLIP);\r\n\r\n        CHOCOLATE_PEARLIP_STICKS = foodItem(\"chocolate_pearlip_sticks\",ImmortalersDelightFoodProperties.CHOCOLATE_PEARLIP_STICKS);\r\n        /*\r\n         溪竹相关物品\r\n        */\r\n        LEAF_TEA = registerWithTab(\"leaf_tea\",()->\r\n                new DrinkableItem(drinkItem(ImmortalersDelightFoodProperties.LEAF_TEA),true, false));\r\n\r\n        EMPTY_BAMBOO_CUP = registerWithTab(\"empty_bamboo_cup\", () ->\r\n                new Item(new Item.Properties().stacksTo(16)));\r\n\r\n        LEISAMBOO_TEA = registerWithTab(\"leisamboo_tea\", () ->\r\n                new DrinkableItem(leisambooDrinksItem(ImmortalersDelightFoodProperties.LEISAMBOO_TEA),true, false));\r\n\r\n        ICED_BLACK_TEA = registerWithTab(\"iced_black_tea\",() ->\r\n                new DrinkableItem(drinkItem(ImmortalersDelightFoodProperties.ICED_BLACK_TEA),true, false));\r\n\r\n        PEARLIPEARL_MILK_TEA = registerWithTab(\"pearlipearl_milk_tea\",() ->\r\n                new DrinkableItem(drinkItem(ImmortalersDelightFoodProperties.PEARLIPEARL_MILK_TEA),true, false));\r\n\r\n        PEARLIPEARL_MILK_GREEN = registerWithTab(\"pearlipearl_milk_green\",() ->\r\n                new DrinkableItem(drinkItem(ImmortalersDelightFoodProperties.PEARLIPEARL_MILK_GREEN),true, false));\r\n\r\n        STOVE_BLACK_TEA = registerWithTab(\"stove_black_tea\",() ->\r\n                new DrinkableItem(drinkItem(ImmortalersDelightFoodProperties.STOVE_BLACK_TEA),true, false));\r\n\r\n        LEAF_GREEN_TEA = registerWithTab(\"leaf_green_tea\",() ->\r\n                new DrinkableItem(drinkItem(ImmortalersDelightFoodProperties.LEAF_GREEN_TEA),true, false));\r\n\r\n        BRITISH_YELLOW_TEA = registerWithTab(\"british_yellow_tea\",() ->\r\n                new DrinkableItem(drinkItem(ImmortalersDelightFoodProperties.BRITISH_YELLOW_TEA),true, false));\r\n\r\n        MILLENIAN_BAMBOO = registerWithTab(\"millenian_bamboo\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.MILLENIAN_BAMBOO.get(), basicItem()));\r\n\r\n        BOWL_OF_MILLENIAN_BAMBOO = registerWithTab(\"bowl_of_millenian_bamboo\", () ->\r\n                new ConsumableItem(bowlFoodItem(ImmortalersDelightFoodProperties.BOWL_OF_MILLENIAN_BAMBOO),true, false));\r\n\r\n        LEISAMBOO_TEA_CAKE = registerWithTab(\"leisamboo_tea_cake\",()->\r\n                new Item(new Item.Properties()));\r\n        /*\r\n        姬海棠系列物品\r\n         */\r\n\r\n        MASHED_POTATOES = foodItem(\"mashed_potatoes\",ImmortalersDelightFoodProperties.MASHED_POTATOES);\r\n\r\n        MASHED_POISONOUS_POTATO = registerWithTab(\"mashed_poisonous_potato\",()->\r\n                new ConsumableItem(new Item.Properties().food(ImmortalersDelightFoodProperties.MASHED_POISONOUS_POTATO)));\r\n\r\n        MASHED_POTATO_WITH_JAM = registerWithTab(\"mashed_potato_with_jam\",()->\r\n                new ConsumableItem(new Item.Properties().food(ImmortalersDelightFoodProperties.MASHED_POTATO_WITH_JAM).craftRemainder(Items.BOWL),true));\r\n\r\n        MASHED_POISONOUS_POTATO_WITH_JAM = registerWithTab(\"mashed_poisonous_potato_with_jam\",()->\r\n                new ConsumableItem(new Item.Properties().food(ImmortalersDelightFoodProperties.MASHED_POISONOUS_POTATO_WITH_JAM).craftRemainder(Items.BOWL),true));\r\n\r\n        HIMEKAIDO_YOGURT_PIE = block(ImmortalersDelightBlocks.HIMEKAIDO_YOGURT_PIE);\r\n\r\n        HIMEKAIDO_YOGURT_PIE_SLICE = foodItem(\"himekaido_yogurt_pie_slice\",ImmortalersDelightFoodProperties.HIMEKAIDO_YOGURT_PIE_SLICE);\r\n\r\n        HIMEKAIDO = registerWithTab(\"himekaido\", () ->\r\n                new ConsumableItem(fantasticFoodItem(ImmortalersDelightFoodProperties.HIMEKAIDO, Rarity.COMMON, false), true));\r\n\r\n        GOLDEN_HIMEKAIDO = registerWithTab(\"golden_himekaido\", () ->\r\n                new GoldenHimkaidoFoodItem(fantasticFoodItem(ImmortalersDelightFoodProperties.GOLDEN_HIMEKAIDO, Rarity.RARE, false),true, true,false));\r\n\r\n        ENCHANTED_GOLDEN_HIMEKAIDO = registerWithTab(\"enchanted_golden_himekaido\", () ->\r\n                new EnchantedGoldenHimekaidoFoodItem((new Item.Properties()).rarity(Rarity.EPIC).food(ImmortalersDelightFoodProperties.ENCHANTED_GOLDEN_HIMEKAIDO),true,true,true,3,1.0));\r\n\r\n        HIMEKAIDO_JELLY = registerWithTab(\"himekaido_jelly\", () ->\r\n                new DrinkableItem(new Item.Properties().craftRemainder(Items.GLASS_BOTTLE).stacksTo(16).food(ImmortalersDelightFoodProperties.HIMEKAIDO_JELLY), true, false));\r\n\r\n        YOGURT = registerWithTab(\"yogurt\", () ->\r\n                new DrinkableItem(new Item.Properties().craftRemainder(Items.GLASS_BOTTLE).stacksTo(16).food(ImmortalersDelightFoodProperties.YOGURT), true, false));\r\n\r\n        STUFFED_POISONOUS_POTATO = registerWithTab(\"stuffed_poisonous_potato\", () ->\r\n                new ConsumableItem(fantasticFoodItem(ImmortalersDelightFoodProperties.STUFFED_POISONOUS_POTATO, Rarity.COMMON, false), true));\r\n\r\n        BAKED_POISONOUS_POTATO = registerWithTab(\"baked_poisonous_potato\", () ->\r\n                new ConsumableItem(fantasticFoodItem(ImmortalersDelightFoodProperties.BAKED_POISONOUS_POTATO, Rarity.COMMON, false), true));\r\n\r\n        BRAISED_SPIDER_EYES_BLOCK = registerWithTab(\"braised_spider_eyes_block\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.BRAISED_SPIDER_EYES_BLOCK.get(), basicItem()));\r\n\r\n        BRAISED_SPIDER_EYES_IN_GRAVY = registerWithTab(\"braised_spider_eyes_in_gravy\", () ->\r\n                new ConsumableItem(bowlFoodItem(ImmortalersDelightFoodProperties.BRAISED_SPIDER_EYES_IN_GRAVY), true));\r\n\r\n\r\n        TARTARE_CHICKEN = registerWithTab(\"tartare_chicken\", () ->\r\n                new ConsumableItem(bowlFoodItem(ImmortalersDelightFoodProperties.TARTARE_CHICKEN), true));\r\n\r\n\r\n        DIPPED_ROTTEN_FLESH = registerWithTab(\"dipped_rotten_flesh\", () ->\r\n                new ConsumableItem(fantasticFoodItem(ImmortalersDelightFoodProperties.DIPPED_ROTTEN_FLESH, Rarity.COMMON, false), true));\r\n\r\n        CRISPY_YOGURT_ROTTEN_FLESH = registerWithTab(\"crispy_yogurt_rotten_flesh\", () ->\r\n                new ConsumableItem(bowlFoodItem(ImmortalersDelightFoodProperties.CRISPY_YOGURT_ROTTEN_FLESH), true));\r\n\r\n        MEATY_ROTTEN_TOMATO_BROTH = registerWithTab(\"meaty_rotten_tomato_broth\", () ->\r\n                new ConsumableItem(bowlFoodItem(ImmortalersDelightFoodProperties.MEATY_ROTTEN_TOMATO_BROTH), true));\r\n\r\n        PUFFERFISH_ROLL = registerWithTab(\"pufferfish_roll\", () ->\r\n                new ConsumableItem(fantasticFoodItem(ImmortalersDelightFoodProperties.PUFFERFISH_ROLL, Rarity.COMMON, false), true));\r\n\r\n        STEWED_ROTTEN_MEAT_POT = registerWithTab(\"stewed_rotten_meat_pot\", () ->\r\n                new BlockItem(ImmortalersDelightBlocks.STEWED_ROTTEN_MEAT_POT.get(), basicItem()));\r\n\r\n        BOWL_OF_STEWED_ROTTEN_MEAT_IN_CLAY_POT = registerWithTab(\"bowl_of_stewed_rotten_meat_in_clay_pot\", () ->\r\n                new ConsumableItem(bowlFoodItem(ImmortalersDelightFoodProperties.BOWL_OF_STEWED_ROTTEN_MEAT_IN_CLAY_POT), true));\r\n        /*\r\n        瓦斯麦相关物品\r\n        */\r\n\r\n        KWAT_WHEAT_DOUGH = registerWithTab(\"kwat_wheat_dough\",()->\r\n                new Item(new Item.Properties()));\r\n\r\n        KWAT_WHEAT_PASTE = registerWithTab(\"kwat_wheat_paste\",()->\r\n                new Item(new Item.Properties().stacksTo(16).craftRemainder(Items.GLASS_BOTTLE)));\r\n\r\n        KWAT_WHEAT_TOAST = foodItem(\"kwat_wheat_toast\",ImmortalersDelightFoodProperties.KWAT_WHEAT_TOAST);\r\n\r\n        KWAT_WHEAT_TOAST_SLICE = foodItem(\"kwat_wheat_toast_slice\",ImmortalersDelightFoodProperties.KWAT_WHEAT_TOAST_SLICE);\r\n\r\n        NETHER_BREAD_CREAM_SOUP = block(ImmortalersDelightBlocks.NETHER_BREAD_CREAM_SOUP);\r\n\r\n        NETHER_CREAM_SOUP = registerWithTab(\"nether_cream_soup\",() ->\r\n                new ConsumableItem(bowlFoodItem(ImmortalersDelightFoodProperties.NETHER_CREAM_SOUP),true,false));\r\n\r\n        NETHER_CREAM_BREAD = registerWithTab(\"nether_cream_bread\",() ->\r\n                new ConsumableItem(bowlFoodItem(ImmortalersDelightFoodProperties.NETHER_CREAM_BREAD),true,false));\r\n\r\n        KWAT_WHEAT_DOUFU = foodItem(\"kwat_wheat_doufu\",ImmortalersDelightFoodProperties.KWAT_WHEAT_DOUFU);\r\n\r\n        FRY_KWAT_WHEAT_DOUFU = registerWithTab(\"fry_kwat_wheat_doufu\",()->\r\n                new ConsumableItem(new Item.Properties().food(ImmortalersDelightFoodProperties.FRY_KWAT_WHEAT_DOUFU),true,false));\r\n\r\n        SUTFFED_KWAT_WHEAT_DOUFU = registerWithTab(\"sutffed_kwat_wheat_doufu\",()->\r\n                new ConsumableItem(new Item.Properties().food(ImmortalersDelightFoodProperties.SUTFFED_DOUFU),true));\r\n\r\n        JADE_AND_RUBY_SOUP = registerWithTab(\"jade_and_ruby_soup\",()->\r\n                new ConsumableItem(bowlFoodItem(ImmortalersDelightFoodProperties.JADE_AND_RUBY_SOUP),true));\r\n\r\n        GOLDEN_FABRIC = register(\"golden_fabric\", () ->\r\n                new ConsumableItem(fantasticItem(Rarity.RARE),false,true));\r\n\r\n        GOLDEN_FABRIC_VEIL = registerWithTab(\"golden_fabric_veil\", () ->\r\n                new GoldenFabricArmor(ImmortalersArmorMaterials.GOLDEN_FABRIC,ArmorItem.Type.HELMET,fantasticItem(Rarity.RARE)));\r\n\r\n        RAW_SNIFFER_SLICE = REGISTER.register(\"raw_sniffer_slice\", () ->\r\n                new ConsumableItem(fantasticFoodItem(ImmortalersDelightFoodProperties.RAW_SNIFFER_SLICE, Rarity.COMMON, false), true));\r\n\r\n        COOKED_SNIFFER_SLICE = REGISTER.register(\"cooked_sniffer_slice\", () ->\r\n                new ConsumableItem(fantasticFoodItem(ImmortalersDelightFoodProperties.COOKED_SNIFFER_SLICE, Rarity.COMMON, false), true));\r\n\r\n        RAW_SNIFFER_STEAK = REGISTER.register(\"raw_sniffer_steak\", () ->\r\n                new ConsumableItem(fantasticFoodItem(ImmortalersDelightFoodProperties.RAW_SNIFFER_STEAK, Rarity.COMMON, false), true));\r\n\r\n        COOKED_SNIFFER_STEAK = REGISTER.register(\"cooked_sniffer_steak\", () ->\r\n                new ConsumableItem(fantasticFoodItem(ImmortalersDelightFoodProperties.COOKED_SNIFFER_STEAK, Rarity.COMMON, false), true));\r\n\r\n        SNIFFER_ROTATING_ROAST_MEAT = REGISTER.register(\"sniffer_rotating_roast_meat\",()->\r\n                new ItemNameBlockItem(ImmortalersDelightBlocks.SNIFFER_ROTATING_ROAST_MEAT.get(), new Item.Properties()));\r\n\r\n        SNIFFER_HIDE = REGISTER.register(\"sniffer_hide\", () ->\r\n                new ConsumableItem(fantasticItem(Rarity.COMMON)));\r\n\r\n        /*\r\n        火把花相关物品\r\n        */\r\n\r\n        TORCHFLOWER_MUSTARD = registerWithTab(\"torchflower_mustard\",()->\r\n                new Item(new Item.Properties()));\r\n\r\n        TORCHFLOWER_COOKIE = foodItem(\"torchflower_cookie\",ImmortalersDelightFoodProperties.TORCHFLOWER_COOKIE,true);\r\n\r\n        TORCHFLOWER_CAKE = foodItem(\"torchflower_cake\",ImmortalersDelightFoodProperties.TORCHFLOWER_CAKE,true);\r\n\r\n        TORCHFLOWER_CURRY_RICE = registerWithTab(\"torchflower_curry_rice\",()->\r\n                new ConsumableItem(bowlFoodItem(ImmortalersDelightFoodProperties.TORCHFLOWER_CURRY_RICE),true));\r\n\r\n        EXTRA_SPICY_PASTA = registerWithTab(\"extra_spicy_pasta\",()->\r\n                new ConsumableItem(bowlFoodItem(ImmortalersDelightFoodProperties.EXTRA_SPICY_PASTA),true));\r\n\r\n        HOT_HI_SOUP = registerWithTab(\"hot_hi_soup\",()->\r\n                new ConsumableItem(bowlFoodItem(ImmortalersDelightFoodProperties.HOT_HI_SOUP),true));\r\n\r\n        INCANDESCENCE_SUSHI = foodItem(\"incandescence_sushi\",ImmortalersDelightFoodProperties.INCANDESCENCE_SUSHI,true);\r\n\r\n        /*火把花相关物品*/\r\n        TORCHFLOWER_MUSTARD = registerWithTab(\"torchflower_mustard\",()->\r\n                new Item(new Item.Properties()));\r\n\r\n        TORCHFLOWER_COOKIE = foodItem(\"torchflower_cookie\",ImmortalersDelightFoodProperties.TORCHFLOWER_COOKIE,true);\r\n\r\n        TORCHFLOWER_CAKE = foodItem(\"torchflower_cake\",ImmortalersDelightFoodProperties.TORCHFLOWER_CAKE,true);\r\n\r\n        TORCHFLOWER_CURRY_RICE = registerWithTab(\"torchflower_curry_rice\",()->\r\n                new ConsumableItem(bowlFoodItem(ImmortalersDelightFoodProperties.TORCHFLOWER_CURRY_RICE),true));\r\n\r\n        EXTRA_SPICY_PASTA = registerWithTab(\"extra_spicy_pasta\",()->\r\n                new ConsumableItem(bowlFoodItem(ImmortalersDelightFoodProperties.EXTRA_SPICY_PASTA),true));\r\n\r\n        HOT_HI_SOUP = registerWithTab(\"hot_hi_soup\",()->\r\n                new ConsumableItem(bowlFoodItem(ImmortalersDelightFoodProperties.HOT_HI_SOUP),true));\r\n\r\n        INCANDESCENCE_SUSHI = foodItem(\"incandescence_sushi\",ImmortalersDelightFoodProperties.INCANDESCENCE_SUSHI,true);\r\n\r\n        PITCHER_PLANT_BARBECUE = registerWithTab(\"pitcher_plant_barbecue\",()->\r\n                new ConsumableItem(new Item.Properties().food(ImmortalersDelightFoodProperties.PITCHER_PLANT_BARBECUE),true));\r\n\r\n        POD_SHELL_BURGER_MEAT = block(ImmortalersDelightBlocks.POD_SHELL_BURGER_MEAT);\r\n        POD_SHELL_BURGER_MEAT_CUBE = registerWithTab(\"pod_shell_burger_meat_cube\",()->\r\n                new ConsumableItem(new Item.Properties().food(ImmortalersDelightFoodProperties.POD_SHELL_BURGER_MEAT_CUBE),true));\r\n\r\n\r\n        //酒品\r\n        DREUMK_WINE = registerWithTab(\"dreumk_wine\",()->\r\n                new InebriatedToxicFoodItem(drinkItem(ImmortalersDelightFoodProperties.DREUMK_WINE),true,false));\r\n\r\n        EVOLUTCORN_BEER = registerWithTab(\"evolutcorn_beer\",()->\r\n                new InebriatedToxicFoodItem(drinkItem(ImmortalersDelightFoodProperties.EVOLUTCORN_BEER), true, false));\r\n\r\n        VULCAN_COKTAIL = registerWithTab(\"vulcan_coktail\",()->\r\n                new InebriatedToxicFoodItem(drinkItem(ImmortalersDelightFoodProperties.VULCAN_COKTAIL),true,false));\r\n\r\n        CLEAR_WATER_VODKA = registerWithTab(\"clear_water_vodka\", () ->\r\n                new InebriatedToxicFoodItem(drinkItem(ImmortalersDelightFoodProperties.CLEAR_WATER_VODKA),true,false,false,true));\r\n\r\n        NETHER_KVASS = registerWithTab(\"nether_kvass\", () ->\r\n                new InebriatedToxicFoodItem(drinkItem(ImmortalersDelightFoodProperties.NETHER_KVASS),true,false,false,true));\r\n\r\n        PURGATORY_ALE = registerWithTab(\"purgatory_ale\",()->\r\n                new InebriatedToxicFoodItem(drinkItem(ImmortalersDelightFoodProperties.PURGATORY_ALE),true,false,false,true));\r\n\r\n    }\r\n\r\n    public static RegistryObject<Item> registerWithTab(String name, Supplier<Item> supplier) {\r\n        RegistryObject<Item> item = REGISTER.register(name, supplier);\r\n        CREATIVE_TAB_ITEMS.add(item);\r\n        return item;\r\n    }\r\n\r\n    public static RegistryObject<Item> register(String name, Supplier<Item> supplier) {\r\n        return REGISTER.register(name, supplier);\r\n    }\r\n\r\n    public static Item.Properties basicItem() {\r\n        return new Item.Properties();\r\n    }\r\n\r\n    public static Item.Properties foodItem(FoodProperties food) {\r\n        return (new Item.Properties()).food(food);\r\n    }\r\n\r\n    public static RegistryObject<Item> foodItem(String name,FoodProperties food) {\r\n        return registerWithTab(name,()->new Item(new Item.Properties().food(food)));\r\n    }\r\n\r\n    public static RegistryObject<Item> foodItem(String name,FoodProperties food,boolean hasFoodEffectTooltip) {\r\n        return registerWithTab(name,()->new ConsumableItem(new Item.Properties().food(food),hasFoodEffectTooltip));\r\n    }\r\n\r\n    public static Item.Properties bowlFoodItem(FoodProperties food) {\r\n        return (new Item.Properties()).food(food).craftRemainder(Items.BOWL).stacksTo(16);\r\n    }\r\n\r\n    public static Item.Properties drinkItem() {\r\n        return (new Item.Properties()).craftRemainder(Items.GLASS_BOTTLE).stacksTo(16);\r\n    }\r\n\r\n    public static Item.Properties drinkItem(FoodProperties foodProperties) {\r\n        return (new Item.Properties()).craftRemainder(Items.GLASS_BOTTLE).stacksTo(16).food(foodProperties);\r\n    }\r\n\r\n    public static Item.Properties leisambooDrinksItem() {\r\n        return (new Item.Properties()).craftRemainder(EMPTY_BAMBOO_CUP.get()).stacksTo(16);\r\n    }\r\n\r\n    public static Item.Properties leisambooDrinksItem(FoodProperties foodProperties) {\r\n        return (new Item.Properties()).craftRemainder(EMPTY_BAMBOO_CUP.get()).stacksTo(16).food(foodProperties);\r\n    }\r\n    private static Item.Properties fantasticItem(Rarity soCool) {\r\n        return (new Item.Properties()).rarity(soCool);\r\n    }\r\n\r\n\r\n    private static Item.Properties fantasticFoodItem(FoodProperties foodProperties, Rarity soCool, boolean isBowl) {\r\n        if (isBowl) {\r\n            return new Item.Properties().rarity(soCool).food(foodProperties).craftRemainder(Items.BOWL).stacksTo(16);\r\n        }\r\n        return (new Item.Properties().rarity(soCool).food(foodProperties));\r\n    }\r\n\r\n    private static RegistryObject<Item> block(RegistryObject<Block> block) {\r\n        return registerWithTab(block.getId().getPath(), () -> new BlockItem(block.get(), new Item.Properties()));\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightItems.java b/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightItems.java
--- a/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightItems.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightItems.java	
@@ -1,11 +1,11 @@
 package com.renyigesai.immortalers_delight.init;
 
 import com.google.common.collect.Sets;
+import com.renyigesai.immortalers_delight.Test;
 import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.entities.ImmortalersBoat;
 import com.renyigesai.immortalers_delight.entities.ImmortalersChestBoat;
 import com.renyigesai.immortalers_delight.item.*;
-import com.renyigesai.immortalers_delight.util.datautil.worlddata.BaseImmortalWorldData;
 import net.minecraft.world.food.FoodProperties;
 import net.minecraft.world.item.*;
 import net.minecraft.world.level.block.Block;
@@ -22,7 +22,7 @@
 public class ImmortalersDelightItems {
 
 
-    public static final DeferredRegister<Item> REGISTER = DeferredRegister.create(ForgeRegistries.ITEMS, ImmortalersDelightMod.MODID);
+    public static final DeferredRegister<Item> REGISTER = DeferredRegister.create(ForgeRegistries.ITEMS, Test.TEST_TEST);
     public static LinkedHashSet<RegistryObject<Item>> CREATIVE_TAB_ITEMS = Sets.newLinkedHashSet();
     public static final RegistryObject<Item> HIMEKAIDO_LOG;
     public static final RegistryObject<Item> HIMEKAIDO_WOOD;
@@ -200,7 +200,14 @@
     public static final RegistryObject<Item> VULCAN_COKTAIL;
     public static final RegistryObject<Item> NETHER_KVASS;
     public static final RegistryObject<Item> PURGATORY_ALE;
+    //public static final RegistryObject<Item> ELIXIR_OF_IMMORTALITY;
+    public static final RegistryObject<Item> PALE_DEW_WINE;
     //public static final RegistryObject<Item> TEST_DAMAGE_ITEM;
+    public static final RegistryObject<Item> SCARLET_DEVILS_CAKE;
+    public static final RegistryObject<Item> SCARLET_DEVILS_CAKE_SLICE;
+    public static final RegistryObject<Item> RED_STUFFED_BUN;
+    //public static final RegistryObject<Item> SPICY_PUDDING;
+
 
 
     static {
@@ -572,6 +579,18 @@
         JADE_AND_RUBY_SOUP = registerWithTab("jade_and_ruby_soup",()->
                 new ConsumableItem(bowlFoodItem(ImmortalersDelightFoodProperties.JADE_AND_RUBY_SOUP),true));
 
+        SCARLET_DEVILS_CAKE = registerWithTab("scarlet_devils_cake", () ->
+                new BlockItem(ImmortalersDelightBlocks.SCARLET_DEVILS_CAKE.get(), basicItem()));
+
+        SCARLET_DEVILS_CAKE_SLICE = registerWithTab("scarlet_devils_cake_slice",()->
+                new ConsumableItem(new Item.Properties().food(ImmortalersDelightFoodProperties.SCARLET_DEVILS_CAKE_SLICE),true,false));
+
+        RED_STUFFED_BUN = registerWithTab("red_stuffed_bun",()->
+                new ConsumableItem(new Item.Properties().food(ImmortalersDelightFoodProperties.RED_STUFFED_BUN),true,false));
+
+//        SPICY_PUDDING = registerWithTab("spicy_pudding",()->
+//                new ConsumableItem(new Item.Properties().food(ImmortalersDelightFoodProperties.SPICY_PUDDING),true,false));
+
         GOLDEN_FABRIC = register("golden_fabric", () ->
                 new ConsumableItem(fantasticItem(Rarity.RARE),false,true));
 
@@ -618,25 +637,6 @@
 
         INCANDESCENCE_SUSHI = foodItem("incandescence_sushi",ImmortalersDelightFoodProperties.INCANDESCENCE_SUSHI,true);
 
-        /*火把花相关物品*/
-        TORCHFLOWER_MUSTARD = registerWithTab("torchflower_mustard",()->
-                new Item(new Item.Properties()));
-
-        TORCHFLOWER_COOKIE = foodItem("torchflower_cookie",ImmortalersDelightFoodProperties.TORCHFLOWER_COOKIE,true);
-
-        TORCHFLOWER_CAKE = foodItem("torchflower_cake",ImmortalersDelightFoodProperties.TORCHFLOWER_CAKE,true);
-
-        TORCHFLOWER_CURRY_RICE = registerWithTab("torchflower_curry_rice",()->
-                new ConsumableItem(bowlFoodItem(ImmortalersDelightFoodProperties.TORCHFLOWER_CURRY_RICE),true));
-
-        EXTRA_SPICY_PASTA = registerWithTab("extra_spicy_pasta",()->
-                new ConsumableItem(bowlFoodItem(ImmortalersDelightFoodProperties.EXTRA_SPICY_PASTA),true));
-
-        HOT_HI_SOUP = registerWithTab("hot_hi_soup",()->
-                new ConsumableItem(bowlFoodItem(ImmortalersDelightFoodProperties.HOT_HI_SOUP),true));
-
-        INCANDESCENCE_SUSHI = foodItem("incandescence_sushi",ImmortalersDelightFoodProperties.INCANDESCENCE_SUSHI,true);
-
         PITCHER_PLANT_BARBECUE = registerWithTab("pitcher_plant_barbecue",()->
                 new ConsumableItem(new Item.Properties().food(ImmortalersDelightFoodProperties.PITCHER_PLANT_BARBECUE),true));
 
@@ -664,6 +664,9 @@
         PURGATORY_ALE = registerWithTab("purgatory_ale",()->
                 new InebriatedToxicFoodItem(drinkItem(ImmortalersDelightFoodProperties.PURGATORY_ALE),true,false,false,true));
 
+        PALE_DEW_WINE = registerWithTab("pale_dew_wine",()->
+                new InebriatedToxicFoodItem(drinkItem(ImmortalersDelightFoodProperties.PALE_DEW_WINE),true,false));
+
     }
 
     public static RegistryObject<Item> registerWithTab(String name, Supplier<Item> supplier) {
Index: src/main/java/com/renyigesai/immortalers_delight/potion/DamageResistPotionEffect.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.potion;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport net.minecraft.tags.DamageTypeTags;\r\nimport net.minecraft.world.effect.MobEffectInstance;\r\nimport net.minecraft.world.effect.MobEffects;\r\nimport net.minecraft.world.entity.LivingEntity;\r\nimport net.minecraft.world.entity.MobType;\r\nimport net.minecraftforge.event.entity.living.LivingHurtEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;\r\n\r\n@Mod.EventBusSubscriber\r\npublic class DamageResistPotionEffect {\r\n    @SubscribeEvent\r\n    public static void onCreatureHurt(LivingHurtEvent evt) {\r\n        LivingEntity hurtOne = evt.getEntity();\r\n        LivingEntity attacker = null;\r\n        if (evt.getSource().getEntity() instanceof LivingEntity livingEntity){\r\n            attacker = livingEntity;\r\n        }\r\n        if (evt.isCanceled() || evt.getSource().is(DamageTypeTags.BYPASSES_RESISTANCE)) {\r\n            return;\r\n        }\r\n\r\n        if (!hurtOne.level().isClientSide) {\r\n            if (attacker != null){\r\n                float damage = evt.getAmount();\r\n                if (attacker.getMobType() == MobType.UNDEAD && hurtOne.hasEffect(ImmortalersDelightMobEffect.RESISTANCE_TO_UNDEAD.get())){\r\n                    int lv = hurtOne.hasEffect(ImmortalersDelightMobEffect.RESISTANCE_TO_UNDEAD.get())?hurtOne.getEffect(ImmortalersDelightMobEffect.RESISTANCE_TO_UNDEAD.get()).getAmplifier():0;\r\n                    damage /= lv == 0 ? 0.75F : 2*lv;\r\n                }\r\n                else if (attacker.getMobType() == MobType.ARTHROPOD && hurtOne.hasEffect(ImmortalersDelightMobEffect.RESISTANCE_TO_ARTHROPOD.get())){\r\n                    int lv = hurtOne.hasEffect(ImmortalersDelightMobEffect.RESISTANCE_TO_ARTHROPOD.get())?hurtOne.getEffect(ImmortalersDelightMobEffect.RESISTANCE_TO_ARTHROPOD.get()).getAmplifier():0;\r\n                    damage /= lv == 0 ? 0.75F : 2*lv;\r\n                    MobEffectInstance speed = new MobEffectInstance(MobEffects.MOVEMENT_SPEED,(lv + 2)*10,3);\r\n                    hurtOne.addEffect(speed);\r\n                }\r\n                else if (attacker.getMobType() == MobType.WATER && hurtOne.hasEffect(ImmortalersDelightMobEffect.RESISTANCE_TO_ABYSSAL.get())){\r\n                    int lv = hurtOne.hasEffect(ImmortalersDelightMobEffect.RESISTANCE_TO_ABYSSAL.get())?hurtOne.getEffect(ImmortalersDelightMobEffect.RESISTANCE_TO_ABYSSAL.get()).getAmplifier():0;\r\n                    damage /= lv == 0 ? 0.75F : 2*lv;\r\n                    MobEffectInstance conduitPower = new MobEffectInstance(lv > 1 ? MobEffects.CONDUIT_POWER : MobEffects.WATER_BREATHING,(lv + 2)*40,0);\r\n                    hurtOne.addEffect(conduitPower);\r\n                    MobEffectInstance swingSpeed =lv > 1 ? new MobEffectInstance(MobEffects.HEAL,1, 0) : new MobEffectInstance(MobEffects.DOLPHINS_GRACE,(lv + 2)*40,lv);\r\n                    hurtOne.addEffect(swingSpeed);\r\n                }\r\n                else if (attacker.getMobType() == MobType.ILLAGER && hurtOne.hasEffect(ImmortalersDelightMobEffect.RESISTANCE_TO_ILLAGER.get())){\r\n                    int lv = hurtOne.hasEffect(ImmortalersDelightMobEffect.RESISTANCE_TO_ILLAGER.get())?hurtOne.getEffect(ImmortalersDelightMobEffect.RESISTANCE_TO_ILLAGER.get()).getAmplifier():0;\r\n                    damage /= lv == 0 ? 0.75F : 2*lv;\r\n                }\r\n                evt.setAmount(Math.max(damage, 0f));\r\n            } else if (hurtOne.hasEffect(ImmortalersDelightMobEffect.RESISTANCE_TO_SURROUNDINGS.get())) {\r\n                int lv = hurtOne.hasEffect(ImmortalersDelightMobEffect.RESISTANCE_TO_SURROUNDINGS.get())?hurtOne.getEffect(ImmortalersDelightMobEffect.RESISTANCE_TO_SURROUNDINGS.get()).getAmplifier():0;\r\n                int buffer = 2 << lv;\r\n                evt.setAmount(Math.max(evt.getAmount() - 0.2F - 0.05F * buffer, 0f));\r\n            }\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/potion/DamageResistPotionEffect.java b/src/main/java/com/renyigesai/immortalers_delight/potion/DamageResistPotionEffect.java
--- a/src/main/java/com/renyigesai/immortalers_delight/potion/DamageResistPotionEffect.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/potion/DamageResistPotionEffect.java	
@@ -1,6 +1,5 @@
 package com.renyigesai.immortalers_delight.potion;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
 import net.minecraft.tags.DamageTypeTags;
 import net.minecraft.world.effect.MobEffectInstance;
 import net.minecraft.world.effect.MobEffects;
Index: src/main/java/com/renyigesai/immortalers_delight/potion/BurnTheBoatsPotionEffect.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.potion;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;\r\nimport net.minecraft.tags.DamageTypeTags;\r\nimport net.minecraft.world.effect.MobEffectInstance;\r\nimport net.minecraft.world.effect.MobEffects;\r\nimport net.minecraft.world.entity.Entity;\r\nimport net.minecraft.world.entity.LivingEntity;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraftforge.event.entity.living.LivingEntityUseItemEvent;\r\nimport net.minecraftforge.event.entity.living.LivingHurtEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\nimport java.util.Objects;\r\n\r\n@Mod.EventBusSubscriber\r\npublic class BurnTheBoatsPotionEffect {\r\n    @SubscribeEvent\r\n    public static void onCreatureHurt(LivingHurtEvent evt) {\r\n        if (evt.isCanceled() ) {\r\n            return;\r\n        }\r\n        LivingEntity hurtOne = evt.getEntity();\r\n        if (hurtOne.hasEffect(ImmortalersDelightMobEffect.BURN_THE_BOATS.get())) {\r\n            int lv = hurtOne.hasEffect(ImmortalersDelightMobEffect.BURN_THE_BOATS.get())? Objects.requireNonNull(hurtOne.getEffect(ImmortalersDelightMobEffect.BURN_THE_BOATS.get())).getAmplifier() :0;\r\n            lv++;\r\n            float workHealth = (hurtOne.getMaxHealth() * lv) / (2 * (lv + 1)) > 3 * (lv + 1) ? 3 * (lv + 1) : (hurtOne.getMaxHealth() * lv / (2 * (lv + 1)));\r\n            if (hurtOne.getHealth() < workHealth) {\r\n                int lvStrong = hurtOne.hasEffect(MobEffects.DAMAGE_BOOST)? Objects.requireNonNull(hurtOne.getEffect(MobEffects.DAMAGE_BOOST)).getAmplifier()+1 :0;\r\n                int lvSpeed = hurtOne.hasEffect(MobEffects.MOVEMENT_SPEED)? Objects.requireNonNull(hurtOne.getEffect(MobEffects.MOVEMENT_SPEED)).getAmplifier()+1 :0;\r\n                int lvDigSpeed = hurtOne.hasEffect(MobEffects.DIG_SPEED)? Objects.requireNonNull(hurtOne.getEffect(MobEffects.DIG_SPEED)).getAmplifier()+1 :0;\r\n                int lvJump = hurtOne.hasEffect(MobEffects.JUMP)? Objects.requireNonNull(hurtOne.getEffect(MobEffects.JUMP)).getAmplifier()+1 :0;\r\n                int timeResist = hurtOne.hasEffect(MobEffects.DAMAGE_RESISTANCE)? Objects.requireNonNull(hurtOne.getEffect(MobEffects.DAMAGE_RESISTANCE)).getDuration()+1 :0;\r\n                MobEffectInstance strong = new MobEffectInstance(MobEffects.DAMAGE_BOOST,300,(lvStrong > lv ? lv : lvStrong) + 2 );\r\n                MobEffectInstance speed = new MobEffectInstance(MobEffects.MOVEMENT_SPEED,300,(lvSpeed > lv ? lv : lvSpeed) + 2 );\r\n                MobEffectInstance dig = new MobEffectInstance(MobEffects.DIG_SPEED,300,(lvDigSpeed > lv ? lv : lvDigSpeed) + 2 );\r\n                MobEffectInstance jump = new MobEffectInstance(MobEffects.JUMP,300,(lvJump > lv ? lv : lvJump) + 2 );\r\n                MobEffectInstance resist = new MobEffectInstance(MobEffects.DAMAGE_RESISTANCE,(timeResist + 300 > lv++ * 300 ? lv++ * 300 : timeResist + 300) ,2);\r\n                hurtOne.addEffect(strong);\r\n                hurtOne.addEffect(speed);\r\n                hurtOne.addEffect(dig);\r\n                hurtOne.addEffect(jump);\r\n                hurtOne.addEffect(resist);\r\n                //ImmortalersDelightMod.LOGGER.info(\"伤害来源是：\" + Objects.requireNonNull(evt.getSource().getEntity()).getName().toString());\r\n                if (evt.getSource().getEntity()==null || !(evt.getSource().getEntity() instanceof LivingEntity) || evt.getSource().is(DamageTypeTags.BYPASSES_RESISTANCE)){\r\n                    int lvRegen = hurtOne.hasEffect(MobEffects.REGENERATION)? Objects.requireNonNull(hurtOne.getEffect(MobEffects.REGENERATION)).getAmplifier()+1 :0;\r\n                    MobEffectInstance regen = new MobEffectInstance(MobEffects.REGENERATION,100,(lvRegen > lv ? lv : lvRegen) + 1 );\r\n                    hurtOne.addEffect(regen);\r\n                }\r\n                hurtOne.removeEffect(ImmortalersDelightMobEffect.BURN_THE_BOATS.get());\r\n            }\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/potion/BurnTheBoatsPotionEffect.java b/src/main/java/com/renyigesai/immortalers_delight/potion/BurnTheBoatsPotionEffect.java
--- a/src/main/java/com/renyigesai/immortalers_delight/potion/BurnTheBoatsPotionEffect.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/potion/BurnTheBoatsPotionEffect.java	
@@ -1,14 +1,10 @@
 package com.renyigesai.immortalers_delight.potion;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;
 import net.minecraft.tags.DamageTypeTags;
 import net.minecraft.world.effect.MobEffectInstance;
 import net.minecraft.world.effect.MobEffects;
-import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.item.ItemStack;
-import net.minecraftforge.event.entity.living.LivingEntityUseItemEvent;
 import net.minecraftforge.event.entity.living.LivingHurtEvent;
 import net.minecraftforge.eventbus.api.SubscribeEvent;
 import net.minecraftforge.fml.common.Mod;
Index: src/main/java/com/renyigesai/immortalers_delight/screen/overlay/AftertasteHungerOverlay.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.screen.overlay;\r\n\r\nimport com.mojang.blaze3d.systems.RenderSystem;\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.gui.GuiGraphics;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.entity.LivingEntity;\r\nimport net.minecraft.world.entity.player.Player;\r\nimport net.minecraft.world.food.FoodData;\r\nimport net.minecraft.world.level.GameRules;\r\nimport net.minecraftforge.client.event.RenderGuiOverlayEvent;\r\nimport net.minecraftforge.client.gui.overlay.ForgeGui;\r\nimport net.minecraftforge.client.gui.overlay.GuiOverlayManager;\r\nimport net.minecraftforge.common.MinecraftForge;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\n\r\nimport java.util.Random;\r\n\r\n/**\r\n * Credits to squeek502 (AppleSkin) for the implementation reference!\r\n * https://www.curseforge.com/minecraft/mc-mods/appleskin\r\n */\r\npublic class AftertasteHungerOverlay {\r\n\t// 食物图标偏移量，用于调整食物图标的位置\r\n\tpublic static int foodIconsOffset;\r\n\t// 余味图标的纹理资源位置\r\n\tprivate static final ResourceLocation AFTERTASTE_ICONS_TEXTURE = new ResourceLocation(ImmortalersDelightMod.MODID, \"textures/gui/icons/aftertaste_icons.png\");\r\n\r\n\t/**\r\n\t * 初始化方法，将当前类的实例注册到 Minecraft Forge 的事件总线中\r\n\t */\r\n\tpublic static void init() {\r\n\t\tMinecraftForge.EVENT_BUS.register(new AftertasteHungerOverlay());\r\n\t}\r\n\r\n\t// 食物等级元素的资源位置\r\n\tstatic ResourceLocation FOOD_LEVEL_ELEMENT = new ResourceLocation(\"minecraft\", \"food_level\");\r\n\r\n\t/**\r\n\t * 处理渲染 GUI 覆盖层的后置事件\r\n\t * @param event 渲染 GUI 覆盖层的后置事件\r\n\t */\r\n\t@SubscribeEvent\r\n\tpublic void onRenderGuiOverlayPost(RenderGuiOverlayEvent.Post event) {\r\n\t\t// 检查事件的覆盖层是否为食物等级元素的覆盖层\r\n\t\tif (event.getOverlay() == GuiOverlayManager.findOverlay(FOOD_LEVEL_ELEMENT)) {\r\n\t\t\tMinecraft mc = Minecraft.getInstance();\r\n\t\t\tForgeGui gui = (ForgeGui) mc.gui;\r\n\t\t\t// 检查玩家是否乘坐了其他生物\r\n\t\t\tboolean isMounted = mc.player != null && mc.player.getVehicle() instanceof LivingEntity;\r\n\t\t\t// 如果玩家没有乘坐其他生物，GUI 没有隐藏，并且应该绘制生存元素，则渲染余味覆盖层\r\n\t\t\tif (!isMounted && !mc.options.hideGui && gui.shouldDrawSurvivalElements()) {\r\n\t\t\t\trenderAftertasteOverlay(gui, event.getGuiGraphics());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 渲染余味覆盖层的方法\r\n\t * @param gui ForgeGui 实例，用于获取 GUI 相关信息\r\n\t * @param graphics GuiGraphics 实例，用于进行图形绘制\r\n\t */\r\n\tpublic static void renderAftertasteOverlay(ForgeGui gui, GuiGraphics graphics) {\r\n//\t\tif (!Configuration.NOURISHED_HUNGER_OVERLAY.get()) {\r\n//\t\t\treturn;\r\n//\t\t}\r\n\r\n\t\t// 设置食物图标偏移量为 GUI 的右侧高度\r\n\t\tfoodIconsOffset = gui.rightHeight;\r\n\t\tMinecraft minecraft = Minecraft.getInstance();\r\n\t\tPlayer player = minecraft.player;\r\n\r\n\t\t// 如果玩家为空，则不进行后续操作\r\n\t\tif (player == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// 获取玩家的食物数据\r\n\t\tFoodData stats = player.getFoodData();\r\n\t\t// 计算顶部位置，这是图标将屏幕上的位置而非在icon贴图的位置\r\n\t\tint top = minecraft.getWindow().getGuiScaledHeight() - foodIconsOffset + 10;\r\n\t\t// 计算左侧位置，同上\r\n\t\tint left = minecraft.getWindow().getGuiScaledWidth() / 2 + 91;\r\n\r\n\t\t// 检查玩家是否正在通过饱和度进行自然恢复\r\n\t\tboolean isPlayerHealingWithSaturation =\r\n\t\t\t\tplayer.level().getGameRules().getBoolean(GameRules.RULE_NATURAL_REGENERATION)\r\n\t\t\t\t\t\t&& player.isHurt()\r\n\t\t\t\t\t\t&& stats.getFoodLevel() >= 18;\r\n\r\n\t\t// 如果玩家有 LINGERING_FLAVOR 效果，则绘制余味覆盖层\r\n\t\tif (player.getEffect(ImmortalersDelightMobEffect.LINGERING_FLAVOR.get()) != null) {\r\n\t\t\tdrawAftertasteOverlay(stats, minecraft, graphics, left, top, isPlayerHealingWithSaturation);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 绘制余味覆盖层的具体方法\r\n\t * @param stats 玩家的食物数据\r\n\t * @param mc Minecraft 实例\r\n\t * @param graphics GuiGraphics 实例，用于进行图形绘制\r\n\t * @param left 左侧位置\r\n\t * @param top 顶部位置\r\n\t * @param naturalHealing 玩家是否正在通过饱和度进行自然恢复\r\n\t */\r\n\tpublic static void drawAftertasteOverlay(FoodData stats, Minecraft mc, GuiGraphics graphics, int left, int top, boolean naturalHealing) {\r\n\t\t// 获取玩家的饱和度\r\n\t\tfloat saturation = stats.getSaturationLevel();\r\n\t\t// 获取玩家的食物等级\r\n\t\tint foodLevel = stats.getFoodLevel();\r\n\t\t// 获取 GUI 的 tick 数\r\n\t\tint ticks = mc.gui.getGuiTicks();\r\n\t\t// 创建一个随机数生成器\r\n\t\tRandom rand = new Random();\r\n\t\t// 设置随机数生成器的种子\r\n\t\trand.setSeed(ticks * 312871);\r\n\r\n//\t\tRenderSystem.setShaderTexture(0, AFTERTASTE_ICONS_TEXTURE);\r\n\t\t// 启用混合模式，用于处理透明纹理的绘制\r\n\t\tRenderSystem.enableBlend();\r\n\r\n\t\t// 循环绘制 10 个图标\r\n\t\tfor (int j = 0; j < 10; ++j) {\r\n\t\t\t// 计算图标在 x 轴上的位置\r\n\t\t\tint x = left - j * 8 - 9;\r\n\t\t\t// 初始化图标在 y 轴上的位置\r\n\t\t\tint y = top;\r\n\r\n\t\t\t// 如果饱和度小于等于 0 且 tick 数满足特定条件，则在 y 轴上进行随机偏移\r\n\t\t\tif (saturation <= 0.0F && ticks % (foodLevel * 3 + 1) == 0) {\r\n\t\t\t\ty = top + (rand.nextInt(3) - 1);\r\n\t\t\t}\r\n\r\n\t\t\t// 绘制背景纹理，后边4个数是图标在icon贴图上的位置\r\n\t\t\tgraphics.blit(AFTERTASTE_ICONS_TEXTURE, x, y, 0, 0, 9, 9);\r\n\r\n\t\t\t// 计算当前栏的有效饥饿值\r\n\t\t\tfloat effectiveHungerOfBar = (stats.getFoodLevel()) / 2.0F - j;\r\n\t\t\t// 根据玩家是否正在自然恢复来确定纹理偏移量\r\n\t\t\tint naturalHealingOffset = naturalHealing ? 18 : 0;\r\n\r\n\t\t\t// 绘制金色饥饿图标，18,0,9,9意为icons左上角第三个9*9区域\r\n\t\t\tif (effectiveHungerOfBar >= 1) {\r\n\t\t\t\tgraphics.blit(AFTERTASTE_ICONS_TEXTURE, x, y, 18 + naturalHealingOffset, 0, 9, 9);\r\n\t\t\t} else if (effectiveHungerOfBar >= .5) {\r\n\t\t\t\tgraphics.blit(AFTERTASTE_ICONS_TEXTURE, x, y, 9 + naturalHealingOffset, 0, 9, 9);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// 禁用混合模式\r\n\t\tRenderSystem.disableBlend();\r\n//\t\tRenderSystem.setShaderTexture(0, Gui.GUI_ICONS_LOCATION);\r\n\t}\r\n}\r\n//\r\n//import com.mojang.blaze3d.systems.RenderSystem;\r\n//import com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\n//import com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;\r\n//import net.minecraft.client.Minecraft;\r\n//import net.minecraft.client.gui.GuiGraphics;\r\n//import net.minecraft.resources.ResourceLocation;\r\n//import net.minecraft.world.entity.LivingEntity;\r\n//import net.minecraft.world.entity.player.Player;\r\n//import net.minecraft.world.food.FoodData;\r\n//import net.minecraft.world.level.GameRules;\r\n//import net.minecraftforge.client.event.RenderGuiOverlayEvent;\r\n//import net.minecraftforge.client.gui.overlay.ForgeGui;\r\n//import net.minecraftforge.client.gui.overlay.GuiOverlayManager;\r\n//import net.minecraftforge.common.MinecraftForge;\r\n//import net.minecraftforge.eventbus.api.SubscribeEvent;\r\n//\r\n//import java.util.Random;\r\n//\r\n///**\r\n// * Credits to squeek502 (AppleSkin) for the implementation reference!\r\n// * https://www.curseforge.com/minecraft/mc-mods/appleskin\r\n// */\r\n//\r\n//public class AftertasteHungerOverlay\r\n//{\r\n//\tpublic static int foodIconsOffset;\r\n//\tprivate static final ResourceLocation AFTERTASTE_ICONS_TEXTURE = new ResourceLocation(ImmortalersDelightMod.MODID, \"textures/gui/icons/aftertaste_icons.png\");\r\n//\r\n//\tpublic static void init() {\r\n//\t\tMinecraftForge.EVENT_BUS.register(new AftertasteHungerOverlay());\r\n//\t}\r\n//\r\n//\tstatic ResourceLocation FOOD_LEVEL_ELEMENT = new ResourceLocation(\"minecraft\", \"food_level\");\r\n//\r\n//\t@SubscribeEvent\r\n//\tpublic void onRenderGuiOverlayPost(RenderGuiOverlayEvent.Post event) {\r\n//\t\tif (event.getOverlay() == GuiOverlayManager.findOverlay(FOOD_LEVEL_ELEMENT)) {\r\n//\t\t\tMinecraft mc = Minecraft.getInstance();\r\n//\t\t\tForgeGui gui = (ForgeGui) mc.gui;\r\n//\t\t\tboolean isMounted = mc.player != null && mc.player.getVehicle() instanceof LivingEntity;\r\n//\t\t\tif (!isMounted && !mc.options.hideGui && gui.shouldDrawSurvivalElements()) {\r\n//\t\t\t\trenderAftertasteOverlay(gui, event.getGuiGraphics());\r\n//\t\t\t}\r\n//\t\t}\r\n//\t}\r\n//\r\n//\tpublic static void renderAftertasteOverlay(ForgeGui gui, GuiGraphics graphics) {\r\n////\t\tif (!Configuration.NOURISHED_HUNGER_OVERLAY.get()) {\r\n////\t\t\treturn;\r\n////\t\t}\r\n//\r\n//\t\tfoodIconsOffset = gui.rightHeight;\r\n//\t\tMinecraft minecraft = Minecraft.getInstance();\r\n//\t\tPlayer player = minecraft.player;\r\n//\r\n//\t\tif (player == null) {\r\n//\t\t\treturn;\r\n//\t\t}\r\n//\r\n//\t\tFoodData stats = player.getFoodData();\r\n//\t\tint top = minecraft.getWindow().getGuiScaledHeight() - foodIconsOffset + 10;\r\n//\t\tint left = minecraft.getWindow().getGuiScaledWidth() / 2 + 91;\r\n//\r\n//\t\tboolean isPlayerHealingWithSaturation =\r\n//\t\t\t\tplayer.level().getGameRules().getBoolean(GameRules.RULE_NATURAL_REGENERATION)\r\n//\t\t\t\t\t\t&& player.isHurt()\r\n//\t\t\t\t\t\t&& stats.getFoodLevel() >= 18;\r\n//\r\n//\t\tif (player.getEffect(ImmortalersDelightMobEffect.LINGERING_FLAVOR.get()) != null) {\r\n//\t\t\tdrawAftertasteOverlay(stats, minecraft, graphics, left, top, isPlayerHealingWithSaturation);\r\n//\t\t}\r\n//\t}\r\n//\r\n//\tpublic static void drawAftertasteOverlay(FoodData stats, Minecraft mc, GuiGraphics graphics, int left, int top, boolean naturalHealing) {\r\n//\t\tfloat saturation = stats.getSaturationLevel();\r\n//\t\tint foodLevel = stats.getFoodLevel();\r\n//\t\tint ticks = mc.gui.getGuiTicks();\r\n//\t\tRandom rand = new Random();\r\n//\t\trand.setSeed(ticks * 312871);\r\n//\r\n////\t\tRenderSystem.setShaderTexture(0, AFTERTASTE_ICONS_TEXTURE);\r\n//\t\tRenderSystem.enableBlend();\r\n//\r\n//\t\tfor (int j = 0; j < 10; ++j) {\r\n//\t\t\tint x = left - j * 8 - 9;\r\n//\t\t\tint y = top;\r\n//\r\n//\t\t\tif (saturation <= 0.0F && ticks % (foodLevel * 3 + 1) == 0) {\r\n//\t\t\t\ty = top + (rand.nextInt(3) - 1);\r\n//\t\t\t}\r\n//\r\n//\t\t\t// Background texture\r\n//\t\t\tgraphics.blit(AFTERTASTE_ICONS_TEXTURE, x, y, 0, 0, 9, 9);\r\n//\r\n//\t\t\tfloat effectiveHungerOfBar = (stats.getFoodLevel()) / 2.0F - j;\r\n//\t\t\tint naturalHealingOffset = naturalHealing ? 18 : 0;\r\n//\r\n//\t\t\t// Gilded hunger icons\r\n//\t\t\tif (effectiveHungerOfBar >= 1)\r\n//\t\t\t\tgraphics.blit(AFTERTASTE_ICONS_TEXTURE, x, y, 18 + naturalHealingOffset, 0, 9, 9);\r\n//\t\t\telse if (effectiveHungerOfBar >= .5)\r\n//\t\t\t\tgraphics.blit(AFTERTASTE_ICONS_TEXTURE, x, y, 9 + naturalHealingOffset, 0, 9, 9);\r\n//\t\t}\r\n//\r\n//\t\tRenderSystem.disableBlend();\r\n////\t\tRenderSystem.setShaderTexture(0, Gui.GUI_ICONS_LOCATION);\r\n//\t}\r\n//}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/AftertasteHungerOverlay.java b/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/AftertasteHungerOverlay.java
--- a/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/AftertasteHungerOverlay.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/AftertasteHungerOverlay.java	
@@ -1,7 +1,7 @@
 package com.renyigesai.immortalers_delight.screen.overlay;
 
 import com.mojang.blaze3d.systems.RenderSystem;
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.GuiGraphics;
Index: src/main/java/com/renyigesai/immortalers_delight/screen/overlay/BurnTheBoatsHealthOverlay.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.screen.overlay;\r\n\r\nimport com.mojang.blaze3d.systems.RenderSystem;\r\nimport com.renyigesai.immortalers_delight.Config;\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.gui.GuiGraphics;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.util.Mth;\r\nimport net.minecraft.world.effect.MobEffects;\r\nimport net.minecraft.world.entity.ai.attributes.AttributeInstance;\r\nimport net.minecraft.world.entity.ai.attributes.Attributes;\r\nimport net.minecraft.world.entity.player.Player;\r\nimport net.minecraft.world.food.FoodData;\r\nimport net.minecraftforge.client.event.RenderGuiOverlayEvent;\r\nimport net.minecraftforge.client.gui.overlay.ForgeGui;\r\nimport net.minecraftforge.client.gui.overlay.GuiOverlayManager;\r\nimport net.minecraftforge.common.MinecraftForge;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\n\r\nimport java.util.Objects;\r\nimport java.util.Random;\r\n\r\n/**\r\n * BurnTheBoatsHealthOverlay类用于在Minecraft游戏中处理背水一战效果的生命值覆盖层渲染。\r\n * 当玩家满足特定条件时，会在玩家的生命值显示上叠加背水一战效果的图标。\r\n */\r\npublic class BurnTheBoatsHealthOverlay {\r\n\t// 生命值图标偏移量，用于确定图标在屏幕上的位置\r\n\tprotected static int healthIconsOffset;\r\n\t// 背水一战效果的图标纹理资源位置\r\n\tprivate static final ResourceLocation HEALTH_ICONS_TEXTURE = new ResourceLocation(ImmortalersDelightMod.MODID, \"textures/gui/icons/burn_the_boats_icons.png\");\r\n\r\n\t/**\r\n\t * 初始化方法，将BurnTheBoatsHealthOverlay类的实例注册到Minecraft Forge的事件总线中，\r\n\t * 以便监听相关事件。\r\n\t */\r\n\tpublic static void init() {\r\n\t\tMinecraftForge.EVENT_BUS.register(new BurnTheBoatsHealthOverlay());\r\n\t}\r\n\r\n\t// 玩家生命值覆盖层的资源位置，用于识别玩家生命值显示的覆盖层\r\n\tstatic ResourceLocation PLAYER_HEALTH_ELEMENT = new ResourceLocation(\"minecraft\", \"player_health\");\r\n\r\n\t/**\r\n\t * 监听RenderGuiOverlayEvent.Post事件，当渲染玩家生命值覆盖层时，\r\n\t * 检查条件并调用renderBurnTheBoatsOverlay方法进行背水一战效果的渲染。\r\n\t *\r\n\t * @param event 渲染GUI覆盖层后的事件\r\n\t */\r\n\t@SubscribeEvent\r\n\tpublic void onRenderGuiOverlayPost(RenderGuiOverlayEvent.Post event) {\r\n\t\t// 检查当前渲染的覆盖层是否为玩家生命值覆盖层\r\n\t\tif (event.getOverlay() == GuiOverlayManager.findOverlay(PLAYER_HEALTH_ELEMENT)) {\r\n\t\t\t// 获取Minecraft实例\r\n\t\t\tMinecraft mc = Minecraft.getInstance();\r\n\t\t\t// 获取ForgeGui实例\r\n\t\t\tForgeGui gui = (ForgeGui) mc.gui;\r\n\t\t\t// 检查玩家是否隐藏了GUI，并且是否应该绘制生存元素\r\n\t\t\tif (!mc.options.hideGui && gui.shouldDrawSurvivalElements()) {\r\n\t\t\t\t// 调用渲染背水一战覆盖层的方法\r\n\t\t\t\trenderBurnTheBoatsOverlay(gui, event.getGuiGraphics());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 渲染背水一战效果的覆盖层，根据配置和玩家状态决定是否进行渲染。\r\n\t *\r\n\t * @param gui 游戏的ForgeGui实例\r\n\t * @param graphics 用于绘制的GuiGraphics实例\r\n\t */\r\n\tpublic static void renderBurnTheBoatsOverlay(ForgeGui gui, GuiGraphics graphics) {\r\n\t\t// 检查配置中是否启用了背水一战生命值覆盖层功能\r\n\t\tif (!Config.weakPoisonHealthOverlay) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// 设置生命值图标偏移量\r\n\t\thealthIconsOffset = gui.leftHeight;\r\n\t\t// 获取Minecraft实例\r\n\t\tMinecraft minecraft = Minecraft.getInstance();\r\n\t\t// 获取当前玩家实例\r\n\t\tPlayer player = minecraft.player;\r\n\r\n\t\t// 如果玩家为空，直接返回\r\n\t\tif (player == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// 获取玩家的食物数据\r\n\t\tFoodData stats = player.getFoodData();\r\n\t\t// 计算覆盖层的顶部位置\r\n\t\tint top = minecraft.getWindow().getGuiScaledHeight() - healthIconsOffset + 10;\r\n\t\t// 计算覆盖层的左侧位置\r\n\t\tint left = minecraft.getWindow().getGuiScaledWidth() / 2 - 91;\r\n\r\n\t\t// 判断玩家是否符合显示背水一战覆盖层的条件：\r\n\t\t// 需要玩家没有凋零效果，凋零效果的黑色显血在设计中包含使判断当前血量变得困难的效果\r\n\t\tboolean isPlayerEligibleForBurnTheBoats = !player.hasEffect(MobEffects.WITHER);\r\n\r\n\t\t// 检查玩家是否有背水一战效果，并且符合显示条件\r\n\t\tif (player.getEffect(ImmortalersDelightMobEffect.BURN_THE_BOATS.get()) != null && isPlayerEligibleForBurnTheBoats) {\r\n\t\t\t// 调用绘制背水一战覆盖层的方法\r\n\t\t\tdrawBurnTheBoatsOverlay(player, minecraft, graphics, left, top);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 绘制背水一战效果的覆盖层，根据玩家的生命值、吸收量等信息确定绘制的位置和样式。\r\n\t *\r\n\t * @param player 当前玩家实例\r\n\t * @param minecraft Minecraft实例\r\n\t * @param graphics 用于绘制的GuiGraphics实例\r\n\t * @param left 覆盖层的左侧位置\r\n\t * @param top 覆盖层的顶部位置\r\n\t */\r\n\tpublic static void drawBurnTheBoatsOverlay(Player player, Minecraft minecraft, GuiGraphics graphics, int left, int top) {\r\n\t\t// 获取游戏的当前帧数\r\n\t\tint ticks = minecraft.gui.getGuiTicks();\r\n\t\t// 创建随机数生成器\r\n\t\tRandom rand = new Random();\r\n\t\t// 设置随机数种子，根据当前帧数生成\r\n\t\trand.setSeed((long) (ticks * 312871));\r\n\r\n\t\t// 获取玩家的当前生命值，向上取整\r\n\t\tint health = Mth.ceil(player.getHealth());\r\n\t\t// 获取玩家的吸收量，向上取整\r\n\t\tfloat absorb = Mth.ceil(player.getAbsorptionAmount());\r\n\t\t// 获取玩家的最大生命值属性实例\r\n\t\tAttributeInstance attrMaxHealth = player.getAttribute(Attributes.MAX_HEALTH);\r\n\t\t// 获取玩家的最大生命值\r\n\t\tfloat healthMax = (float) attrMaxHealth.getValue();\r\n\r\n\t\t// 初始化再生效果的帧数，默认为-1\r\n\t\tint regen = -1;\r\n\t\t// 如果玩家有再生效果，计算再生效果的帧数\r\n\t\tif (player.hasEffect(MobEffects.REGENERATION)) regen = ticks % 25;\r\n\r\n\t\t// 计算生命值显示的行数\r\n\t\tint healthRows = Mth.ceil((healthMax + absorb) / 2.0F / 10.0F);\r\n\t\t// 计算每行的高度，最小为3\r\n\t\tint rowHeight = Math.max(10 - (healthRows - 2), 3);\r\n\r\n\t\t// 计算闪烁效果的帧数\r\n\t\tint comfortSheen = ticks % 50;\r\n\t\t// 计算闪烁的心形图框的索引\r\n\t\tint comfortHeartFrame = comfortSheen % 2;\r\n\t\t// 存储纹理宽度的数组\r\n\t\tint[] textureWidth = {5, 9};\r\n\r\n\t\t// 设置渲染的纹理\r\n\t\tRenderSystem.setShaderTexture(0, HEALTH_ICONS_TEXTURE);\r\n\t\t// 启用混合模式，用于透明渲染\r\n\t\tRenderSystem.enableBlend();\r\n\r\n\t\t// 计算单行最大生命值显示数量\r\n\t\tint healthMaxSingleRow = Mth.ceil(Math.min(healthMax, 20) / 2.0F);\r\n\t\t// 计算左侧高度偏移量，确保覆盖层在最底部的一行心型图标上\r\n\t\tint leftHeightOffset = ((healthRows - 1) * rowHeight);\r\n\r\n\t\t// 遍历单行的每个生命值图标位置\r\n\t\tfor (int i = 0; i < healthMaxSingleRow; ++i) {\r\n\t\t\t// 计算当前图标的列索引\r\n\t\t\tint column = i % 10;\r\n\t\t\t// 计算当前图标的x坐标\r\n\t\t\tint x = left + column * 8;\r\n\t\t\t// 计算当前图标的y坐标\r\n\t\t\tint y = top + leftHeightOffset;\r\n\r\n\t\t\t// 如果玩家生命值小于等于4，随机调整y坐标\r\n\t\t\tif (health <= 4) y += rand.nextInt(2);\r\n\t\t\t// 如果当前图标位置与再生效果帧数相同，调整y坐标\r\n\t\t\tif (i == regen) y -= 2;\r\n\t\t\t//计算触发血线\r\n\t\t\tint lv = player.hasEffect(ImmortalersDelightMobEffect.BURN_THE_BOATS.get())? Objects.requireNonNull(player.getEffect(ImmortalersDelightMobEffect.BURN_THE_BOATS.get())).getAmplifier() :0;\r\n\t\t\tlv++;\r\n\t\t\tfloat workHealth = (healthMax * lv) / (2 * (lv + 1)) > 3 * (lv + 1) ? 3 * (lv + 1) : (healthMax * lv)/ (2 * (lv + 1));\r\n\t\t\t// 计算当前栏的有效生命值\r\n\t\t\tfloat effectiveHealthOfBar = (health / 2.0F - i);\r\n\t\t\tfloat effectiveWorkHealthOfBar = (workHealth / 2.0F - i);\r\n\t\t\t// 绘制Buff血量图标，9,9,9,9意为icons左上角第二行第二个9*9区域\r\n\t\t\tif (effectiveHealthOfBar >= 1 && effectiveWorkHealthOfBar >= 1) {\r\n\t\t\t\tgraphics.blit(HEALTH_ICONS_TEXTURE, x, y, 9, 9, 9, 9);\r\n\t\t\t} else if (effectiveHealthOfBar >= .5 && effectiveWorkHealthOfBar >= .5) {\r\n\t\t\t\tgraphics.blit(HEALTH_ICONS_TEXTURE, x, y, 18, 9, 9, 9);\r\n\t\t\t} else graphics.blit(HEALTH_ICONS_TEXTURE, x, y, 0, 9, 9, 9);\r\n\t\t\t/*\r\n\t\t\t这两个是舒适效果用来弄闪烁动画的，目前为弃用\r\n\t\t\t */\r\n//\t\t\t// 如果当前列索引与闪烁效果的帧数匹配，绘制闪烁的心形图标\r\n//\t\t\tif (column == comfortSheen / 2) {\r\n//\t\t\t\tgraphics.blit(HEALTH_ICONS_TEXTURE, x, y, 0, 9, textureWidth[comfortHeartFrame], 9);\r\n//\t\t\t}\r\n//\t\t\t// 如果当前列索引与闪烁效果的帧数匹配，并且是特定的心形图框，绘制额外的图标\r\n//\t\t\tif (column == (comfortSheen / 2) - 1 && comfortHeartFrame == 0) {\r\n//\t\t\t\tgraphics.blit(HEALTH_ICONS_TEXTURE, x + 5, y, 5, 9, 4, 9);\r\n//\t\t\t}\r\n\t\t}\r\n\r\n\t\t// 禁用混合模式\r\n\t\tRenderSystem.disableBlend();\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/BurnTheBoatsHealthOverlay.java b/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/BurnTheBoatsHealthOverlay.java
--- a/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/BurnTheBoatsHealthOverlay.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/BurnTheBoatsHealthOverlay.java	
@@ -2,7 +2,7 @@
 
 import com.mojang.blaze3d.systems.RenderSystem;
 import com.renyigesai.immortalers_delight.Config;
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.GuiGraphics;
Index: src/main/java/com/renyigesai/immortalers_delight/screen/overlay/WeakWitherHealthOverlay.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.screen.overlay;\r\n\r\nimport com.mojang.blaze3d.systems.RenderSystem;\r\nimport com.renyigesai.immortalers_delight.Config;\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.gui.GuiGraphics;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.util.Mth;\r\nimport net.minecraft.world.effect.MobEffects;\r\nimport net.minecraft.world.entity.ai.attributes.AttributeInstance;\r\nimport net.minecraft.world.entity.ai.attributes.Attributes;\r\nimport net.minecraft.world.entity.player.Player;\r\nimport net.minecraft.world.food.FoodData;\r\nimport net.minecraftforge.client.event.RenderGuiOverlayEvent;\r\nimport net.minecraftforge.client.gui.overlay.ForgeGui;\r\nimport net.minecraftforge.client.gui.overlay.GuiOverlayManager;\r\nimport net.minecraftforge.common.MinecraftForge;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\n\r\nimport java.util.Random;\r\n\r\npublic class WeakWitherHealthOverlay\r\n{\r\n\tprotected static int healthIconsOffset;\r\n\tprivate static final ResourceLocation HEALTH_ICONS_TEXTURE = new ResourceLocation(ImmortalersDelightMod.MODID, \"textures/gui/icons/weak_wither_icons.png\");\r\n\r\n\tpublic static void init() {\r\n\t\tMinecraftForge.EVENT_BUS.register(new WeakWitherHealthOverlay());\r\n\t}\r\n\r\n\r\n\tstatic ResourceLocation PLAYER_HEALTH_ELEMENT = new ResourceLocation(\"minecraft\", \"player_health\");\r\n\r\n\t@SubscribeEvent\r\n\tpublic void onRenderGuiOverlayPost(RenderGuiOverlayEvent.Post event) {\r\n\t\tif (event.getOverlay() == GuiOverlayManager.findOverlay(PLAYER_HEALTH_ELEMENT)) {\r\n\t\t\tMinecraft mc = Minecraft.getInstance();\r\n\t\t\tForgeGui gui = (ForgeGui) mc.gui;\r\n\t\t\tif (!mc.options.hideGui && gui.shouldDrawSurvivalElements()) {\r\n\t\t\t\trenderWeakWitherOverlay(gui, event.getGuiGraphics());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static void renderWeakWitherOverlay(ForgeGui gui, GuiGraphics graphics) {\r\n\t\tif (!Config.weakPoisonHealthOverlay) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\thealthIconsOffset = gui.leftHeight;\r\n\t\tMinecraft minecraft = Minecraft.getInstance();\r\n\t\tPlayer player = minecraft.player;\r\n\r\n\t\tif (player == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tFoodData stats = player.getFoodData();\r\n\t\tint top = minecraft.getWindow().getGuiScaledHeight() - healthIconsOffset + 10;\r\n\t\tint left = minecraft.getWindow().getGuiScaledWidth() / 2 - 91;\r\n\r\n\t\tboolean isPlayerEligibleForWeakWither = !player.hasEffect(MobEffects.REGENERATION);\r\n\r\n\t\tif (player.getEffect(ImmortalersDelightMobEffect.WEAK_WITHER.get()) != null && isPlayerEligibleForWeakWither) {\r\n\t\t\tdrawWeakWitherOverlay(player, minecraft, graphics, left, top);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static void drawWeakWitherOverlay(Player player, Minecraft minecraft, GuiGraphics graphics, int left, int top) {\r\n\t\tint ticks = minecraft.gui.getGuiTicks();\r\n\t\tRandom rand = new Random();\r\n\t\trand.setSeed((long) (ticks * 312871));\r\n\r\n\t\tint health = Mth.ceil(player.getHealth());\r\n\t\tfloat absorb = Mth.ceil(player.getAbsorptionAmount());\r\n\t\tAttributeInstance attrMaxHealth = player.getAttribute(Attributes.MAX_HEALTH);\r\n\t\tfloat healthMax = (float) attrMaxHealth.getValue();\r\n\r\n\t\tint regen = -1;\r\n\t\tif (player.hasEffect(MobEffects.REGENERATION)) regen = ticks % 25;\r\n\r\n\t\tint healthRows = Mth.ceil((healthMax + absorb) / 2.0F / 10.0F);\r\n\t\tint rowHeight = Math.max(10 - (healthRows - 2), 3);\r\n\r\n\t\tint comfortSheen = ticks % 50;\r\n\t\tint comfortHeartFrame = comfortSheen % 2;\r\n\t\tint[] textureWidth = {5, 9};\r\n\r\n\t\tRenderSystem.setShaderTexture(0, HEALTH_ICONS_TEXTURE);\r\n\t\tRenderSystem.enableBlend();\r\n\r\n\t\tint healthMaxSingleRow = Mth.ceil(Math.min(healthMax, 20) / 2.0F);\r\n\t\tint leftHeightOffset = ((healthRows - 1) * rowHeight); // This keeps the overlay on the bottommost row of hearts\r\n\r\n\t\tfor (int i = 0; i < healthMaxSingleRow; ++i) {\r\n\t\t\tint column = i % 10;\r\n\t\t\tint x = left + column * 8;\r\n\t\t\tint y = top + leftHeightOffset;\r\n\r\n\t\t\tif (health <= 4) y += rand.nextInt(2);\r\n\t\t\tif (i == regen) y -= 2;\r\n\t\t\t// 计算当前栏的有效生命值\r\n\t\t\tfloat effectiveHealthOfBar = (health / 2.0F - i);\r\n\t\t\t// 绘制Buff血量图标，9,9,9,9意为icons左上角第二行第二个9*9区域\r\n\t\t\tif (effectiveHealthOfBar >= 1) {\r\n\t\t\t\tgraphics.blit(HEALTH_ICONS_TEXTURE, x, y, 9, 9, 9, 9);\r\n\t\t\t} else if (effectiveHealthOfBar >= .5) {\r\n\t\t\t\tgraphics.blit(HEALTH_ICONS_TEXTURE, x, y, 18, 9, 9, 9);\r\n\t\t\t} else graphics.blit(HEALTH_ICONS_TEXTURE, x, y, 0, 9, 9, 9);\r\n//\r\n//\t\t\tif (column == comfortSheen / 2) {\r\n//\t\t\t\tgraphics.blit(HEALTH_ICONS_TEXTURE, x, y, 0, 9, textureWidth[comfortHeartFrame], 9);\r\n//\t\t\t}\r\n//\t\t\tif (column == (comfortSheen / 2) - 1 && comfortHeartFrame == 0) {\r\n//\t\t\t\tgraphics.blit(HEALTH_ICONS_TEXTURE, x + 5, y, 5, 9, 4, 9);\r\n//\t\t\t}\r\n\t\t}\r\n\r\n\t\tRenderSystem.disableBlend();\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/WeakWitherHealthOverlay.java b/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/WeakWitherHealthOverlay.java
--- a/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/WeakWitherHealthOverlay.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/WeakWitherHealthOverlay.java	
@@ -2,7 +2,7 @@
 
 import com.mojang.blaze3d.systems.RenderSystem;
 import com.renyigesai.immortalers_delight.Config;
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.GuiGraphics;
Index: src/main/java/com/renyigesai/immortalers_delight/screen/overlay/GasPoisonHealthOverlay.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.screen.overlay;\r\n\r\nimport com.mojang.blaze3d.systems.RenderSystem;\r\nimport com.renyigesai.immortalers_delight.Config;\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.gui.GuiGraphics;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.util.Mth;\r\nimport net.minecraft.world.effect.MobEffects;\r\nimport net.minecraft.world.entity.ai.attributes.AttributeInstance;\r\nimport net.minecraft.world.entity.ai.attributes.Attributes;\r\nimport net.minecraft.world.entity.player.Player;\r\nimport net.minecraft.world.food.FoodData;\r\nimport net.minecraftforge.client.event.RenderGuiOverlayEvent;\r\nimport net.minecraftforge.client.gui.overlay.ForgeGui;\r\nimport net.minecraftforge.client.gui.overlay.GuiOverlayManager;\r\nimport net.minecraftforge.common.MinecraftForge;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\n\r\nimport java.util.Random;\r\n\r\npublic class GasPoisonHealthOverlay\r\n{\r\n    protected static int healthIconsOffset;\r\n    private static final ResourceLocation HEALTH_ICONS_TEXTURE = new ResourceLocation(ImmortalersDelightMod.MODID, \"textures/gui/icons/gas_poison_icons.png\");\r\n\r\n    public static void init() {\r\n        MinecraftForge.EVENT_BUS.register(new WeakPoisonHealthOverlay());\r\n    }\r\n\r\n\r\n    static ResourceLocation PLAYER_HEALTH_ELEMENT = new ResourceLocation(\"minecraft\", \"player_health\");\r\n\r\n    @SubscribeEvent\r\n    public void onRenderGuiOverlayPost(RenderGuiOverlayEvent.Post event) {\r\n        if (event.getOverlay() == GuiOverlayManager.findOverlay(PLAYER_HEALTH_ELEMENT)) {\r\n            Minecraft mc = Minecraft.getInstance();\r\n            ForgeGui gui = (ForgeGui) mc.gui;\r\n            if (!mc.options.hideGui && gui.shouldDrawSurvivalElements()) {\r\n                renderWeakPoisonOverlay(gui, event.getGuiGraphics());\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void renderWeakPoisonOverlay(ForgeGui gui, GuiGraphics graphics) {\r\n        if (!Config.weakPoisonHealthOverlay) {\r\n            return;\r\n        }\r\n\r\n        healthIconsOffset = gui.leftHeight;\r\n        Minecraft minecraft = Minecraft.getInstance();\r\n        Player player = minecraft.player;\r\n\r\n        if (player == null) {\r\n            return;\r\n        }\r\n\r\n        FoodData stats = player.getFoodData();\r\n        int top = minecraft.getWindow().getGuiScaledHeight() - healthIconsOffset + 10;\r\n        int left = minecraft.getWindow().getGuiScaledWidth() / 2 - 91;\r\n\r\n        if (player.getEffect(ImmortalersDelightMobEffect.GAS_POISON.get()) != null) {\r\n            drawWeakPoisonOverlay(player, minecraft, graphics, left, top);\r\n        }\r\n    }\r\n\r\n    public static void drawWeakPoisonOverlay(Player player, Minecraft minecraft, GuiGraphics graphics, int left, int top) {\r\n        int ticks = minecraft.gui.getGuiTicks();\r\n        Random rand = new Random();\r\n        rand.setSeed((long) (ticks * 312871));\r\n\r\n        int health = Mth.ceil(player.getHealth());\r\n        float absorb = Mth.ceil(player.getAbsorptionAmount());\r\n        AttributeInstance attrMaxHealth = player.getAttribute(Attributes.MAX_HEALTH);\r\n        float healthMax = (float) attrMaxHealth.getValue();\r\n\r\n        int regen = -1;\r\n        if (player.hasEffect(MobEffects.REGENERATION)) regen = ticks % 25;\r\n\r\n        int healthRows = Mth.ceil((healthMax + absorb) / 2.0F / 10.0F);\r\n        int rowHeight = Math.max(10 - (healthRows - 2), 3);\r\n\r\n        int comfortSheen = ticks % 50;\r\n        int comfortHeartFrame = comfortSheen % 2;\r\n        int[] textureWidth = {5, 9};\r\n\r\n        RenderSystem.setShaderTexture(0, HEALTH_ICONS_TEXTURE);\r\n        RenderSystem.enableBlend();\r\n\r\n        int healthMaxSingleRow = Mth.ceil(Math.min(healthMax, 20) / 2.0F);\r\n        int leftHeightOffset = ((healthRows - 1) * rowHeight); // This keeps the overlay on the bottommost row of hearts\r\n\r\n        for (int i = 0; i < healthMaxSingleRow; ++i) {\r\n            int column = i % 10;\r\n            int x = left + column * 8;\r\n            int y = top + leftHeightOffset;\r\n\r\n            if (health <= 4) y += rand.nextInt(2);\r\n            if (i == regen) y -= 2;\r\n\r\n            if (column == comfortSheen / 2) {\r\n                graphics.blit(HEALTH_ICONS_TEXTURE, x, y, 0, 9, textureWidth[comfortHeartFrame], 9);\r\n            }\r\n            if (column == (comfortSheen / 2) - 1 && comfortHeartFrame == 0) {\r\n                graphics.blit(HEALTH_ICONS_TEXTURE, x + 5, y, 5, 9, 4, 9);\r\n            }\r\n            float effectiveHealthOfBar = (health / 2.0F - i);\r\n            if (effectiveHealthOfBar >= 1) {\r\n                graphics.blit(HEALTH_ICONS_TEXTURE, x, y, 9, 9, 9, 9);\r\n            } else if (effectiveHealthOfBar >= .5) {\r\n                graphics.blit(HEALTH_ICONS_TEXTURE, x, y, 18, 9, 9, 9);\r\n            }\r\n        }\r\n\r\n        RenderSystem.disableBlend();\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/GasPoisonHealthOverlay.java b/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/GasPoisonHealthOverlay.java
--- a/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/GasPoisonHealthOverlay.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/GasPoisonHealthOverlay.java	
@@ -2,7 +2,7 @@
 
 import com.mojang.blaze3d.systems.RenderSystem;
 import com.renyigesai.immortalers_delight.Config;
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.GuiGraphics;
Index: src/main/java/com/renyigesai/immortalers_delight/screen/overlay/WeakPoisonHealthOverlay.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.screen.overlay;\r\n\r\nimport com.mojang.blaze3d.systems.RenderSystem;\r\nimport com.renyigesai.immortalers_delight.Config;\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.gui.GuiGraphics;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.util.Mth;\r\nimport net.minecraft.world.effect.MobEffects;\r\nimport net.minecraft.world.entity.ai.attributes.AttributeInstance;\r\nimport net.minecraft.world.entity.ai.attributes.Attributes;\r\nimport net.minecraft.world.entity.player.Player;\r\nimport net.minecraft.world.food.FoodData;\r\nimport net.minecraftforge.client.event.RenderGuiOverlayEvent;\r\nimport net.minecraftforge.client.gui.overlay.ForgeGui;\r\nimport net.minecraftforge.client.gui.overlay.GuiOverlayManager;\r\nimport net.minecraftforge.common.MinecraftForge;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\n\r\nimport java.util.Random;\r\n\r\n/**\r\n * WeakPoisonHealthOverlay类用于在Minecraft游戏中处理虚弱中毒效果的生命值覆盖层渲染。\r\n * 当玩家满足特定条件时，会在玩家的生命值显示上叠加虚弱中毒效果的图标。\r\n */\r\npublic class WeakPoisonHealthOverlay {\r\n\t// 生命值图标偏移量，用于确定图标在屏幕上的位置\r\n\tprotected static int healthIconsOffset;\r\n\t// 虚弱中毒效果的图标纹理资源位置\r\n\tprivate static final ResourceLocation HEALTH_ICONS_TEXTURE = new ResourceLocation(ImmortalersDelightMod.MODID, \"textures/gui/icons/weak_poison_icons.png\");\r\n\r\n\t/**\r\n\t * 初始化方法，将WeakPoisonHealthOverlay类的实例注册到Minecraft Forge的事件总线中，\r\n\t * 以便监听相关事件。\r\n\t */\r\n\tpublic static void init() {\r\n\t\tMinecraftForge.EVENT_BUS.register(new WeakPoisonHealthOverlay());\r\n\t}\r\n\r\n\t// 玩家生命值覆盖层的资源位置，用于识别玩家生命值显示的覆盖层\r\n\tstatic ResourceLocation PLAYER_HEALTH_ELEMENT = new ResourceLocation(\"minecraft\", \"player_health\");\r\n\r\n\t/**\r\n\t * 监听RenderGuiOverlayEvent.Post事件，当渲染玩家生命值覆盖层时，\r\n\t * 检查条件并调用renderWeakPoisonOverlay方法进行虚弱中毒效果的渲染。\r\n\t *\r\n\t * @param event 渲染GUI覆盖层后的事件\r\n\t */\r\n\t@SubscribeEvent\r\n\tpublic void onRenderGuiOverlayPost(RenderGuiOverlayEvent.Post event) {\r\n\t\t// 检查当前渲染的覆盖层是否为玩家生命值覆盖层\r\n\t\tif (event.getOverlay() == GuiOverlayManager.findOverlay(PLAYER_HEALTH_ELEMENT)) {\r\n\t\t\t// 获取Minecraft实例\r\n\t\t\tMinecraft mc = Minecraft.getInstance();\r\n\t\t\t// 获取ForgeGui实例\r\n\t\t\tForgeGui gui = (ForgeGui) mc.gui;\r\n\t\t\t// 检查玩家是否隐藏了GUI，并且是否应该绘制生存元素\r\n\t\t\tif (!mc.options.hideGui && gui.shouldDrawSurvivalElements()) {\r\n\t\t\t\t// 调用渲染虚弱中毒覆盖层的方法\r\n\t\t\t\trenderWeakPoisonOverlay(gui, event.getGuiGraphics());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 渲染虚弱中毒效果的覆盖层，根据配置和玩家状态决定是否进行渲染。\r\n\t *\r\n\t * @param gui 游戏的ForgeGui实例\r\n\t * @param graphics 用于绘制的GuiGraphics实例\r\n\t */\r\n\tpublic static void renderWeakPoisonOverlay(ForgeGui gui, GuiGraphics graphics) {\r\n\t\t// 检查配置中是否启用了虚弱中毒生命值覆盖层功能\r\n\t\tif (!Config.weakPoisonHealthOverlay) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// 设置生命值图标偏移量\r\n\t\thealthIconsOffset = gui.leftHeight;\r\n\t\t// 获取Minecraft实例\r\n\t\tMinecraft minecraft = Minecraft.getInstance();\r\n\t\t// 获取当前玩家实例\r\n\t\tPlayer player = minecraft.player;\r\n\r\n\t\t// 如果玩家为空，直接返回\r\n\t\tif (player == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// 获取玩家的食物数据\r\n\t\tFoodData stats = player.getFoodData();\r\n\t\t// 计算覆盖层的顶部位置\r\n\t\tint top = minecraft.getWindow().getGuiScaledHeight() - healthIconsOffset + 10;\r\n\t\t// 计算覆盖层的左侧位置\r\n\t\tint left = minecraft.getWindow().getGuiScaledWidth() / 2 - 91;\r\n\r\n\t\t// 判断玩家是否符合显示虚弱中毒覆盖层的条件：\r\n\t\t// 需要玩家没有再生效果\r\n\t\tboolean isPlayerEligibleForWeakPoison = !player.hasEffect(MobEffects.REGENERATION);\r\n\r\n\t\t// 检查玩家是否有虚弱中毒效果，并且符合显示条件\r\n\t\tif (player.getEffect(ImmortalersDelightMobEffect.WEAK_POISON.get()) != null && isPlayerEligibleForWeakPoison) {\r\n\t\t\t// 调用绘制虚弱中毒覆盖层的方法\r\n\t\t\tdrawWeakPoisonOverlay(player, minecraft, graphics, left, top);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 绘制虚弱中毒效果的覆盖层，根据玩家的生命值、吸收量等信息确定绘制的位置和样式。\r\n\t *\r\n\t * @param player 当前玩家实例\r\n\t * @param minecraft Minecraft实例\r\n\t * @param graphics 用于绘制的GuiGraphics实例\r\n\t * @param left 覆盖层的左侧位置\r\n\t * @param top 覆盖层的顶部位置\r\n\t */\r\n\tpublic static void drawWeakPoisonOverlay(Player player, Minecraft minecraft, GuiGraphics graphics, int left, int top) {\r\n\t\t// 获取游戏的当前帧数\r\n\t\tint ticks = minecraft.gui.getGuiTicks();\r\n\t\t// 创建随机数生成器\r\n\t\tRandom rand = new Random();\r\n\t\t// 设置随机数种子，根据当前帧数生成\r\n\t\trand.setSeed((long) (ticks * 312871));\r\n\r\n\t\t// 获取玩家的当前生命值，向上取整\r\n\t\tint health = Mth.ceil(player.getHealth());\r\n\t\t// 获取玩家的吸收量，向上取整\r\n\t\tfloat absorb = Mth.ceil(player.getAbsorptionAmount());\r\n\t\t// 获取玩家的最大生命值属性实例\r\n\t\tAttributeInstance attrMaxHealth = player.getAttribute(Attributes.MAX_HEALTH);\r\n\t\t// 获取玩家的最大生命值\r\n\t\tfloat healthMax = (float) attrMaxHealth.getValue();\r\n\r\n\t\t// 初始化再生效果的帧数，默认为-1\r\n\t\tint regen = -1;\r\n\t\t// 如果玩家有再生效果，计算再生效果的帧数\r\n\t\tif (player.hasEffect(MobEffects.REGENERATION)) regen = ticks % 25;\r\n\r\n\t\t// 计算生命值显示的行数\r\n\t\tint healthRows = Mth.ceil((healthMax + absorb) / 2.0F / 10.0F);\r\n\t\t// 计算每行的高度，最小为3\r\n\t\tint rowHeight = Math.max(10 - (healthRows - 2), 3);\r\n\r\n\t\t// 计算闪烁效果的帧数\r\n\t\tint comfortSheen = ticks % 50;\r\n\t\t// 计算闪烁的心形图框的索引\r\n\t\tint comfortHeartFrame = comfortSheen % 2;\r\n\t\t// 存储纹理宽度的数组\r\n\t\tint[] textureWidth = {5, 9};\r\n\r\n\t\t// 设置渲染的纹理\r\n\t\tRenderSystem.setShaderTexture(0, HEALTH_ICONS_TEXTURE);\r\n\t\t// 启用混合模式，用于透明渲染\r\n\t\tRenderSystem.enableBlend();\r\n\r\n\t\t// 计算单行最大生命值显示数量\r\n\t\tint healthMaxSingleRow = Mth.ceil(Math.min(healthMax, 20) / 2.0F);\r\n\t\t// 计算左侧高度偏移量，确保覆盖层在最底部的一行心型图标上\r\n\t\tint leftHeightOffset = ((healthRows - 1) * rowHeight);\r\n\r\n\t\t// 遍历单行的每个生命值图标位置\r\n\t\tfor (int i = 0; i < healthMaxSingleRow; ++i) {\r\n\t\t\t// 计算当前图标的列索引\r\n\t\t\tint column = i % 10;\r\n\t\t\t// 计算当前图标的x坐标\r\n\t\t\tint x = left + column * 8;\r\n\t\t\t// 计算当前图标的y坐标\r\n\t\t\tint y = top + leftHeightOffset;\r\n\r\n\t\t\t// 如果玩家生命值小于等于4，随机调整y坐标\r\n\t\t\tif (health <= 4) y += rand.nextInt(2);\r\n\t\t\t// 如果当前图标位置与再生效果帧数相同，调整y坐标\r\n\t\t\tif (i == regen) y -= 2;\r\n\t\t\t// 计算当前栏的有效生命值\r\n\t\t\tfloat effectiveHealthOfBar = (health / 2.0F - i);\r\n\t\t\t// 绘制Buff血量图标，9,9,9,9意为icons左上角第二行第二个9*9区域\r\n\t\t\tif (effectiveHealthOfBar >= 1) {\r\n\t\t\t\tgraphics.blit(HEALTH_ICONS_TEXTURE, x, y, 9, 9, 9, 9);\r\n\t\t\t} else if (effectiveHealthOfBar >= .5) {\r\n\t\t\t\tgraphics.blit(HEALTH_ICONS_TEXTURE, x, y, 18, 9, 9, 9);\r\n\t\t\t} else graphics.blit(HEALTH_ICONS_TEXTURE, x, y, 0, 9, 9, 9);\r\n\t\t\t/*\r\n\t\t\t这两个是舒适效果用来弄闪烁动画的，目前为弃用\r\n\t\t\t */\r\n//\t\t\t// 如果当前列索引与闪烁效果的帧数匹配，绘制闪烁的心形图标\r\n//\t\t\tif (column == comfortSheen / 2) {\r\n//\t\t\t\tgraphics.blit(HEALTH_ICONS_TEXTURE, x, y, 0, 9, textureWidth[comfortHeartFrame], 9);\r\n//\t\t\t}\r\n//\t\t\t// 如果当前列索引与闪烁效果的帧数匹配，并且是特定的心形图框，绘制额外的图标\r\n//\t\t\tif (column == (comfortSheen / 2) - 1 && comfortHeartFrame == 0) {\r\n//\t\t\t\tgraphics.blit(HEALTH_ICONS_TEXTURE, x + 5, y, 5, 9, 4, 9);\r\n//\t\t\t}\r\n\t\t}\r\n\r\n\t\t// 禁用混合模式\r\n\t\tRenderSystem.disableBlend();\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/WeakPoisonHealthOverlay.java b/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/WeakPoisonHealthOverlay.java
--- a/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/WeakPoisonHealthOverlay.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/WeakPoisonHealthOverlay.java	
@@ -2,7 +2,7 @@
 
 import com.mojang.blaze3d.systems.RenderSystem;
 import com.renyigesai.immortalers_delight.Config;
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.GuiGraphics;
Index: src/main/java/com/renyigesai/immortalers_delight/screen/overlay/KeepFastHungerOverlay.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.screen.overlay;\r\n\r\nimport com.mojang.blaze3d.systems.RenderSystem;\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.gui.GuiGraphics;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.entity.LivingEntity;\r\nimport net.minecraft.world.entity.player.Player;\r\nimport net.minecraft.world.food.FoodData;\r\nimport net.minecraft.world.level.GameRules;\r\nimport net.minecraftforge.client.event.RenderGuiOverlayEvent;\r\nimport net.minecraftforge.client.gui.overlay.ForgeGui;\r\nimport net.minecraftforge.client.gui.overlay.GuiOverlayManager;\r\nimport net.minecraftforge.common.MinecraftForge;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\n\r\nimport java.util.Random;\r\n\r\n/**\r\n * Credits to squeek502 (AppleSkin) for the implementation reference!\r\n * https://www.curseforge.com/minecraft/mc-mods/appleskin\r\n */\r\npublic class KeepFastHungerOverlay {\r\n\t// 食物图标偏移量，用于调整食物图标的位置\r\n\tpublic static int foodIconsOffset;\r\n\t// 节食图标的纹理资源位置\r\n\tprivate static final ResourceLocation KEEP_FAST_ICONS_TEXTURE = new ResourceLocation(ImmortalersDelightMod.MODID, \"textures/gui/icons/keep_fast_icons.png\");\r\n\r\n\t/**\r\n\t * 初始化方法，将当前类的实例注册到 Minecraft Forge 的事件总线中\r\n\t */\r\n\tpublic static void init() {\r\n\t\tMinecraftForge.EVENT_BUS.register(new KeepFastHungerOverlay());\r\n\t}\r\n\r\n\t// 食物等级元素的资源位置\r\n\tstatic ResourceLocation FOOD_LEVEL_ELEMENT = new ResourceLocation(\"minecraft\", \"food_level\");\r\n\r\n\t/**\r\n\t * 处理渲染 GUI 覆盖层的后置事件\r\n\t * @param event 渲染 GUI 覆盖层的后置事件\r\n\t */\r\n\t@SubscribeEvent\r\n\tpublic void onRenderGuiOverlayPost(RenderGuiOverlayEvent.Post event) {\r\n\t\t// 检查事件的覆盖层是否为食物等级元素的覆盖层\r\n\t\tif (event.getOverlay() == GuiOverlayManager.findOverlay(FOOD_LEVEL_ELEMENT)) {\r\n\t\t\tMinecraft mc = Minecraft.getInstance();\r\n\t\t\tForgeGui gui = (ForgeGui) mc.gui;\r\n\t\t\t// 检查玩家是否乘坐了其他生物\r\n\t\t\tboolean isMounted = mc.player != null && mc.player.getVehicle() instanceof LivingEntity;\r\n\t\t\t// 如果玩家没有乘坐其他生物，GUI 没有隐藏，并且应该绘制生存元素，则渲染节食覆盖层\r\n\t\t\tif (!isMounted && !mc.options.hideGui && gui.shouldDrawSurvivalElements()) {\r\n\t\t\t\trenderKeepFastOverlay(gui, event.getGuiGraphics());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 渲染节食覆盖层的方法\r\n\t * @param gui ForgeGui 实例，用于获取 GUI 相关信息\r\n\t * @param graphics GuiGraphics 实例，用于进行图形绘制\r\n\t */\r\n\tpublic static void renderKeepFastOverlay(ForgeGui gui, GuiGraphics graphics) {\r\n//\t\tif (!Configuration.NOURISHED_HUNGER_OVERLAY.get()) {\r\n//\t\t\treturn;\r\n//\t\t}\r\n\r\n\t\t// 设置食物图标偏移量为 GUI 的右侧高度\r\n\t\tfoodIconsOffset = gui.rightHeight;\r\n\t\tMinecraft minecraft = Minecraft.getInstance();\r\n\t\tPlayer player = minecraft.player;\r\n\r\n\t\t// 如果玩家为空，则不进行后续操作\r\n\t\tif (player == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// 获取玩家的食物数据\r\n\t\tFoodData stats = player.getFoodData();\r\n\t\t// 计算顶部位置，这是图标将屏幕上的位置而非在icon贴图的位置\r\n\t\tint top = minecraft.getWindow().getGuiScaledHeight() - foodIconsOffset + 10;\r\n\t\t// 计算左侧位置，同上\r\n\t\tint left = minecraft.getWindow().getGuiScaledWidth() / 2 + 91;\r\n\r\n\t\t// 如果玩家有 KEEP_FAST 效果，则绘制节食覆盖层\r\n\t\tif (player.getEffect(ImmortalersDelightMobEffect.KEEP_A_FAST.get()) != null) {\r\n\t\t\tdrawKeepFastOverlay(stats, minecraft, graphics, left, top);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 绘制覆盖层的具体方法\r\n\t * @param stats 玩家的食物数据\r\n\t * @param mc Minecraft 实例\r\n\t * @param graphics GuiGraphics 实例，用于进行图形绘制\r\n\t * @param left 左侧位置\r\n\t * @param top 顶部位置\r\n\t */\r\n\tpublic static void drawKeepFastOverlay(FoodData stats, Minecraft mc, GuiGraphics graphics, int left, int top) {\r\n\t\t// 获取玩家的饱和度\r\n\t\tfloat saturation = stats.getSaturationLevel();\r\n\t\t// 获取玩家的食物等级\r\n\t\tint foodLevel = stats.getFoodLevel();\r\n\t\t// 获取 GUI 的 tick 数\r\n\t\tint ticks = mc.gui.getGuiTicks();\r\n\t\t// 创建一个随机数生成器\r\n\t\tRandom rand = new Random();\r\n\t\t// 设置随机数生成器的种子\r\n\t\trand.setSeed(ticks * 312871);\r\n\r\n//\t\tRenderSystem.setShaderTexture(0, KEEP_FAST_ICONS_TEXTURE);\r\n\t\t// 启用混合模式，用于处理透明纹理的绘制\r\n\t\tRenderSystem.enableBlend();\r\n\r\n\t\t// 循环绘制 10 个图标\r\n\t\tfor (int j = 0; j < 10; ++j) {\r\n\t\t\t// 计算图标在 x 轴上的位置\r\n\t\t\tint x = left - j * 8 - 9;\r\n\t\t\t// 初始化图标在 y 轴上的位置\r\n\t\t\tint y = top;\r\n\r\n\t\t\t// 如果饱和度小于等于 0 且 tick 数满足特定条件，则在 y 轴上进行随机偏移\r\n\t\t\tif (saturation <= 0.0F && ticks % (foodLevel * 3 + 1) == 0) {\r\n\t\t\t\ty = top + (rand.nextInt(3) - 1);\r\n\t\t\t}\r\n\r\n\t\t\t// 绘制背景纹理，后边4个数是图标在icon贴图上的位置\r\n\t\t\tgraphics.blit(KEEP_FAST_ICONS_TEXTURE, x, y - 4, 0, 18, 10, 14);\r\n\r\n\t\t\t// 计算当前栏的有效饥饿值\r\n\t\t\tfloat effectiveHungerOfBar = (stats.getFoodLevel()) / 2.0F - j;\r\n\t\t\tfloat effectiveSaturationOfBar = saturation/ 2.0F - j;\r\n\t\t\t// 根据玩家是否正在自然恢复来确定纹理偏移量\r\n\t\t\tint fullSaturationOffset = effectiveSaturationOfBar >= .5 ? 20 : 0;\r\n//\t\t\tif (ticks % 20 == 0) {\r\n//\t\t\t\tImmortalersDelightMod.LOGGER.info(\"这是第\" + j+ \"个图标，当前的饱食度水平是\" + saturation + \"是否需要偏移纹理？\" + effectiveSaturationOfBar);\r\n//\t\t\t}\r\n\r\n\t\t\t// 绘制金色饥饿图标，18,0,9,9意为icons左上角第三个9*9区域\r\n\t\t\tif (effectiveHungerOfBar >= 1) {\r\n\t\t\t\tgraphics.blit(KEEP_FAST_ICONS_TEXTURE, x, y - 4, 20 + fullSaturationOffset, 18, 10, 14);\r\n\t\t\t} else if (effectiveHungerOfBar >= .5) {\r\n\t\t\t\tgraphics.blit(KEEP_FAST_ICONS_TEXTURE, x, y - 4, 10 + fullSaturationOffset, 18, 10, 14);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// 禁用混合模式\r\n\t\tRenderSystem.disableBlend();\r\n//\t\tRenderSystem.setShaderTexture(0, Gui.GUI_ICONS_LOCATION);\r\n\t}\r\n}\r\n//\r\n//import com.mojang.blaze3d.systems.RenderSystem;\r\n//import com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\n//import com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;\r\n//import net.minecraft.client.Minecraft;\r\n//import net.minecraft.client.gui.GuiGraphics;\r\n//import net.minecraft.resources.ResourceLocation;\r\n//import net.minecraft.world.entity.LivingEntity;\r\n//import net.minecraft.world.entity.player.Player;\r\n//import net.minecraft.world.food.FoodData;\r\n//import net.minecraft.world.level.GameRules;\r\n//import net.minecraftforge.client.event.RenderGuiOverlayEvent;\r\n//import net.minecraftforge.client.gui.overlay.ForgeGui;\r\n//import net.minecraftforge.client.gui.overlay.GuiOverlayManager;\r\n//import net.minecraftforge.common.MinecraftForge;\r\n//import net.minecraftforge.eventbus.api.SubscribeEvent;\r\n//\r\n//import java.util.Random;\r\n//\r\n///**\r\n// * Credits to squeek502 (AppleSkin) for the implementation reference!\r\n// * https://www.curseforge.com/minecraft/mc-mods/appleskin\r\n// */\r\n//\r\n//public class KeepFastHungerOverlay\r\n//{\r\n//\tpublic static int foodIconsOffset;\r\n//\tprivate static final ResourceLocation KEEP_FAST_ICONS_TEXTURE = new ResourceLocation(ImmortalersDelightMod.MODID, \"textures/gui/icons/keep_fast_icons.png\");\r\n//\r\n//\tpublic static void init() {\r\n//\t\tMinecraftForge.EVENT_BUS.register(new KeepFastHungerOverlay());\r\n//\t}\r\n//\r\n//\tstatic ResourceLocation FOOD_LEVEL_ELEMENT = new ResourceLocation(\"minecraft\", \"food_level\");\r\n//\r\n//\t@SubscribeEvent\r\n//\tpublic void onRenderGuiOverlayPost(RenderGuiOverlayEvent.Post event) {\r\n//\t\tif (event.getOverlay() == GuiOverlayManager.findOverlay(FOOD_LEVEL_ELEMENT)) {\r\n//\t\t\tMinecraft mc = Minecraft.getInstance();\r\n//\t\t\tForgeGui gui = (ForgeGui) mc.gui;\r\n//\t\t\tboolean isMounted = mc.player != null && mc.player.getVehicle() instanceof LivingEntity;\r\n//\t\t\tif (!isMounted && !mc.options.hideGui && gui.shouldDrawSurvivalElements()) {\r\n//\t\t\t\trenderKeepFastOverlay(gui, event.getGuiGraphics());\r\n//\t\t\t}\r\n//\t\t}\r\n//\t}\r\n//\r\n//\tpublic static void renderKeepFastOverlay(ForgeGui gui, GuiGraphics graphics) {\r\n////\t\tif (!Configuration.NOURISHED_HUNGER_OVERLAY.get()) {\r\n////\t\t\treturn;\r\n////\t\t}\r\n//\r\n//\t\tfoodIconsOffset = gui.rightHeight;\r\n//\t\tMinecraft minecraft = Minecraft.getInstance();\r\n//\t\tPlayer player = minecraft.player;\r\n//\r\n//\t\tif (player == null) {\r\n//\t\t\treturn;\r\n//\t\t}\r\n//\r\n//\t\tFoodData stats = player.getFoodData();\r\n//\t\tint top = minecraft.getWindow().getGuiScaledHeight() - foodIconsOffset + 10;\r\n//\t\tint left = minecraft.getWindow().getGuiScaledWidth() / 2 + 91;\r\n//\r\n//\t\tboolean isPlayerHealingWithSaturation =\r\n//\t\t\t\tplayer.level().getGameRules().getBoolean(GameRules.RULE_NATURAL_REGENERATION)\r\n//\t\t\t\t\t\t&& player.isHurt()\r\n//\t\t\t\t\t\t&& stats.getFoodLevel() >= 18;\r\n//\r\n//\t\tif (player.getEffect(ImmortalersDelightMobEffect.KEEP_FAST.get()) != null) {\r\n//\t\t\tdrawKeepFastOverlay(stats, minecraft, graphics, left, top, isPlayerHealingWithSaturation);\r\n//\t\t}\r\n//\t}\r\n//\r\n//\tpublic static void drawKeepFastOverlay(FoodData stats, Minecraft mc, GuiGraphics graphics, int left, int top, boolean naturalHealing) {\r\n//\t\tfloat saturation = stats.getSaturationLevel();\r\n//\t\tint foodLevel = stats.getFoodLevel();\r\n//\t\tint ticks = mc.gui.getGuiTicks();\r\n//\t\tRandom rand = new Random();\r\n//\t\trand.setSeed(ticks * 312871);\r\n//\r\n////\t\tRenderSystem.setShaderTexture(0, KEEP_FAST_ICONS_TEXTURE);\r\n//\t\tRenderSystem.enableBlend();\r\n//\r\n//\t\tfor (int j = 0; j < 10; ++j) {\r\n//\t\t\tint x = left - j * 8 - 9;\r\n//\t\t\tint y = top;\r\n//\r\n//\t\t\tif (saturation <= 0.0F && ticks % (foodLevel * 3 + 1) == 0) {\r\n//\t\t\t\ty = top + (rand.nextInt(3) - 1);\r\n//\t\t\t}\r\n//\r\n//\t\t\t// Background texture\r\n//\t\t\tgraphics.blit(KEEP_FAST_ICONS_TEXTURE, x, y, 0, 0, 9, 9);\r\n//\r\n//\t\t\tfloat effectiveHungerOfBar = (stats.getFoodLevel()) / 2.0F - j;\r\n//\t\t\tint naturalHealingOffset = naturalHealing ? 18 : 0;\r\n//\r\n//\t\t\t// Gilded hunger icons\r\n//\t\t\tif (effectiveHungerOfBar >= 1)\r\n//\t\t\t\tgraphics.blit(KEEP_FAST_ICONS_TEXTURE, x, y, 18 + naturalHealingOffset, 0, 9, 9);\r\n//\t\t\telse if (effectiveHungerOfBar >= .5)\r\n//\t\t\t\tgraphics.blit(KEEP_FAST_ICONS_TEXTURE, x, y, 9 + naturalHealingOffset, 0, 9, 9);\r\n//\t\t}\r\n//\r\n//\t\tRenderSystem.disableBlend();\r\n////\t\tRenderSystem.setShaderTexture(0, Gui.GUI_ICONS_LOCATION);\r\n//\t}\r\n//}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/KeepFastHungerOverlay.java b/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/KeepFastHungerOverlay.java
--- a/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/KeepFastHungerOverlay.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/screen/overlay/KeepFastHungerOverlay.java	
@@ -1,7 +1,7 @@
 package com.renyigesai.immortalers_delight.screen.overlay;
 
 import com.mojang.blaze3d.systems.RenderSystem;
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.GuiGraphics;
@@ -9,7 +9,6 @@
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.food.FoodData;
-import net.minecraft.world.level.GameRules;
 import net.minecraftforge.client.event.RenderGuiOverlayEvent;
 import net.minecraftforge.client.gui.overlay.ForgeGui;
 import net.minecraftforge.client.gui.overlay.GuiOverlayManager;
Index: src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightBlocks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.init;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.block.*;\r\nimport com.renyigesai.immortalers_delight.block.ancient_stove.AncientStoveBlock;\r\nimport com.renyigesai.immortalers_delight.block.ancient_stove.AncientStoveBlockEntity;\r\nimport com.renyigesai.immortalers_delight.block.enchantal_cooler.EnchantalCoolerBlock;\r\nimport com.renyigesai.immortalers_delight.block.enchantal_cooler.EnchantalCoolerBlockEntity;\r\nimport com.renyigesai.immortalers_delight.block.hanging_sign.ImmortalersDelightCeilingHangingSignBlock;\r\nimport com.renyigesai.immortalers_delight.block.hanging_sign.ImmortalersDelightWallHangingSignBlockBlock;\r\nimport com.renyigesai.immortalers_delight.block.sign.ImmortalersDelightStandingSignBlock;\r\nimport com.renyigesai.immortalers_delight.block.sign.ImmortalersDelightWallSignBlock;\r\nimport net.minecraft.core.Direction;\r\nimport net.minecraft.world.flag.FeatureFlag;\r\nimport net.minecraft.world.item.Item;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.level.block.*;\r\nimport net.minecraft.world.level.block.entity.BlockEntityType;\r\nimport net.minecraft.world.level.block.state.BlockBehaviour;\r\nimport net.minecraft.world.level.block.state.BlockState;\r\nimport net.minecraft.world.level.block.state.properties.BlockSetType;\r\nimport net.minecraft.world.level.block.state.properties.BlockStateProperties;\r\nimport net.minecraft.world.level.block.state.properties.NoteBlockInstrument;\r\nimport net.minecraft.world.level.block.state.properties.WoodType;\r\nimport net.minecraft.world.level.material.MapColor;\r\nimport net.minecraft.world.level.material.PushReaction;\r\nimport net.minecraftforge.eventbus.api.IEventBus;\r\nimport net.minecraftforge.registries.DeferredRegister;\r\nimport net.minecraftforge.registries.ForgeRegistries;\r\nimport net.minecraftforge.registries.RegistryObject;\r\nimport vectorwing.farmersdelight.common.block.CabinetBlock;\r\nimport vectorwing.farmersdelight.common.block.PieBlock;\r\n\r\nimport java.util.function.Supplier;\r\nimport java.util.function.ToIntFunction;\r\n\r\npublic class ImmortalersDelightBlocks {\r\n\r\n    public static final DeferredRegister<Block> BLOCKS =\r\n            DeferredRegister.create(ForgeRegistries.BLOCKS, ImmortalersDelightMod.MODID);\r\n\r\n    public static final DeferredRegister<BlockEntityType<?>> BLOCK_ENTITY_REGISTRY =\r\n            DeferredRegister.create(ForgeRegistries.BLOCK_ENTITY_TYPES, ImmortalersDelightMod.MODID);\r\n\r\n    public static final RegistryObject<Block> ENCHANTAL_COOLER;\r\n    public static final RegistryObject<BlockEntityType<EnchantalCoolerBlockEntity>> ENCHANTAL_COOLER_ENTITY;\r\n    public static final RegistryObject<Block> ANCIENT_STOVE;\r\n    public static final RegistryObject<BlockEntityType<AncientStoveBlockEntity>> ANCIENT_STOVE_ENTITY;\r\n    public static final RegistryObject<BlockEntityType<RotatingRoastMeatBlockEntity>> ROTATING_ROAST_MEAT_ENTITY;\r\n\r\n    public static final RegistryObject<Block> HIMEKAIDO_LOG = BLOCKS.register(\"himekaido_log\",() ->\r\n            log(MapColor.WOOD, MapColor.PODZOL));\r\n\r\n    public static final RegistryObject<Block> LEISAMBOO_STALK = BLOCKS.register(\"leisamboo_stalk\",() ->\r\n            new LeisambooStalkBlock(BlockBehaviour.Properties.of().mapColor(MapColor.PLANT).forceSolidOn().randomTicks().instabreak().strength(1.0F).sound(SoundType.BAMBOO).noOcclusion().dynamicShape()));\r\n    public static final RegistryObject<Block> LEISAMBOO_CROP = BLOCKS.register(\"leisamboo_crop\",() ->\r\n            new LeisambooCropBlock(BlockBehaviour.Properties.of().mapColor(MapColor.PLANT).forceSolidOn().randomTicks().instabreak().strength(1.0F).sound(SoundType.BAMBOO).noOcclusion().dynamicShape()));\r\n\r\n    public static final RegistryObject<Block> HIMEKAIDO_WOOD = BLOCKS.register(\"himekaido_wood\",() ->\r\n            log(MapColor.WOOD, MapColor.PODZOL));\r\n\r\n    public static final RegistryObject<Block> STRIPPED_HIMEKAIDO_WOOD = BLOCKS.register(\"stripped_himekaido_wood\",() ->\r\n            log(MapColor.WOOD, MapColor.PODZOL));\r\n\r\n    public static final RegistryObject<Block> STRIPPED_HIMEKAIDO_LOG = BLOCKS.register(\"stripped_himekaido_log\",() ->\r\n            log(MapColor.WOOD, MapColor.PODZOL));\r\n\r\n    public static final RegistryObject<Block> HIMEKAIDO_SHRUB = BLOCKS.register(\"himekaido_shrub\",() ->\r\n            new HimekaidoShrubBlock(BlockBehaviour.Properties.copy(Blocks.SWEET_BERRY_BUSH).noCollission().randomTicks().instabreak()));\r\n    public static final RegistryObject<Block> HIMEKAIDO_FRUITED_LEAVES = BLOCKS.register(\"himekaido_fruited_leaves\",() ->\r\n        new HimekaidoLeavesFruited(BlockBehaviour.Properties.copy(Blocks.OAK_LEAVES)));\r\n    public static final RegistryObject<Block> HIMEKAIDO_FLOWERING_LEAVES = BLOCKS.register(\"himekaido_flowering_leaves\",() ->\r\n        new HimekaidoLeavesGrowing((HimekaidoLeavesFruited) HIMEKAIDO_FRUITED_LEAVES.get(), BlockBehaviour.Properties.copy(Blocks.OAK_LEAVES)));\r\n    public static final RegistryObject<Block> HIMEKAIDO_LEAVES = BLOCKS.register(\"himekaido_leaves\",() ->\r\n            new HimekaidoLeavesGrowing((HimekaidoLeavesGrowing) HIMEKAIDO_FLOWERING_LEAVES.get(), BlockBehaviour.Properties.copy(Blocks.OAK_LEAVES)));\r\n\r\n    public static final RegistryObject<Block> HIMEKAIDO_PLANKS = BLOCKS.register(\"himekaido_planks\",\r\n            () -> new Block(BlockBehaviour.Properties.copy(Blocks.OAK_PLANKS)));\r\n\r\n    public static final RegistryObject<Block> HIMEKAIDO_STAIRS = BLOCKS.register(\"himekaido_stairs\",\r\n            () -> new StairBlock(HIMEKAIDO_PLANKS.get().defaultBlockState(),BlockBehaviour.Properties.copy(HIMEKAIDO_PLANKS.get())));\r\n\r\n    public static final RegistryObject<Block> HIMEKAIDO_SLAB = BLOCKS.register(\"himekaido_slab\",\r\n            () -> new SlabBlock(BlockBehaviour.Properties.copy(Blocks.OAK_SLAB)));\r\n\r\n    public static final RegistryObject<Block> HIMEKAIDO_DOOR = BLOCKS.register(\"himekaido_door\",\r\n            () -> new DoorBlock(BlockBehaviour.Properties.copy(Blocks.OAK_DOOR),BlockSetType.OAK));\r\n\r\n    public static final RegistryObject<Block> HIMEKAIDO_TRAPDOOR = BLOCKS.register(\"himekaido_trapdoor\",\r\n            () -> new TrapDoorBlock(BlockBehaviour.Properties.copy(Blocks.OAK_DOOR),BlockSetType.OAK));\r\n\r\n    public static final RegistryObject<Block> HIMEKAIDO_FENCE = BLOCKS.register(\"himekaido_fence\",\r\n            () -> new FenceBlock(BlockBehaviour.Properties.copy(Blocks.OAK_FENCE)));\r\n\r\n    public static final RegistryObject<Block> HIMEKAIDO_FENCE_GATE = BLOCKS.register(\"himekaido_fence_gate\",\r\n            () -> new FenceGateBlock(BlockBehaviour.Properties.copy(Blocks.OAK_FENCE_GATE), WoodType.OAK));\r\n\r\n    public static final RegistryObject<Block> HIMEKAIDO_PRESSURE_PLATE = BLOCKS.register(\"himekaido_pressure_plate\",\r\n            () -> new PressurePlateBlock(PressurePlateBlock.Sensitivity.EVERYTHING,BlockBehaviour.Properties.copy(Blocks.OAK_FENCE_GATE),BlockSetType.OAK));\r\n\r\n    public static final RegistryObject<Block> HIMEKAIDO_BUTTON = BLOCKS.register(\"himekaido_button\",\r\n            () ->woodenButton(BlockSetType.OAK));\r\n\r\n    public static final RegistryObject<Block> HIMEKAIDO_CABINET = BLOCKS.register(\"himekaido_cabinet\",\r\n            () -> new CabinetBlock(Block.Properties.copy(Blocks.BARREL)));\r\n\r\n    public static final RegistryObject<Block> MILLENIAN_BAMBOO = BLOCKS.register(\"millenian_bamboo\",\r\n            () -> new MillenianBambooBlock(BlockBehaviour.Properties.of().mapColor(MapColor.PLANT).strength(2.0F,3.0F).sound(SoundType.BAMBOO),ImmortalersDelightItems.BOWL_OF_MILLENIAN_BAMBOO));\r\n    public static final RegistryObject<Block> HIMEKAIDO_SIGN = BLOCKS.register(\"himekaido_sign\",\r\n            () ->  new ImmortalersDelightStandingSignBlock(BlockBehaviour.Properties.of().mapColor(MapColor.WOOD).forceSolidOn().instrument(NoteBlockInstrument.BASS).noCollission().strength(1.0F).ignitedByLava(), ImmortalersDelightWoodType.HIMEKAIDO));\r\n    public static final RegistryObject<Block>  HIMEKAIDO_WALL_SIGN = BLOCKS.register(\"himekaido_wall_sign\",\r\n            () -> new ImmortalersDelightWallSignBlock(BlockBehaviour.Properties.of().mapColor(MapColor.WOOD).forceSolidOn().instrument(NoteBlockInstrument.BASS).noCollission().strength(1.0F).dropsLike(HIMEKAIDO_SIGN.get()).ignitedByLava(), ImmortalersDelightWoodType.HIMEKAIDO));\r\n\r\n    public static final RegistryObject<Block> HIMEKAIDO_HANGING_SIGN = BLOCKS.register(\"himekaido_hanging_sign\",\r\n            () ->  new ImmortalersDelightCeilingHangingSignBlock(BlockBehaviour.Properties.of().mapColor(MapColor.WOOD).forceSolidOn().instrument(NoteBlockInstrument.BASS).noCollission().strength(1.0F).ignitedByLava(), ImmortalersDelightWoodType.HIMEKAIDO));\r\n    public static final RegistryObject<Block>  HIMEKAIDO_WALL_HANGING_SIGN = BLOCKS.register(\"himekaido_wall_hanging_sign\",\r\n            () -> new ImmortalersDelightWallHangingSignBlockBlock(BlockBehaviour.Properties.of().mapColor(MapColor.WOOD).forceSolidOn().instrument(NoteBlockInstrument.BASS).noCollission().strength(1.0F).dropsLike(HIMEKAIDO_SIGN.get()).ignitedByLava(), ImmortalersDelightWoodType.HIMEKAIDO));\r\n    /*\r\n    古木\r\n    */\r\n\r\n    public static final RegistryObject<Block> ANCIENT_WOOD_LOG = BLOCKS.register(\"ancient_wood_log\",() ->\r\n            log(MapColor.WOOD, MapColor.PODZOL));\r\n\r\n    public static final RegistryObject<Block> ANCIENT_WOOD = BLOCKS.register(\"ancient_wood\",() ->\r\n            log(MapColor.WOOD, MapColor.PODZOL));\r\n\r\n    public static final RegistryObject<Block> STRIPPED_ANCIENT_WOOD = BLOCKS.register(\"stripped_ancient_wood\",() ->\r\n            log(MapColor.WOOD, MapColor.PODZOL));\r\n\r\n    public static final RegistryObject<Block> STRIPPED_ANCIENT_WOOD_LOG = BLOCKS.register(\"stripped_ancient_wood_log\",() ->\r\n            log(MapColor.WOOD, MapColor.PODZOL));\r\n\r\n    public static final RegistryObject<Block> ANCIENT_WOOD_PLANKS = BLOCKS.register(\"ancient_wood_planks\",\r\n            () -> new Block(BlockBehaviour.Properties.copy(Blocks.OAK_PLANKS)));\r\n\r\n    public static final RegistryObject<Block> ANCIENT_WOOD_CABINET = BLOCKS.register(\"ancient_wood_cabinet\",\r\n            () -> new CabinetBlock(Block.Properties.copy(Blocks.BARREL)));\r\n\r\n    public static final RegistryObject<Block> ANCIENT_WOOD_STAIRS = BLOCKS.register(\"ancient_wood_stairs\",\r\n            () -> new StairBlock(HIMEKAIDO_PLANKS.get().defaultBlockState(),BlockBehaviour.Properties.copy(ANCIENT_WOOD_PLANKS.get())));\r\n\r\n    public static final RegistryObject<Block> ANCIENT_WOOD_SLAB = BLOCKS.register(\"ancient_wood_slab\",\r\n            () -> new SlabBlock(BlockBehaviour.Properties.copy(Blocks.OAK_SLAB)));\r\n\r\n    public static final RegistryObject<Block> ANCIENT_WOOD_DOOR = BLOCKS.register(\"ancient_wood_door\",\r\n            () -> new DoorBlock(BlockBehaviour.Properties.copy(Blocks.OAK_DOOR),BlockSetType.OAK));\r\n\r\n        public static final RegistryObject<Block> ANCIENT_WOOD_TRAPDOOR = BLOCKS.register(\"ancient_wood_trapdoor\",\r\n            () -> new TrapDoorBlock(BlockBehaviour.Properties.copy(Blocks.OAK_DOOR),BlockSetType.OAK));\r\n\r\n    public static final RegistryObject<Block> ANCIENT_WOOD_FENCE = BLOCKS.register(\"ancient_wood_fence\",\r\n            () -> new FenceBlock(BlockBehaviour.Properties.copy(Blocks.OAK_FENCE)));\r\n\r\n    public static final RegistryObject<Block> ANCIENT_WOOD_FENCE_GATE = BLOCKS.register(\"ancient_wood_fence_gate\",\r\n            () -> new FenceGateBlock(BlockBehaviour.Properties.copy(Blocks.OAK_FENCE_GATE), WoodType.OAK));\r\n\r\n    public static final RegistryObject<Block> ANCIENT_WOOD_PRESSURE_PLATE = BLOCKS.register(\"ancient_wood_pressure_plate\",\r\n            () -> new PressurePlateBlock(PressurePlateBlock.Sensitivity.EVERYTHING,BlockBehaviour.Properties.copy(Blocks.OAK_PRESSURE_PLATE),BlockSetType.OAK));\r\n\r\n    public static final RegistryObject<Block> ANCIENT_WOOD_BUTTON = BLOCKS.register(\"ancient_wood_button\",\r\n            () ->woodenButton(BlockSetType.OAK));\r\n\r\n    /**\r\n     * 溪柱制品\r\n     */\r\n    public static final RegistryObject<Block> LEISAMBOO_PLANKS = BLOCKS.register(\"leisamboo_planks\",\r\n            () -> new Block(BlockBehaviour.Properties.copy(Blocks.OAK_PLANKS)));\r\n\r\n    public static final RegistryObject<Block> LEISAMBOO_STAIRS = BLOCKS.register(\"leisamboo_stairs\",\r\n            () -> new StairBlock(LEISAMBOO_PLANKS.get().defaultBlockState(),BlockBehaviour.Properties.copy(LEISAMBOO_PLANKS.get())));\r\n\r\n    public static final RegistryObject<Block> LEISAMBOO_SLAB = BLOCKS.register(\"leisamboo_slab\",\r\n            () -> new SlabBlock(BlockBehaviour.Properties.copy(Blocks.OAK_SLAB)));\r\n    public static final RegistryObject<Block> LEISAMBOO_DOOR = BLOCKS.register(\"leisamboo_door\",\r\n            () -> new DoorBlock(BlockBehaviour.Properties.copy(Blocks.OAK_DOOR),BlockSetType.OAK));\r\n\r\n    public static final RegistryObject<Block> LEISAMBOO_TRAPDOOR = BLOCKS.register(\"leisamboo_trapdoor\",\r\n            () -> new TrapDoorBlock(BlockBehaviour.Properties.copy(Blocks.OAK_DOOR),BlockSetType.OAK));\r\n\r\n    public static final RegistryObject<Block> LEISAMBOO_FENCE = BLOCKS.register(\"leisamboo_fence\",\r\n            () -> new FenceBlock(BlockBehaviour.Properties.copy(Blocks.OAK_FENCE)));\r\n\r\n    public static final RegistryObject<Block> LEISAMBOO_FENCE_GATE = BLOCKS.register(\"leisamboo_fence_gate\",\r\n            () -> new FenceGateBlock(BlockBehaviour.Properties.copy(Blocks.OAK_FENCE_GATE), WoodType.OAK));\r\n\r\n    public static final RegistryObject<Block> LEISAMBOO_PRESSURE_PLATE = BLOCKS.register(\"leisamboo_pressure_plate\",\r\n            () -> new PressurePlateBlock(PressurePlateBlock.Sensitivity.EVERYTHING,BlockBehaviour.Properties.copy(Blocks.OAK_FENCE_GATE),BlockSetType.OAK));\r\n\r\n    public static final RegistryObject<Block> LEISAMBOO_BUTTON = BLOCKS.register(\"leisamboo_button\",\r\n            () ->woodenButton(BlockSetType.OAK));\r\n\r\n    public static final RegistryObject<Block> LEISAMBOO_CABINET = BLOCKS.register(\"leisamboo_cabinet\",\r\n            () -> new CabinetBlock(Block.Properties.copy(Blocks.BARREL)));\r\n\r\n    public static final RegistryObject<Block> LEISAMBOO_SIGN = BLOCKS.register(\"leisamboo_sign\",\r\n            () ->  new ImmortalersDelightStandingSignBlock(BlockBehaviour.Properties.of().mapColor(MapColor.WOOD).forceSolidOn().instrument(NoteBlockInstrument.BASS).noCollission().strength(1.0F).ignitedByLava(), ImmortalersDelightWoodType.LEISAMBOO));\r\n    public static final RegistryObject<Block>  LEISAMBOO_WALL_SIGN = BLOCKS.register(\"leisamboo_wall_sign\",\r\n            () -> new ImmortalersDelightWallSignBlock(BlockBehaviour.Properties.of().mapColor(MapColor.WOOD).forceSolidOn().instrument(NoteBlockInstrument.BASS).noCollission().strength(1.0F).dropsLike(LEISAMBOO_SIGN.get()).ignitedByLava(), ImmortalersDelightWoodType.LEISAMBOO));\r\n\r\n    public static final RegistryObject<Block> LEISAMBOO_HANGING_SIGN = BLOCKS.register(\"leisamboo_hanging_sign\",\r\n            () ->  new ImmortalersDelightCeilingHangingSignBlock(BlockBehaviour.Properties.of().mapColor(MapColor.WOOD).forceSolidOn().instrument(NoteBlockInstrument.BASS).noCollission().strength(1.0F).ignitedByLava(), ImmortalersDelightWoodType.LEISAMBOO));\r\n    public static final RegistryObject<Block>  LEISAMBOO_WALL_HANGING_SIGN = BLOCKS.register(\"leisamboo_wall_hanging_sign\",\r\n            () -> new ImmortalersDelightWallHangingSignBlockBlock(BlockBehaviour.Properties.of().mapColor(MapColor.WOOD).forceSolidOn().instrument(NoteBlockInstrument.BASS).noCollission().strength(1.0F).dropsLike(LEISAMBOO_HANGING_SIGN.get()).ignitedByLava(), ImmortalersDelightWoodType.LEISAMBOO));\r\n\r\n    public static final RegistryObject<Block> EVOLUTCORN = BLOCKS.register(\"evolutcorn\",\r\n            () -> new EvolutcornBlock(BlockBehaviour.Properties.of().mapColor(MapColor.PLANT).noCollission().randomTicks().instabreak().sound(SoundType.CROP).pushReaction(PushReaction.DESTROY)));\r\n\r\n    public static final RegistryObject<Block> PEARLIPEARL_BUNDLE = BLOCKS.register(\"pearlipearl_bundle\",\r\n            ()-> new PearlipearlBeanBlock(BlockBehaviour.Properties.of().mapColor(MapColor.COLOR_GREEN).instrument(NoteBlockInstrument.DIDGERIDOO).strength(0.5F).sound(SoundType.WOOD).pushReaction(PushReaction.DESTROY).randomTicks()));\r\n\r\n    public static final RegistryObject<Block> PEARLIPEARL_STALK = BLOCKS.register(\"pearlipearl_stalk\",\r\n            ()-> new PearlipearlStalkBlock(BlockBehaviour.Properties.of().mapColor(MapColor.COLOR_GREEN).instrument(NoteBlockInstrument.DIDGERIDOO).strength(1.0F).sound(SoundType.WOOD).pushReaction(PushReaction.DESTROY).randomTicks()));\r\n\r\n    public static final RegistryObject<Block> ZEA_PANCAKE = BLOCKS.register(\"zea_pancake\",()->\r\n            new ZeaPancakeBLock(BlockBehaviour.Properties.copy(Blocks.CAKE)));\r\n\r\n    public static final RegistryObject<Block> STEWED_ROTTEN_MEAT_POT = BLOCKS.register(\"stewed_rotten_meat_pot\",()->\r\n            new StewedRottenMeatPot(BlockBehaviour.Properties.copy(Blocks.DECORATED_POT),ImmortalersDelightItems.BOWL_OF_STEWED_ROTTEN_MEAT_IN_CLAY_POT));\r\n    public static final RegistryObject<Block> BRAISED_SPIDER_EYES_BLOCK = BLOCKS.register(\"braised_spider_eyes_block\",()->\r\n            new BraisedSpiderEyesBlock(BlockBehaviour.Properties.copy(Blocks.CAKE)));\r\n\r\n    public static final RegistryObject<Block> ROTATING_ROAST_MEAT = BLOCKS.register(\"rotating_roast_meat\",()->\r\n            new RotatingRoastMeatBlock(BlockBehaviour.Properties.copy(Blocks.CAKE)));\r\n\r\n    public static final RegistryObject<Block> SNIFFER_ROTATING_ROAST_MEAT = BLOCKS.register(\"sniffer_rotating_roast_meat\",()->\r\n            new RotatingRoastMeatBlock(BlockBehaviour.Properties.copy(Blocks.CAKE)));\r\n\r\n    public static final RegistryObject<Block> TARTARE_CHICKEN_BIG_MEAL = BLOCKS.register(\"tartare_chicken_big_meal\",()->\r\n            new TartareChickenBigMealBlock(BlockBehaviour.Properties.copy(Blocks.CAKE)));\r\n\r\n    public static final RegistryObject<Block> EVOLUTCORN_GRAIN_BAG = BLOCKS.register(\"evolutcorn_grain_bag\",()->\r\n            new Block(BlockBehaviour.Properties.copy(Blocks.WHITE_WOOL)));\r\n\r\n    public static final RegistryObject<Block> HIMEKAIDO_CRATE = BLOCKS.register(\"himekaido_crate\",()->\r\n            new Block(BlockBehaviour.Properties.copy(Blocks.OAK_PLANKS).strength(2.0F, 3.0F).sound(SoundType.WOOD)));\r\n\r\n    public static final RegistryObject<Block> PEARLIP_CRATE = BLOCKS.register(\"pearlip_crate\",()->\r\n            new Block(BlockBehaviour.Properties.copy(Blocks.OAK_PLANKS).strength(2.0F, 3.0F).sound(SoundType.WOOD)));\r\n    public static final RegistryObject<Block> BEEF_CRATE = BLOCKS.register(\"beef_crate\",()->\r\n            new Block(BlockBehaviour.Properties.copy(Blocks.OAK_PLANKS).strength(2.0F, 3.0F).sound(SoundType.WOOD)));\r\n    public static final RegistryObject<Block> COOKED_BEEF_CRATE = BLOCKS.register(\"cooked_beef_crate\",()->\r\n            new Block(BlockBehaviour.Properties.copy(Blocks.OAK_PLANKS).strength(2.0F, 3.0F).sound(SoundType.WOOD)));\r\n    public static final RegistryObject<Block> CHICKEN_CRATE = BLOCKS.register(\"chicken_crate\",()->\r\n            new Block(BlockBehaviour.Properties.copy(Blocks.OAK_PLANKS).strength(2.0F, 3.0F).sound(SoundType.WOOD)));\r\n    public static final RegistryObject<Block> SPIDER_EYE_CRATE = BLOCKS.register(\"spider_eye_crate\",()->\r\n            new Block(BlockBehaviour.Properties.copy(Blocks.OAK_PLANKS).strength(2.0F, 3.0F).sound(SoundType.WOOD)));\r\n\r\n    public static final RegistryObject<Block> EVOLUTCORN_BLOCK = BLOCKS.register(\"evolutcorn_block\",()->\r\n            new Block(BlockBehaviour.Properties.copy(Blocks.HAY_BLOCK)));\r\n\r\n    public static final RegistryObject<Block> CULTURAL_LEGACY = BLOCKS.register(\"cultural_legacy\",\r\n            () -> new CulturalLegacyEffectToolBlock(BlockBehaviour.Properties.of().mapColor(MapColor.PLANT).noCollission().randomTicks().lightLevel(ageBlockEmission(2)).instabreak().sound(SoundType.GLASS).pushReaction(PushReaction.DESTROY)));\r\n\r\n    public static final RegistryObject<Block> PEARLIP_PIE = BLOCKS.register(\"pearlip_pie\",()->\r\n            new PieBlock(BlockBehaviour.Properties.copy(Blocks.CAKE),ImmortalersDelightItems.PEARLIP_PIE_SLICE));\r\n\r\n    public static final RegistryObject<Block> HIMEKAIDO_YOGURT_PIE = BLOCKS.register(\"himekaido_yogurt_pie\",()->\r\n            new PieBlock(BlockBehaviour.Properties.copy(Blocks.CAKE),ImmortalersDelightItems.HIMEKAIDO_YOGURT_PIE_SLICE));\r\n\r\n    public static final RegistryObject<Block> KWAT_WHEAT = BLOCKS.register(\"kwat_wheat\",\r\n            () -> new KwatWheatCrop(BlockBehaviour.Properties.of().mapColor(MapColor.PLANT).noCollission().randomTicks().instabreak().sound(SoundType.CROP).pushReaction(PushReaction.DESTROY)));\r\n\r\n    public static final RegistryObject<Block> NETHER_BREAD_CREAM_SOUP = BLOCKS.register(\"nether_bread_cream_soup\",\r\n            () -> new KwatWheatToastStewedVegetablesBlock(BlockBehaviour.Properties.copy(Blocks.CAKE)));\r\n\r\n    public static final RegistryObject<Block> POD_SHELL_BURGER_MEAT = BLOCKS.register(\"pod_shell_burger_meat\",\r\n            () -> new PodShellBurgerMeatBlock(BlockBehaviour.Properties.copy(Blocks.CAKE)));\r\n\r\n    public static final RegistryObject<Block> OXIDIZED_ANCIENT_STOVE = BLOCKS.register(\"oxidized_ancient_stove\",\r\n            () -> new OxidizedAncientStoveBlock(BlockBehaviour.Properties.of().mapColor(MapColor.COLOR_ORANGE).requiresCorrectToolForDrops().strength(3.0F, 6.0F).sound(SoundType.COPPER)) {\r\n            });\r\n\r\n    //oxidized\r\n\r\n    static {\r\n        //方块实体 Block Entity\r\n\r\n        ENCHANTAL_COOLER = BLOCKS.register(\"enchantal_cooler\",()->\r\n                new EnchantalCoolerBlock(BlockBehaviour.Properties.copy(Blocks.STONE)));\r\n\r\n        ENCHANTAL_COOLER_ENTITY = BLOCK_ENTITY_REGISTRY.register(\"enchantal_cooler\",\r\n                ()-> BlockEntityType.Builder.of(EnchantalCoolerBlockEntity::new, ENCHANTAL_COOLER.get()).build(null));\r\n\r\n        ANCIENT_STOVE = BLOCKS.register(\"ancient_stove\",()->\r\n                new AncientStoveBlock(BlockBehaviour.Properties.of().mapColor(MapColor.COLOR_ORANGE).requiresCorrectToolForDrops().strength(3.0F, 6.0F).sound(SoundType.COPPER)));\r\n\r\n        ANCIENT_STOVE_ENTITY = BLOCK_ENTITY_REGISTRY.register(\"ancient_stove\",\r\n                ()-> BlockEntityType.Builder.of(AncientStoveBlockEntity::new, ANCIENT_STOVE.get()).build(null));\r\n\r\n        ROTATING_ROAST_MEAT_ENTITY = BLOCK_ENTITY_REGISTRY.register(\"rotating_roast_meat\",\r\n                ()-> BlockEntityType.Builder.of(RotatingRoastMeatBlockEntity::new, ROTATING_ROAST_MEAT.get()).build(null));\r\n    }\r\n\r\n    private static ToIntFunction<BlockState> ageBlockEmission(int exLightValue) {\r\n        return (p_50763_) -> {\r\n            return p_50763_.getValue(BlockStateProperties.AGE_7) + exLightValue;\r\n        };\r\n    }\r\n    private static BasicsLogsBlock log(MapColor p_285370_, MapColor p_285126_) {\r\n        return new BasicsLogsBlock(BlockBehaviour.Properties.of().mapColor((p_152624_) -> {\r\n            return p_152624_.getValue(BasicsLogsBlock.AXIS) == Direction.Axis.Y ? p_285370_ : p_285126_;\r\n        }).instrument(NoteBlockInstrument.BASS).strength(2.0F).sound(SoundType.WOOD).ignitedByLava());\r\n    }\r\n\r\n    private static ButtonBlock woodenButton(BlockSetType p_278239_, FeatureFlag... p_278229_) {\r\n        BlockBehaviour.Properties blockbehaviour$properties = BlockBehaviour.Properties.of().noCollission().strength(0.5F).pushReaction(PushReaction.DESTROY);\r\n        if (p_278229_.length > 0) {\r\n            blockbehaviour$properties = blockbehaviour$properties.requiredFeatures(p_278229_);\r\n        }\r\n\r\n        return new ButtonBlock(blockbehaviour$properties, p_278239_, 30, true);\r\n    }\r\n\r\n\r\n    public static void register(IEventBus eventBus) {\r\n        BLOCKS.register(eventBus);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightBlocks.java b/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightBlocks.java
--- a/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightBlocks.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightBlocks.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.init;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.block.*;
 import com.renyigesai.immortalers_delight.block.ancient_stove.AncientStoveBlock;
 import com.renyigesai.immortalers_delight.block.ancient_stove.AncientStoveBlockEntity;
@@ -12,8 +12,6 @@
 import com.renyigesai.immortalers_delight.block.sign.ImmortalersDelightWallSignBlock;
 import net.minecraft.core.Direction;
 import net.minecraft.world.flag.FeatureFlag;
-import net.minecraft.world.item.Item;
-import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.block.*;
 import net.minecraft.world.level.block.entity.BlockEntityType;
 import net.minecraft.world.level.block.state.BlockBehaviour;
@@ -31,7 +29,6 @@
 import vectorwing.farmersdelight.common.block.CabinetBlock;
 import vectorwing.farmersdelight.common.block.PieBlock;
 
-import java.util.function.Supplier;
 import java.util.function.ToIntFunction;
 
 public class ImmortalersDelightBlocks {
@@ -229,6 +226,9 @@
     public static final RegistryObject<Block> TARTARE_CHICKEN_BIG_MEAL = BLOCKS.register("tartare_chicken_big_meal",()->
             new TartareChickenBigMealBlock(BlockBehaviour.Properties.copy(Blocks.CAKE)));
 
+    public static final RegistryObject<Block> SCARLET_DEVILS_CAKE = BLOCKS.register("scarlet_devils_cake",()->
+            new ScarletDevilsCakeBlock(BlockBehaviour.Properties.copy(Blocks.CAKE)));
+
     public static final RegistryObject<Block> EVOLUTCORN_GRAIN_BAG = BLOCKS.register("evolutcorn_grain_bag",()->
             new Block(BlockBehaviour.Properties.copy(Blocks.WHITE_WOOL)));
 
Index: src/main/java/com/renyigesai/immortalers_delight/block/CulturalLegacyEffectToolBlock.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.block;\r\n\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightItems;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.core.Direction;\r\nimport net.minecraft.core.particles.ParticleTypes;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport net.minecraft.sounds.SoundEvent;\r\nimport net.minecraft.sounds.SoundSource;\r\nimport net.minecraft.tags.BlockTags;\r\nimport net.minecraft.util.ParticleUtils;\r\nimport net.minecraft.util.RandomSource;\r\nimport net.minecraft.world.InteractionHand;\r\nimport net.minecraft.world.InteractionResult;\r\nimport net.minecraft.world.effect.MobEffect;\r\nimport net.minecraft.world.effect.MobEffects;\r\nimport net.minecraft.world.entity.player.Player;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.level.*;\r\nimport net.minecraft.world.level.block.Block;\r\nimport net.minecraft.world.level.block.Blocks;\r\nimport net.minecraft.world.level.block.state.BlockState;\r\nimport net.minecraft.world.level.block.state.StateDefinition;\r\nimport net.minecraft.world.level.block.state.properties.BlockStateProperties;\r\nimport net.minecraft.world.level.block.state.properties.BooleanProperty;\r\nimport net.minecraft.world.level.block.state.properties.IntegerProperty;\r\nimport net.minecraft.world.level.material.FluidState;\r\nimport net.minecraft.world.level.storage.loot.LootParams;\r\nimport net.minecraft.world.phys.BlockHitResult;\r\nimport net.minecraft.world.phys.shapes.CollisionContext;\r\nimport net.minecraft.world.phys.shapes.Shapes;\r\nimport net.minecraft.world.phys.shapes.VoxelShape;\r\nimport net.minecraftforge.common.MinecraftForge;\r\nimport net.minecraftforge.event.enchanting.EnchantmentLevelSetEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\nimport vectorwing.farmersdelight.common.registry.ModSounds;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.OptionalInt;\r\n\r\n@Mod.EventBusSubscriber\r\npublic class CulturalLegacyEffectToolBlock extends ReapCropBlock{\r\n    /*\r\n    用于显示附魔台粒子的列表\r\n     */\r\n    public static final List<BlockPos> BOOKSHELF_OFFSETS = BlockPos.betweenClosedStream(-2, 0, -2, 2, 1, 2).filter((p_207914_) -> {\r\n        return Math.abs(p_207914_.getX()) == 2 || Math.abs(p_207914_.getZ()) == 2;\r\n    }).map(BlockPos::immutable).toList();\r\n\r\n    /*\r\n     结构空位的轮廓形状\r\n     */\r\n    protected static final VoxelShape OUTLINE_SHAPE = Block.box(6.0D, 6.0D, 6.0D, 10.0D, 10.0D, 10.0D);\r\n\r\n    public CulturalLegacyEffectToolBlock(Properties p_52247_) {\r\n        super(p_52247_);\r\n        MinecraftForge.EVENT_BUS.register(this);\r\n    }\r\n    public boolean isRandomlyTicking(BlockState pState) {\r\n        return true;\r\n    }\r\n    /*\r\n     执行随机 tick 逻辑，移除方块\r\n     */\r\n    public void randomTick(BlockState pState, ServerLevel pLevel, BlockPos pPos, RandomSource pRandom) {\r\n        /*\r\n        执行生长逻辑\r\n         */\r\n        if (!pLevel.isAreaLoaded(pPos, 1)) return; // Forge: prevent loading unloaded chunks when checking neighbor's light\r\n        if (pLevel.getRawBrightness(pPos, 0) >= 9) {\r\n            int i = this.getAge(pState);\r\n            if (i < this.getMaxAge()) {\r\n                float f = getGrowthSpeed(this, pLevel, pPos);\r\n                if (net.minecraftforge.common.ForgeHooks.onCropsGrowPre(pLevel, pPos, pState, pRandom.nextInt((int)(25.0F / f) + 1) == 0)) {\r\n                    pLevel.setBlock(pPos,Blocks.AIR.defaultBlockState(),2);\r\n                    net.minecraftforge.common.ForgeHooks.onCropsGrowPost(pLevel, pPos, pState);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /*\r\n     获取树叶方块的光照强度，这里返回1，表示树叶有一定的透光性\r\n     */\r\n    public int getLightBlock(BlockState p_54460_, BlockGetter p_54461_, BlockPos p_54462_) {\r\n        return 1;\r\n    }\r\n    /*\r\n     在客户端定期调用，用于显示附魔台粒子效果\r\n     */\r\n    public void animateTick(BlockState pState, Level pLevel, BlockPos pPos, RandomSource pRandom) {\r\n        super.animateTick(pState, pLevel, pPos, pRandom);\r\n\r\n        for(BlockPos blockpos : BOOKSHELF_OFFSETS) {\r\n            if (pRandom.nextInt(16) == 0 && isValidBookShelf(pLevel, pPos, blockpos)) {\r\n                pLevel.addParticle(ParticleTypes.ENCHANT, (double)pPos.getX() + 0.5D, (double)pPos.getY() + 2.0D, (double)pPos.getZ() + 0.5D, (double)((float)blockpos.getX() + pRandom.nextFloat()) - 0.5D, (double)((float)blockpos.getY() - pRandom.nextFloat() - 1.0F), (double)((float)blockpos.getZ() + pRandom.nextFloat()) - 0.5D);\r\n            }\r\n        }\r\n\r\n    }\r\n    public static boolean isValidBookShelf(Level pLevel, BlockPos pTablePos, BlockPos pOffsetPos) {\r\n        return pLevel.getBlockState(pTablePos.offset(pOffsetPos)).getEnchantPowerBonus(pLevel, pTablePos.offset(pOffsetPos)) != 0 && pLevel.getBlockState(pTablePos.offset(pOffsetPos.getX() / 2, pOffsetPos.getY(), pOffsetPos.getZ() / 2)).is(BlockTags.ENCHANTMENT_POWER_TRANSMITTER);\r\n    }\r\n    /*\r\n     判断作物是否能在给定环境中存活\r\n     重写存活条件以确保能跟树叶一样浮空放置\r\n     */\r\n    @Override\r\n    public boolean canSurvive(BlockState pState, LevelReader pLevel, BlockPos pPos) {\r\n        return (true);\r\n    }\r\n\r\n    @SubscribeEvent\r\n    public void onEnchantmentLevelSet(EnchantmentLevelSetEvent event) {\r\n        if (event == null || event.isCanceled()) {\r\n            return;\r\n        }\r\n\r\n        // 获取世界和附魔台的位置\r\n        Level level = event.getLevel();\r\n        BlockPos pos = event.getPos();\r\n\r\n        // 以附魔台为中心，检查 5*5 范围内的方块\r\n        int goldBlockCount = maxAgeToolBlocksInRange(level, pos, 2); // 2 表示从中心到边缘的距离\r\n\r\n        // 根据金块数量计算新的附魔等级\r\n        int newLevel = calculateNewLevel(event.getEnchantLevel(), goldBlockCount);\r\n\r\n        // 设置新的附魔等级\r\n        event.setEnchantLevel(newLevel);\r\n    }\r\n\r\n    /**\r\n     * 处理指定范围内的指定方块\r\n     * @param level 世界\r\n     * @param centerPos 中心位置\r\n     * @param range 范围（从中心到边缘的距离）\r\n     * @return 最大Age\r\n     */\r\n    private int maxAgeToolBlocksInRange(Level level, BlockPos centerPos, int range) {\r\n        int maxAge = 0;\r\n        for (int x = -range; x <= range; x++) {\r\n            for (int y = -range; y <= range; y++) {\r\n                for (int z = -range; z <= range; z++) {\r\n                    BlockPos checkPos = centerPos.offset(x, y, z);\r\n                    if (level.getBlockState(checkPos).getBlock() instanceof CulturalLegacyEffectToolBlock) {\r\n                        int ageHere = this.getAge(level.getBlockState(checkPos));\r\n                        maxAge = maxAge > ageHere + 1 ? maxAge : ageHere + 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return maxAge;\r\n    }\r\n\r\n    /**\r\n     * 范围内最大AGE的当前方块设置附魔等级\r\n     * @param originalLevel 原始附魔等级\r\n     * @param maxAge 范围内最大Age\r\n     * @return 新的附魔等级\r\n     */\r\n    private static int calculateNewLevel(int originalLevel, int maxAge) {\r\n        // 根据范围内最大AGE的当前方块设置附魔等级。\r\n        int newLevel = originalLevel + 8 + 4 * (maxAge - 1);\r\n        return Math.min(30, newLevel);\r\n    }\r\n    @Override\r\n    protected ItemLike getBaseSeedId() {\r\n        return ImmortalersDelightItems.BOWL_OF_MILLENIAN_BAMBOO.get();\r\n    }\r\n\r\n    /*\r\n    获取仙人掌的轮廓形状\r\n     */\r\n    public VoxelShape getShape(BlockState pState, BlockGetter pLevel, BlockPos pPos, CollisionContext pContext) {\r\n        return OUTLINE_SHAPE;\r\n    }\r\n\r\n    @Override\r\n    public List<ItemStack> getDrops(BlockState p_287732_, LootParams.Builder p_287596_) {\r\n        return super.getDrops(p_287732_, p_287596_);\r\n    }\r\n\r\n    @Override\r\n    public boolean onDestroyedByPlayer(BlockState state, Level level, BlockPos pos, Player player, boolean willHarvest, FluidState fluid) {\r\n        return super.onDestroyedByPlayer(state, level, pos, player, willHarvest, fluid);\r\n    }\r\n    @Override\r\n    public boolean isValidBonemealTarget(LevelReader p_255715_, BlockPos p_52259_, BlockState p_52260_, boolean p_52261_) {\r\n        return false;\r\n    }\r\n    @Override\r\n    public void performBonemeal(ServerLevel p_221040_, RandomSource p_221041_, BlockPos p_221042_, BlockState p_221043_) {\r\n        if (this.getAge(p_221043_) < this.getMaxAge()) {\r\n            p_221040_.setBlock(p_221042_, this.getStateForAge(this.getAge(p_221043_) + 1), 2);\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/block/CulturalLegacyEffectToolBlock.java b/src/main/java/com/renyigesai/immortalers_delight/block/CulturalLegacyEffectToolBlock.java
--- a/src/main/java/com/renyigesai/immortalers_delight/block/CulturalLegacyEffectToolBlock.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/block/CulturalLegacyEffectToolBlock.java	
@@ -124,11 +124,13 @@
         // 以附魔台为中心，检查 5*5 范围内的方块
         int goldBlockCount = maxAgeToolBlocksInRange(level, pos, 2); // 2 表示从中心到边缘的距离
 
-        // 根据金块数量计算新的附魔等级
-        int newLevel = calculateNewLevel(event.getEnchantLevel(), goldBlockCount);
+        if (goldBlockCount > 0) {
+            // 如果有金,根据金块数量计算新的附魔等级
+            int newLevel = calculateNewLevel(event.getEnchantLevel(), goldBlockCount);
 
-        // 设置新的附魔等级
-        event.setEnchantLevel(newLevel);
+            // 设置新的附魔等级
+            event.setEnchantLevel(newLevel);
+        }
     }
 
     /**
Index: src/main/java/com/renyigesai/immortalers_delight/block/ScarletDevilsCakeBlock.java
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/block/ScarletDevilsCakeBlock.java b/src/main/java/com/renyigesai/immortalers_delight/block/ScarletDevilsCakeBlock.java
new file mode 100644
--- /dev/null	
+++ b/src/main/java/com/renyigesai/immortalers_delight/block/ScarletDevilsCakeBlock.java	
@@ -0,0 +1,160 @@
+package com.renyigesai.immortalers_delight.block;
+
+import com.mojang.datafixers.util.Pair;
+import com.renyigesai.immortalers_delight.init.ImmortalersDelightItems;
+import com.renyigesai.immortalers_delight.util.ItemUtils;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.sounds.SoundEvents;
+import net.minecraft.sounds.SoundSource;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.InteractionResult;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.context.BlockPlaceContext;
+import net.minecraft.world.level.BlockGetter;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LevelAccessor;
+import net.minecraft.world.level.LevelReader;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.HorizontalDirectionalBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.StateDefinition;
+import net.minecraft.world.level.block.state.properties.IntegerProperty;
+import net.minecraft.world.level.gameevent.GameEvent;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.shapes.CollisionContext;
+import net.minecraft.world.phys.shapes.VoxelShape;
+import vectorwing.farmersdelight.common.tag.ModTags;
+
+public class ScarletDevilsCakeBlock extends HorizontalDirectionalBlock {
+
+    public static final IntegerProperty BITES = IntegerProperty.create("bites",0,8);
+    public static final VoxelShape BOX = box(1.0D,0.0D,1.0D,15.0D,12.0D,15.0D);
+
+    public ScarletDevilsCakeBlock(Properties p_54120_) {
+        super(p_54120_);
+        super.registerDefaultState(defaultBlockState().setValue(BITES,0).setValue(FACING, Direction.NORTH));
+    }
+
+    @Override
+    public VoxelShape getShape(BlockState state, BlockGetter getter, BlockPos pos, CollisionContext context) {
+        return BOX;
+    }
+
+    @Override
+    public InteractionResult use(BlockState state, Level level, BlockPos pos, Player player, InteractionHand hand, BlockHitResult hitResult) {
+        ItemStack hand_stack = player.getItemInHand(hand);
+            if (hand_stack.is(ModTags.KNIVES)) {
+                return takeServing(state, level, pos, player);
+            }
+            if (!hand_stack.is(ModTags.KNIVES)){
+                return eat(state, level, pos, player);
+            }
+            return super.use(state, level, pos, player, hand, hitResult);
+    }
+
+    public InteractionResult eat(BlockState state, Level level, BlockPos pos, Player player){
+        int bites = state.getValue(BITES);
+        if (!player.canEat(false)) {return InteractionResult.PASS;}
+        int eatCount = 1;
+        for (int i = 1;bites + i <= 8; i++){
+            if (player.canEat(false)){
+                eatCount = i;
+                player.getFoodData().eat(ImmortalersDelightItems.SCARLET_DEVILS_CAKE_SLICE.get(),
+                        new ItemStack(ImmortalersDelightItems.SCARLET_DEVILS_CAKE_SLICE.get()));
+                level.gameEvent(player, GameEvent.EAT, pos);
+                level.playSound(null, pos, SoundEvents.GENERIC_EAT, SoundSource.PLAYERS, 0.8F, 0.8F);
+            }else {
+                break;
+            }
+        }
+        addFoodPoisonEffect(new ItemStack(ImmortalersDelightItems.SCARLET_DEVILS_CAKE_SLICE.get()),level,player,eatCount);
+        if (bites + eatCount < 9) {
+            setBlock(bites + eatCount,state,level,pos);
+        }else {
+            level.destroyBlock(pos, false);
+            vectorwing.farmersdelight.common.utility.ItemUtils.spawnItemEntity(level,
+                    new ItemStack(Items.BOWL),pos.getX() + 0.5,pos.getY() + 0.5,pos.getZ() + 0.5,0.0,0.0,0.0);
+            level.playSound(null,pos, SoundEvents.WOOL_BREAK, SoundSource.PLAYERS, 0.8F, 0.8F);
+        }
+        return InteractionResult.SUCCESS;
+    }
+    /**
+     * 该方法用于处理实体食用物品后添加对应的药水效果。
+     * 当实体食用某个可食用物品时，会根据物品的属性尝试为实体添加相应的药水效果。
+     *
+     * @param p_21064_ 被食用的物品栈，包含了具体的物品及其数量等信息。
+     * @param p_21065_ 实体所在的游戏世界，用于判断是否为客户端，以及获取随机数生成器。
+     * @param p_21066_ 食用物品的实体，即要添加药水效果的对象。
+     */
+    private void addFoodPoisonEffect(ItemStack p_21064_, Level p_21065_, LivingEntity p_21066_, int timeBuffer) {
+        // 从物品栈中获取具体的物品
+        Item item = p_21064_.getItem();
+        // 检查该物品是否为可食用物品
+        if (item.isEdible()) {
+            // 遍历物品的食物属性中定义的所有药水效果及其概率
+            if (!p_21065_.isClientSide && p_21064_.getFoodProperties(p_21066_) != null) {
+                for (Pair<MobEffectInstance, Float> pair : p_21064_.getFoodProperties(p_21066_).getEffects()) {
+                    // 条件判断：
+                    // 1. 当前不是客户端，因为药水效果的添加通常在服务器端处理，以保证数据一致性。
+                    // 2. 药水效果实例不为空，确保有有效的药水效果。
+                    if (pair.getFirst() != null) {
+                        // 创建一个新的药水效果实例，使用原有的药水效果实例作为模板。
+                        // 然后将该药水效果添加到食用物品的实体上。
+                        if (timeBuffer > 1) {
+                            int time = pair.getFirst().getDuration() * timeBuffer;
+                            int lv = pair.getFirst().getAmplifier();
+                            p_21066_.addEffect(new MobEffectInstance(pair.getFirst().getEffect(),time,lv));
+                            //如果时间倍率大于1，会将持续时间乘以倍率
+                        } else p_21066_.addEffect(new MobEffectInstance(pair.getFirst()));
+                    }
+                }
+                p_21066_.addEffect(new MobEffectInstance(MobEffects.HEAL,1));
+            }
+        }
+    }
+    public InteractionResult takeServing(BlockState state, Level level, BlockPos pos, Player player){
+        int bites = state.getValue(BITES);
+        if (bites < 8){
+            ItemUtils.givePlayerItem(player,new ItemStack(ImmortalersDelightItems.SCARLET_DEVILS_CAKE_SLICE.get()));
+            setBlock(bites + 1,state,level,pos);
+        }else {
+            level.destroyBlock(pos, false);
+            vectorwing.farmersdelight.common.utility.ItemUtils.spawnItemEntity(level,
+                    new ItemStack(Items.BOWL),pos.getX() + 0.5,pos.getY() + 0.5,pos.getZ() + 0.5,0.0,0.0,0.0);
+        }
+        level.playSound(null,pos, SoundEvents.WOOL_BREAK, SoundSource.PLAYERS, 0.8F, 0.8F);
+        return InteractionResult.SUCCESS;
+    }
+
+    public void setBlock(int variate,BlockState state, Level level, BlockPos pos){
+        level.setBlock(pos, state.setValue(BITES, variate), 3);
+    }
+
+    @Override
+    public BlockState getStateForPlacement(BlockPlaceContext pContext) {
+        return this.defaultBlockState().setValue(FACING, pContext.getHorizontalDirection());
+    }
+
+    @Override
+    public BlockState updateShape(BlockState stateIn, Direction facing, BlockState facingState, LevelAccessor level, BlockPos currentPos, BlockPos facingPos) {
+        return facing == Direction.DOWN && !stateIn.canSurvive(level, currentPos) ? Blocks.AIR.defaultBlockState() : super.updateShape(stateIn, facing, facingState, level, currentPos, facingPos);
+    }
+
+    @Override
+    public boolean canSurvive(BlockState state, LevelReader level, BlockPos pos) {
+        return level.getBlockState(pos.below()).isSolid();
+    }
+
+    @Override
+    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
+        builder.add(BITES,FACING);
+    }
+}
Index: src/main/java/com/renyigesai/immortalers_delight/block/SpikeTrapBlock.java
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/block/SpikeTrapBlock.java b/src/main/java/com/renyigesai/immortalers_delight/block/SpikeTrapBlock.java
new file mode 100644
--- /dev/null	
+++ b/src/main/java/com/renyigesai/immortalers_delight/block/SpikeTrapBlock.java	
@@ -0,0 +1,341 @@
+package com.renyigesai.immortalers_delight.block;
+
+import com.google.common.collect.ImmutableMap;
+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import java.util.Map;
+import javax.annotation.Nullable;
+import net.minecraft.Util;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.sounds.SoundEvent;
+import net.minecraft.sounds.SoundEvents;
+import net.minecraft.sounds.SoundSource;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.util.Mth;
+import net.minecraft.util.RandomSource;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.entity.projectile.Projectile;
+import net.minecraft.world.item.context.BlockPlaceContext;
+import net.minecraft.world.level.BlockGetter;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LevelAccessor;
+import net.minecraft.world.level.LevelHeightAccessor;
+import net.minecraft.world.level.LevelReader;
+import net.minecraft.world.level.block.*;
+import net.minecraft.world.level.block.state.BlockBehaviour;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.StateDefinition;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import net.minecraft.world.level.block.state.properties.BooleanProperty;
+import net.minecraft.world.level.block.state.properties.EnumProperty;
+import net.minecraft.world.level.block.state.properties.Tilt;
+import net.minecraft.world.level.gameevent.GameEvent;
+import net.minecraft.world.level.material.FluidState;
+import net.minecraft.world.level.material.Fluids;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.shapes.BooleanOp;
+import net.minecraft.world.phys.shapes.CollisionContext;
+import net.minecraft.world.phys.shapes.Shapes;
+import net.minecraft.world.phys.shapes.VoxelShape;
+
+// 大型垂滴叶方块类，继承自HorizontalDirectionalBlock，实现了BonemealableBlock和SimpleWaterloggedBlock接口
+public class SpikeTrapBlock extends HorizontalDirectionalBlock implements BonemealableBlock, SimpleWaterloggedBlock {
+    // 定义一个布尔属性，表示方块是否被水logged（即是否被水填充）
+    private static final BooleanProperty WATERLOGGED = BlockStateProperties.WATERLOGGED;
+    // 定义一个枚举属性，表示方块的倾斜状态
+    private static final EnumProperty<Tilt> TILT = BlockStateProperties.TILT;
+    // 定义一个常量，表示不进行方块刻（tick）的标识
+    private static final int NO_TICK = -1;
+    // 定义一个映射，存储不同倾斜状态到下一个倾斜状态的延迟时间（以方块刻为单位）
+    private static final Object2IntMap<Tilt> DELAY_UNTIL_NEXT_TILT_STATE = Util.make(new Object2IntArrayMap<>(), (p_152305_) -> {
+        p_152305_.defaultReturnValue(-1);
+        p_152305_.put(Tilt.UNSTABLE, 10);
+        p_152305_.put(Tilt.PARTIAL, 10);
+        p_152305_.put(Tilt.FULL, 100);
+    });
+    // 定义最大生成高度的常量
+    private static final int MAX_GEN_HEIGHT = 5;
+    // 定义茎的宽度常量
+    private static final int STEM_WIDTH = 6;
+    // 定义实体检测的最小Y坐标常量
+    private static final int ENTITY_DETECTION_MIN_Y = 11;
+    // 定义最低的叶子顶部Y坐标常量
+    private static final int LOWEST_LEAF_TOP = 13;
+    protected static final VoxelShape NORTH_SHAPE = Block.box(5.0D, 0.0D, 9.0D, 11.0D, 16.0D, 15.0D);
+    protected static final VoxelShape SOUTH_SHAPE = Block.box(5.0D, 0.0D, 1.0D, 11.0D, 16.0D, 7.0D);
+    protected static final VoxelShape EAST_SHAPE = Block.box(1.0D, 0.0D, 5.0D, 7.0D, 16.0D, 11.0D);
+    protected static final VoxelShape WEST_SHAPE = Block.box(9.0D, 0.0D, 5.0D, 15.0D, 16.0D, 11.0D);
+    // 定义不同倾斜状态对应的叶子形状的映射
+    private static final Map<Tilt, VoxelShape> LEAF_SHAPES = ImmutableMap.of(
+        Tilt.NONE, Block.box(0.0D, 11.0D, 0.0D, 16.0D, 15.0D, 16.0D),
+        Tilt.UNSTABLE, Block.box(0.0D, 11.0D, 0.0D, 16.0D, 15.0D, 16.0D), 
+        Tilt.PARTIAL, Block.box(0.0D, 11.0D, 0.0D, 16.0D, 13.0D, 16.0D), 
+        Tilt.FULL, Shapes.empty());
+    // 定义茎的切片形状
+    private static final VoxelShape STEM_SLICER = Block.box(0.0D, 13.0D, 0.0D, 16.0D, 16.0D, 16.0D);
+    // 定义不同方向对应的茎的形状的映射
+    private static final Map<Direction, VoxelShape> STEM_SHAPES = ImmutableMap.of(
+            Direction.NORTH, Shapes.joinUnoptimized(SpikeTrapBlock.NORTH_SHAPE, STEM_SLICER, BooleanOp.ONLY_FIRST),
+            Direction.SOUTH, Shapes.joinUnoptimized(SpikeTrapBlock.SOUTH_SHAPE, STEM_SLICER, BooleanOp.ONLY_FIRST),
+            Direction.EAST, Shapes.joinUnoptimized(SpikeTrapBlock.EAST_SHAPE, STEM_SLICER, BooleanOp.ONLY_FIRST),
+            Direction.WEST, Shapes.joinUnoptimized(SpikeTrapBlock.WEST_SHAPE, STEM_SLICER, BooleanOp.ONLY_FIRST)
+    );
+    // 定义一个缓存，存储每个方块状态对应的形状
+    private final Map<BlockState, VoxelShape> shapesCache;
+
+    // 构造函数，初始化方块的属性和默认状态，并缓存形状
+    public SpikeTrapBlock(Properties pProperties) {
+        super(pProperties);
+        // 注册默认状态，设置初始的水logged为false，朝向为北方，倾斜状态为NONE
+        this.registerDefaultState(this.stateDefinition.any().setValue(WATERLOGGED, Boolean.valueOf(false)).setValue(FACING, Direction.NORTH).setValue(TILT, Tilt.NONE));
+        // 计算并缓存每个状态的形状
+        this.shapesCache = this.getShapeForEachState(SpikeTrapBlock::calculateShape);
+    }
+
+    // 计算方块形状的静态方法，根据倾斜状态和朝向返回对应的形状
+    private static VoxelShape calculateShape(BlockState p_152318_) {
+        return Shapes.or(LEAF_SHAPES.get(p_152318_.getValue(TILT)), STEM_SHAPES.get(p_152318_.getValue(FACING)));
+    }
+
+    // 以随机高度放置大型垂滴叶的静态方法
+    public static void placeWithRandomHeight(LevelAccessor pLevel, RandomSource pRandom, BlockPos pPos, Direction pDirection) {
+        // 生成一个在2到5之间的随机高度
+        int i = Mth.nextInt(pRandom, 2, 5);
+        // 创建一个可变的方块位置对象
+        BlockPos.MutableBlockPos blockpos$mutableblockpos = pPos.mutable();
+        int j = 0;
+
+        // 检查并找到可以放置的位置，直到达到最大高度或者不能放置为止
+        while(j < i && canPlaceAt(pLevel, blockpos$mutableblockpos, pLevel.getBlockState(blockpos$mutableblockpos))) {
+            ++j;
+            blockpos$mutableblockpos.move(Direction.UP);
+        }
+
+        int k = pPos.getY() + j - 1;
+        blockpos$mutableblockpos.setY(pPos.getY());
+
+        // 放置茎方块
+        while(blockpos$mutableblockpos.getY() < k) {
+            SpikeTrapBlock.place(pLevel, blockpos$mutableblockpos, pLevel.getFluidState(blockpos$mutableblockpos), pDirection);
+            blockpos$mutableblockpos.move(Direction.UP);
+        }
+
+        // 放置叶子方块
+        place(pLevel, blockpos$mutableblockpos, pLevel.getFluidState(blockpos$mutableblockpos), pDirection);
+    }
+
+    // 判断方块是否可以被替换的静态方法
+    private static boolean canReplace(BlockState pState) {
+        return pState.isAir() || pState.is(Blocks.WATER) || pState.is(Blocks.SMALL_DRIPLEAF);
+    }
+
+    // 判断是否可以在指定位置放置方块的静态方法
+    protected static boolean canPlaceAt(LevelHeightAccessor pLevel, BlockPos pPos, BlockState pState) {
+        return !pLevel.isOutsideBuildHeight(pPos) && canReplace(pState);
+    }
+
+    // 在指定位置放置方块的静态方法
+    protected static boolean place(LevelAccessor pLevel, BlockPos pPos, FluidState pFluidState, Direction pDirection) {
+        // 创建方块状态，设置水logged和朝向
+        BlockState blockstate = Blocks.BIG_DRIPLEAF.defaultBlockState().setValue(WATERLOGGED, Boolean.valueOf(pFluidState.isSourceOfType(Fluids.WATER))).setValue(FACING, pDirection);
+        // 设置方块状态到指定位置
+        return pLevel.setBlock(pPos, blockstate, 3);
+    }
+
+    // 当有投射物击中时的处理方法
+    public void onProjectileHit(Level pLevel, BlockState pState, BlockHitResult pHit, Projectile pProjectile) {
+        // 设置倾斜状态为FULL，并安排下一次方块刻和播放声音
+        this.setTiltAndScheduleTick(pState, pLevel, pHit.getBlockPos(), Tilt.FULL, SoundEvents.BIG_DRIPLEAF_TILT_DOWN);
+    }
+
+    // 获取方块的流体状态的方法
+    public FluidState getFluidState(BlockState pState) {
+        // 如果方块是水logged的，返回水的源流体状态，否则返回父类的流体状态
+        return pState.getValue(WATERLOGGED) ? Fluids.WATER.getSource(false) : super.getFluidState(pState);
+    }
+
+    // 判断方块是否可以在指定位置生存的方法
+    public boolean canSurvive(BlockState pState, LevelReader pLevel, BlockPos pPos) {
+        // 获取下方方块的位置和状态
+        BlockPos blockpos = pPos.below();
+        BlockState blockstate = pLevel.getBlockState(blockpos);
+        // 判断下方方块是否是大型垂滴叶、大型垂滴叶茎或者可放置大型垂滴叶的方块
+        //return blockstate.is(this) || blockstate.is(Blocks.BIG_DRIPLEAF_STEM) || blockstate.is(BlockTags.BIG_DRIPLEAF_PLACEABLE);
+        return true;
+    }
+
+    // 更新方块状态的方法，根据邻居方块的状态和方向返回新的状态
+    public BlockState updateShape(BlockState pState, Direction pDirection, BlockState pNeighborState, LevelAccessor pLevel, BlockPos pPos, BlockPos pNeighborPos) {
+        // 如果下方方块不能支撑当前方块，返回空气方块状态
+        if (pDirection == Direction.DOWN && !pState.canSurvive(pLevel, pPos)) {
+            return Blocks.AIR.defaultBlockState();
+        } else {
+            // 如果方块是水logged的，安排水的方块刻
+            if (pState.getValue(WATERLOGGED)) {
+                pLevel.scheduleTick(pPos, Fluids.WATER, Fluids.WATER.getTickDelay(pLevel));
+            }
+
+            // 如果上方方块是大型垂滴叶，返回大型垂滴叶茎的状态
+            return pDirection == Direction.UP && pNeighborState.is(this) ? Blocks.BIG_DRIPLEAF_STEM.withPropertiesOf(pState) : super.updateShape(pState, pDirection, pNeighborState, pLevel, pPos, pNeighborPos);
+        }
+    }
+
+    // 判断是否可以对当前方块使用骨粉的方法
+    public boolean isValidBonemealTarget(LevelReader pLevel, BlockPos pPos, BlockState pState, boolean pIsClient) {
+        // 获取上方方块的状态
+        BlockState blockstate = pLevel.getBlockState(pPos.above());
+        // 判断上方方块是否可以被替换
+        return canReplace(blockstate);
+    }
+
+    // 判断使用骨粉是否成功的方法，这里总是返回true
+    public boolean isBonemealSuccess(Level pLevel, RandomSource pRandom, BlockPos pPos, BlockState pState) {
+        return true;
+    }
+
+    // 使用骨粉后的处理方法，在上方放置茎和叶子方块
+    public void performBonemeal(ServerLevel pLevel, RandomSource pRandom, BlockPos pPos, BlockState pState) {
+        // 获取上方方块的位置和状态
+        BlockPos blockpos = pPos.above();
+        BlockState blockstate = pLevel.getBlockState(blockpos);
+        // 如果上方可以放置方块
+        if (canPlaceAt(pLevel, blockpos, blockstate)) {
+            // 获取当前方块的朝向
+            Direction direction = pState.getValue(FACING);
+            // 放置茎方块
+            SpikeTrapBlock.place(pLevel, pPos, pState.getFluidState(), direction);
+            // 放置叶子方块
+            place(pLevel, blockpos, blockstate.getFluidState(), direction);
+        }
+
+    }
+
+    // 当有实体进入方块时的处理方法
+    public void entityInside(BlockState pState, Level pLevel, BlockPos pPos, Entity pEntity) {
+        // 仅在服务端处理
+        if (!pLevel.isClientSide) {
+            // 如果当前倾斜状态为NONE，且实体可以使方块倾斜，并且没有邻居信号
+            if (pState.getValue(TILT) == Tilt.NONE && canEntityTilt(pPos, pEntity) && !pLevel.hasNeighborSignal(pPos)) {
+                // 设置倾斜状态为UNSTABLE，并安排下一次方块刻，不播放声音
+                this.setTiltAndScheduleTick(pState, pLevel, pPos, Tilt.UNSTABLE, (SoundEvent)null);
+            }
+
+        }
+    }
+
+    // 方块刻的处理方法
+    public void tick(BlockState pState, ServerLevel pLevel, BlockPos pPos, RandomSource pRandom) {
+        // 如果有邻居信号，重置倾斜状态
+        if (pLevel.hasNeighborSignal(pPos)) {
+            resetTilt(pState, pLevel, pPos);
+        } else {
+            // 获取当前倾斜状态
+            Tilt tilt = pState.getValue(TILT);
+            // 根据不同的倾斜状态进行处理
+            if (tilt == Tilt.UNSTABLE) {
+                this.setTiltAndScheduleTick(pState, pLevel, pPos, Tilt.PARTIAL, SoundEvents.BIG_DRIPLEAF_TILT_DOWN);
+            } else if (tilt == Tilt.PARTIAL) {
+                this.setTiltAndScheduleTick(pState, pLevel, pPos, Tilt.FULL, SoundEvents.BIG_DRIPLEAF_TILT_DOWN);
+            } else if (tilt == Tilt.FULL) {
+                resetTilt(pState, pLevel, pPos);
+            }
+
+        }
+    }
+
+    // 当邻居方块改变时的处理方法
+    public void neighborChanged(BlockState pState, Level pLevel, BlockPos pPos, Block pNeighborBlock, BlockPos pNeighborPos, boolean pMovedByPiston) {
+        // 如果有邻居信号，重置倾斜状态
+        if (pLevel.hasNeighborSignal(pPos)) {
+            resetTilt(pState, pLevel, pPos);
+        }
+
+    }
+
+    // 播放倾斜声音的静态方法
+    private static void playTiltSound(Level pLevel, BlockPos pPos, SoundEvent pSound) {
+        // 生成一个在0.8到1.2之间的随机音量
+        float f = Mth.randomBetween(pLevel.random, 0.8F, 1.2F);
+        // 播放声音
+        pLevel.playSound((Player)null, pPos, pSound, SoundSource.BLOCKS, 1.0F, f);
+    }
+
+    // 判断实体是否可以使方块倾斜的静态方法
+    private static boolean canEntityTilt(BlockPos pPos, Entity pEntity) {
+        return pEntity.onGround() && pEntity.position().y > (double)((float)pPos.getY() + 0.6875F);
+    }
+
+    // 设置倾斜状态并安排下一次方块刻的方法
+    private void setTiltAndScheduleTick(BlockState pState, Level pLevel, BlockPos pPos, Tilt pTilt, @Nullable SoundEvent pSound) {
+        // 设置倾斜状态
+        setTilt(pState, pLevel, pPos, pTilt);
+        // 如果有声音，播放声音
+        if (pSound != null) {
+            playTiltSound(pLevel, pPos, pSound);
+        }
+
+        // 获取到下一个倾斜状态的延迟时间
+        int i = DELAY_UNTIL_NEXT_TILT_STATE.getInt(pTilt);
+        // 如果延迟时间不为-1，安排方块刻
+        if (i != -1) {
+            pLevel.scheduleTick(pPos, this, i);
+        }
+
+    }
+
+    // 重置倾斜状态的静态方法
+    private static void resetTilt(BlockState pState, Level pLevel, BlockPos pPos) {
+        // 设置倾斜状态为NONE
+        setTilt(pState, pLevel, pPos, Tilt.NONE);
+        // 如果当前倾斜状态不是NONE，播放倾斜上升的声音
+        if (pState.getValue(TILT) != Tilt.NONE) {
+            playTiltSound(pLevel, pPos, SoundEvents.BIG_DRIPLEAF_TILT_UP);
+        }
+
+    }
+    // 设置倾斜状态的静态方法
+    private static void setTilt(BlockState pState, Level pLevel, BlockPos pPos, Tilt pTilt) {
+        // 获取当前方块状态的倾斜状态
+        Tilt tilt = pState.getValue(TILT);
+        // 更新方块状态为新的倾斜状态
+        pLevel.setBlock(pPos, pState.setValue(TILT, pTilt), 2);
+        // 如果新的倾斜状态会引起振动且与旧的倾斜状态不同
+        if (pTilt.causesVibration() && pTilt != tilt) {
+            // 触发方块改变的游戏事件
+            pLevel.gameEvent((Entity)null, GameEvent.BLOCK_CHANGE, pPos);
+        }
+    }
+
+    // 获取方块的碰撞形状的方法
+    public VoxelShape getCollisionShape(BlockState pState, BlockGetter pLevel, BlockPos pPos, CollisionContext pContext) {
+        // 根据当前方块状态的倾斜状态从LEAF_SHAPES中获取对应的形状
+        return LEAF_SHAPES.get(pState.getValue(TILT));
+    }
+
+    // 获取方块的形状的方法
+    public VoxelShape getShape(BlockState pState, BlockGetter pLevel, BlockPos pPos, CollisionContext pContext) {
+        // 从形状缓存中获取当前方块状态对应的形状
+        return this.shapesCache.get(pState);
+    }
+
+    // 获取放置方块时的状态的方法
+    public BlockState getStateForPlacement(BlockPlaceContext pContext) {
+        // 获取点击位置下方方块的状态
+        BlockState blockstate = pContext.getLevel().getBlockState(pContext.getClickedPos().below());
+        // 获取点击位置的流体状态
+        FluidState fluidstate = pContext.getLevel().getFluidState(pContext.getClickedPos());
+        // 判断下方方块是否是大型垂滴叶或大型垂滴叶茎
+        boolean flag = blockstate.is(Blocks.BIG_DRIPLEAF) || blockstate.is(Blocks.BIG_DRIPLEAF_STEM);
+        // 创建方块状态，设置水logged和朝向
+        return this.defaultBlockState().setValue(WATERLOGGED, Boolean.valueOf(fluidstate.isSourceOfType(Fluids.WATER))).setValue(FACING, flag ? blockstate.getValue(FACING) : pContext.getHorizontalDirection().getOpposite());
+    }
+
+    // 创建方块状态定义的方法，用于添加方块的属性
+    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> pBuilder) {
+        // 添加水logged、朝向和倾斜状态属性
+        pBuilder.add(WATERLOGGED, FACING, TILT);
+    }
+}
\ No newline at end of file
Index: src/main/java/com/renyigesai/immortalers_delight/potion/CulturalLegacyPotionEffect.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.potion;\r\n\r\nimport com.renyigesai.immortalers_delight.block.CulturalLegacyEffectToolBlock;\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightBlocks;\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightFoodProperties;\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.world.effect.MobEffectInstance;\r\nimport net.minecraft.world.effect.MobEffects;\r\nimport net.minecraft.world.entity.Entity;\r\nimport net.minecraft.world.entity.LivingEntity;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraft.world.level.block.Blocks;\r\nimport net.minecraft.world.level.block.state.BlockState;\r\nimport net.minecraftforge.event.enchanting.EnchantmentLevelSetEvent;\r\nimport net.minecraftforge.event.entity.living.LivingEntityUseItemEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\n@Mod.EventBusSubscriber\r\npublic class CulturalLegacyPotionEffect {\r\n\r\n    @SubscribeEvent\r\n    public static void onUseItemFinish(LivingEntityUseItemEvent.Finish event) {\r\n        if (event != null && event.getEntity() != null) {\r\n            ItemStack stack = event.getItem();\r\n            Entity entity = event.getEntity();\r\n            if (entity instanceof LivingEntity livingEntity) {\r\n                if (stack.getItem().isEdible()) {\r\n                    if (stack.getFoodProperties(livingEntity) == ImmortalersDelightFoodProperties.PUFFERFISH_ROLL) {\r\n                        livingEntity.addEffect(new MobEffectInstance(MobEffects.SATURATION, 1));\r\n                    }\r\n                    if (stack.getFoodProperties(livingEntity) == ImmortalersDelightFoodProperties.BOWL_OF_STEWED_ROTTEN_MEAT_IN_CLAY_POT) {\r\n                        livingEntity.addEffect(new MobEffectInstance(MobEffects.HEAL, 1));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n//    @SubscribeEvent\r\n//    public static void onEnchantmentLevelSet(EnchantmentLevelSetEvent event) {\r\n//        if (event == null || event.isCanceled()) {\r\n//            return;\r\n//        }\r\n//\r\n//        // 获取世界和附魔台的位置\r\n//        Level level = event.getLevel();\r\n//        BlockPos pos = event.getPos();\r\n//\r\n//        // 以附魔台为中心，检查 5*5 范围内的方块\r\n//        int goldBlockCount = maxAgeToolBlocksInRange(level, pos, 2); // 2 表示从中心到边缘的距离\r\n//\r\n//        // 根据金块数量计算新的附魔等级\r\n//        int newLevel = calculateNewLevel(event.getEnchantLevel(), goldBlockCount);\r\n//\r\n//        // 设置新的附魔等级\r\n//        event.setEnchantLevel(newLevel);\r\n//    }\r\n//\r\n//    /**\r\n//     * 计算指定范围内的指定方块数量\r\n//     * @param level 世界\r\n//     * @param centerPos 中心位置\r\n//     * @param range 范围（从中心到边缘的距离）\r\n//     * @return 金块数量\r\n//     */\r\n//    private static int maxAgeToolBlocksInRange(Level level, BlockPos centerPos, int range) {\r\n//        int maxAge = 0;\r\n//        for (int x = -range; x <= range; x++) {\r\n//            for (int y = -range; y <= range; y++) {\r\n//                for (int z = -range; z <= range; z++) {\r\n//                    BlockPos checkPos = centerPos.offset(x, y, z);\r\n//                    if (level.getBlockState(checkPos).getBlock() instanceof CulturalLegacyEffectToolBlock block) {\r\n//\r\n//                        maxAge++;\r\n//                    }\r\n//                }\r\n//            }\r\n//        }\r\n//        return maxAge;\r\n//    }\r\n//\r\n//    /**\r\n//     * 根据金块数量计算新的附魔等级\r\n//     * @param originalLevel 原始附魔等级\r\n//     * @param goldBlockCount 金块数量\r\n//     * @return 新的附魔等级\r\n//     */\r\n//    private static int calculateNewLevel(int originalLevel, int goldBlockCount) {\r\n//        // 简单示例：每有一个金块，附魔等级降低 1 级，但不低于 0\r\n//        int newLevel = originalLevel - goldBlockCount;\r\n//        return Math.max(0, newLevel);\r\n//    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/potion/CulturalLegacyPotionEffect.java b/src/main/java/com/renyigesai/immortalers_delight/potion/CulturalLegacyPotionEffect.java
--- a/src/main/java/com/renyigesai/immortalers_delight/potion/CulturalLegacyPotionEffect.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/potion/CulturalLegacyPotionEffect.java	
@@ -26,14 +26,24 @@
         if (event != null && event.getEntity() != null) {
             ItemStack stack = event.getItem();
             Entity entity = event.getEntity();
-            if (entity instanceof LivingEntity livingEntity) {
+            if (entity instanceof LivingEntity livingEntity && !livingEntity.level().isClientSide()) {
                 if (stack.getItem().isEdible()) {
                     if (stack.getFoodProperties(livingEntity) == ImmortalersDelightFoodProperties.PUFFERFISH_ROLL) {
                         livingEntity.addEffect(new MobEffectInstance(MobEffects.SATURATION, 1));
                     }
-                    if (stack.getFoodProperties(livingEntity) == ImmortalersDelightFoodProperties.BOWL_OF_STEWED_ROTTEN_MEAT_IN_CLAY_POT) {
+                    if (
+                            stack.getFoodProperties(livingEntity) == ImmortalersDelightFoodProperties.BOWL_OF_STEWED_ROTTEN_MEAT_IN_CLAY_POT) {
                         livingEntity.addEffect(new MobEffectInstance(MobEffects.HEAL, 1));
                     }
+                    if (stack.getFoodProperties(livingEntity) == ImmortalersDelightFoodProperties.SCARLET_DEVILS_CAKE_SLICE) {
+                        livingEntity.heal(2);
+                    }
+                    if (stack.getFoodProperties(livingEntity) == ImmortalersDelightFoodProperties.RED_STUFFED_BUN) {
+                        if (livingEntity.getRandom().nextInt(3) == 0) {
+                            livingEntity.addEffect(new MobEffectInstance(MobEffects.DAMAGE_BOOST, 3000));
+                            livingEntity.addEffect(new MobEffectInstance(MobEffects.LUCK, 600));
+                        }
+                    }
                 }
             }
         }
Index: src/main/java/com/renyigesai/immortalers_delight/util/task/ScheduledExecuteTask.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.util.task;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport net.minecraftforge.common.MinecraftForge;\r\nimport net.minecraftforge.event.TickEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\nimport javax.annotation.Nonnull;\r\nimport java.util.HashMap;\r\nimport java.util.Random;\r\n\r\n@Mod.EventBusSubscriber\r\npublic abstract class ScheduledExecuteTask implements Runnable {\r\n    /*\r\n    这是一个计划任务，在服务端tick执行自身tick\r\n    用于实际执行特殊状态效果的功能\r\n     */\r\n    private final static HashMap<Integer, ScheduledExecuteTask> TASK_LIST = new HashMap<Integer, ScheduledExecuteTask>();\r\n    private volatile boolean isRemoved = false;\r\n    protected final int TASKID;\r\n    private int delay;\r\n    protected boolean cycle = delay >= 0;;\r\n    protected final int INITIALDELAY;\r\n    protected final int DELAY;\r\n    protected boolean start;\r\n    protected boolean first;\r\n    protected int tick;\r\n\r\n    public ScheduledExecuteTask() {\r\n        this(0);\r\n    }\r\n\r\n    public ScheduledExecuteTask(int initialDelay) {\r\n        this(initialDelay, -1);\r\n    }\r\n\r\n    public ScheduledExecuteTask(int initialDelay, int delay) {\r\n        this.TASKID = new Random().nextInt(Short.MAX_VALUE);\r\n        this.first = true;\r\n        this.delay = delay;\r\n        this.tick = 0;\r\n        this.INITIALDELAY = initialDelay;\r\n        this.DELAY = delay;\r\n    }\r\n\r\n    public ScheduledExecuteTask(int initialDelay, int delay, int taskID) {\r\n        this.TASKID = taskID;\r\n        this.first = true;\r\n        this.delay = delay;\r\n        this.tick = 0;\r\n        this.INITIALDELAY = initialDelay;\r\n        this.DELAY = delay;\r\n    }\r\n\r\n    public synchronized static boolean cancel(int taskID) {\r\n        if (TASK_LIST.containsKey(taskID)) {\r\n            TASK_LIST.get(taskID).cancel();\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public static HashMap<Integer, ScheduledExecuteTask> getTaskMap() {return TASK_LIST;}\r\n    public static ScheduledExecuteTask getTaskFromID(Integer id) {return TASK_LIST.get(id);}\r\n\r\n    @SubscribeEvent\r\n    public void onTick(@Nonnull TickEvent.ServerTickEvent evt) {\r\n        if (evt.phase.equals(TickEvent.Phase.START)) {\r\n            tick++;\r\n            if (first) {\r\n                if (tick >= INITIALDELAY) {\r\n                    first = false;\r\n                    tick = 0;\r\n                    this.run();\r\n                }\r\n            } else {\r\n                if (delay >= 0) {\r\n                    if (tick >= DELAY) {\r\n                        tick = 0;\r\n                        this.run();\r\n                    }\r\n                } else {\r\n                    ImmortalersDelightMod.LOGGER.info(\"孩子们，我已经超时了，但我还在跑\");\r\n                    cancel();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public int getTaskID() {\r\n        return TASKID;\r\n    }\r\n\r\n    public synchronized void start() {\r\n        if (!start) {\r\n            start = true;\r\n            TASK_LIST.put(getTaskID(), this);\r\n            MinecraftForge.EVENT_BUS.register(this);\r\n        }\r\n    }\r\n\r\n    public synchronized void cancel() {\r\n        start = false;\r\n        TASK_LIST.remove(this.getTaskID());\r\n        ImmortalersDelightMod.LOGGER.info(\"我是Task，孩子们我被取消了\");\r\n        MinecraftForge.EVENT_BUS.unregister(this);\r\n    }\r\n    public void stop() {\r\n        delay = -1;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/util/task/ScheduledExecuteTask.java b/src/main/java/com/renyigesai/immortalers_delight/util/task/ScheduledExecuteTask.java
--- a/src/main/java/com/renyigesai/immortalers_delight/util/task/ScheduledExecuteTask.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/util/task/ScheduledExecuteTask.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.util.task;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import net.minecraftforge.common.MinecraftForge;
 import net.minecraftforge.event.TickEvent;
 import net.minecraftforge.eventbus.api.SubscribeEvent;
Index: src/main/java/com/renyigesai/immortalers_delight/util/task/TimekeepingTask.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.util.task;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.util.task.ScheduledExecuteTask;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport net.minecraftforge.event.TickEvent;\r\nimport net.minecraftforge.event.level.LevelEvent;\r\nimport net.minecraftforge.eventbus.api.EventPriority;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\nimport javax.annotation.Nonnull;\r\n\r\n@Mod.EventBusSubscriber\r\npublic class TimekeepingTask {\r\n    private static Long ImmortalTickTime = 0L;\r\n    public static Long getImmortalTickTime() {return ImmortalTickTime;}\r\n    @SubscribeEvent(priority = EventPriority.HIGH)\r\n    public static void onWorldLoad(LevelEvent.Load event) {\r\n        if (event.getLevel() instanceof ServerLevel serverLevel) {\r\n            if (ImmortalTickTime == 0) ImmortalTickTime = System.currentTimeMillis();\r\n\r\n        }\r\n    }\r\n    @SubscribeEvent\r\n    public static void onTick(@Nonnull TickEvent.ServerTickEvent evt) {\r\n        if (evt.phase.equals(TickEvent.Phase.START)) {\r\n            run();\r\n        }\r\n    }\r\n    private static void run() {\r\n        ImmortalTickTime = ImmortalTickTime + 50L;\r\n        //ImmortalersDelightMod.LOGGER.info(\"现在的TICK时间是：\" + ImmortalTickTime);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/util/task/TimekeepingTask.java b/src/main/java/com/renyigesai/immortalers_delight/util/task/TimekeepingTask.java
--- a/src/main/java/com/renyigesai/immortalers_delight/util/task/TimekeepingTask.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/util/task/TimekeepingTask.java	
@@ -1,7 +1,5 @@
 package com.renyigesai.immortalers_delight.util.task;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
-import com.renyigesai.immortalers_delight.util.task.ScheduledExecuteTask;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraftforge.event.TickEvent;
 import net.minecraftforge.event.level.LevelEvent;
Index: src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightMobEffect.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.init;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.potion.*;\r\nimport net.minecraft.world.effect.MobEffect;\r\nimport net.minecraft.world.entity.ai.attributes.Attribute;\r\nimport net.minecraft.world.entity.ai.attributes.AttributeModifier;\r\nimport net.minecraft.world.entity.ai.attributes.Attributes;\r\nimport net.minecraftforge.registries.DeferredRegister;\r\nimport net.minecraftforge.registries.ForgeRegistries;\r\nimport net.minecraftforge.registries.RegistryObject;\r\n\r\npublic class ImmortalersDelightMobEffect {\r\n\r\n    public static final DeferredRegister<MobEffect> REGISTRY = DeferredRegister.create(ForgeRegistries.MOB_EFFECTS, ImmortalersDelightMod.MODID);\r\n    public static final RegistryObject<MobEffect> INCANDESCENCE = REGISTRY.register(\"incandescence\", IncandescenceMobEffect::new);\r\n\r\n\r\n    public static final RegistryObject<MobEffect> WEAK_POISON = REGISTRY.register(\"weak_poison\", DamageOnTimeMobEffect::new);\r\n    public static final RegistryObject<MobEffect> WEAK_WITHER = REGISTRY.register(\"weak_wither\", DamageOnTimeMobEffect::new);\r\n    public static final RegistryObject<MobEffect> RELIEVE_POISON = REGISTRY.register(\"relieve_poison\", RelievePotionEffectMobEffect::new);\r\n    public static final RegistryObject<MobEffect> RESISTANCE_TO_UNDEAD = REGISTRY.register(\"resistance_to_undead\", DamageResistMobEffect::new);\r\n    public static final RegistryObject<MobEffect> RESISTANCE_TO_ARTHROPOD = REGISTRY.register(\"resistance_to_arthropod\", DamageResistMobEffect::new);\r\n    public static final RegistryObject<MobEffect> RESISTANCE_TO_ABYSSAL = REGISTRY.register(\"resistance_to_abyssal\", DamageResistMobEffect::new);\r\n    public static final RegistryObject<MobEffect> RESISTANCE_TO_ILLAGER = REGISTRY.register(\"resistance_to_illager\", DamageResistMobEffect::new);\r\n    public static final RegistryObject<MobEffect> RESISTANCE_TO_SURROUNDINGS = REGISTRY.register(\"resistance_to_surroundings\", DamageResistMobEffect::new);\r\n//    public static final RegistryObject<MobEffect> GREAT_MISERY = REGISTRY.register(\"great_misery\", RelievePotionEffectMobEffect::new);\r\n    public static final RegistryObject<MobEffect> MAGICAL_REVERSE = REGISTRY.register(\"magical_reverse\", IncandescenceMobEffect::new);\r\n\r\n    public static final RegistryObject<MobEffect> GAS_POISON = REGISTRY.register(\"gas_poison\", IncandescenceMobEffect::new);\r\n    public static final RegistryObject<MobEffect> INEBRIATED = REGISTRY.register(\"inebriated\", IncandescenceMobEffect::new);\r\n    public static final RegistryObject<MobEffect> LINGERING_FLAVOR = REGISTRY.register(\"lingering_flavor\", IncandescenceMobEffect::new);\r\n    public static final RegistryObject<MobEffect> KEEP_A_FAST = REGISTRY.register(\"keep_a_fast\",KeepFastMobEffect::new);\r\n    public static final RegistryObject<MobEffect> BURN_THE_BOATS = REGISTRY.register(\"burn_the_boats\", BurnTheBoatsMobEffect::new);\r\n    public static final RegistryObject<MobEffect> CULTURAL_LEGACY = REGISTRY.register(\"cultural_legacy\", CulturalLegacyMobEffect::new);\r\n    public static final RegistryObject<MobEffect> WARM_CURRENT_SURGES = REGISTRY.register(\"warm_current_surges\",()-> new WarmCurrentSurgesMobEffect().addAttributeModifier(Attributes.ATTACK_DAMAGE,\"7aadc50d-fcf7-43f6-a1c6-af5f56246aa7\",3.0, AttributeModifier.Operation.ADDITION));\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightMobEffect.java b/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightMobEffect.java
--- a/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightMobEffect.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightMobEffect.java	
@@ -1,9 +1,8 @@
 package com.renyigesai.immortalers_delight.init;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.potion.*;
 import net.minecraft.world.effect.MobEffect;
-import net.minecraft.world.entity.ai.attributes.Attribute;
 import net.minecraft.world.entity.ai.attributes.AttributeModifier;
 import net.minecraft.world.entity.ai.attributes.Attributes;
 import net.minecraftforge.registries.DeferredRegister;
Index: src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightGroup.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.init;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport net.minecraft.core.registries.Registries;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.world.item.CreativeModeTab;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraftforge.registries.DeferredRegister;\r\nimport net.minecraftforge.registries.RegistryObject;\r\n\r\npublic class ImmortalersDelightGroup {\r\n    public static final DeferredRegister<CreativeModeTab> CREATIVE_TABS = DeferredRegister.create(Registries.CREATIVE_MODE_TAB, ImmortalersDelightMod.MODID);\r\n\r\n    public static final RegistryObject<CreativeModeTab> TAB_FARMERS_DELIGHT = CREATIVE_TABS.register(ImmortalersDelightMod.MODID,\r\n            () -> CreativeModeTab.builder()\r\n                    .title(Component.translatable(\"creativetab_immortalers_delight_tab\"))\r\n                    .icon(() -> new ItemStack(ImmortalersDelightItems.EVOLUTCORN.get()))\r\n                    .displayItems((parameters, output) -> ImmortalersDelightItems.CREATIVE_TAB_ITEMS.forEach((item) -> output.accept(item.get())))\r\n                    .build());\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightGroup.java b/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightGroup.java
--- a/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightGroup.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightGroup.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.init;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.network.chat.Component;
 import net.minecraft.world.item.CreativeModeTab;
Index: src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightParticleTypes.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.init;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport net.minecraft.core.particles.ParticleType;\r\nimport net.minecraft.core.particles.SimpleParticleType;\r\nimport net.minecraftforge.registries.DeferredRegister;\r\nimport net.minecraftforge.registries.ForgeRegistries;\r\nimport net.minecraftforge.registries.RegistryObject;\r\n\r\npublic class ImmortalersDelightParticleTypes {\r\n    public static final DeferredRegister<ParticleType<?>> REGISTRY = DeferredRegister.create(ForgeRegistries.PARTICLE_TYPES, ImmortalersDelightMod.MODID);\r\n    public static final RegistryObject<SimpleParticleType> KWAT = REGISTRY.register(\"kwat\", () -> new SimpleParticleType(false));\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightParticleTypes.java b/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightParticleTypes.java
--- a/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightParticleTypes.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightParticleTypes.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.init;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import net.minecraft.core.particles.ParticleType;
 import net.minecraft.core.particles.SimpleParticleType;
 import net.minecraftforge.registries.DeferredRegister;
Index: src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightFoodProperties.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.init;\r\n\r\nimport net.minecraft.world.effect.MobEffect;\r\nimport net.minecraft.world.effect.MobEffectInstance;\r\nimport net.minecraft.world.effect.MobEffects;\r\nimport net.minecraft.world.food.FoodProperties;\r\nimport vectorwing.farmersdelight.common.registry.ModEffects;\r\n\r\npublic class ImmortalersDelightFoodProperties {\r\n\r\n    public static final FoodProperties BOWL_OF_MILLENIAN_BAMBOO = new FoodProperties.Builder().nutrition(6)\r\n            .saturationMod(0.65f)\r\n            .effect(()-> new MobEffectInstance(ModEffects.COMFORT.get(),1200,0),1.0F)\r\n            .effect(()-> new MobEffectInstance(ModEffects.NOURISHMENT.get(),1200,0),1.0F)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.CULTURAL_LEGACY.get(),6000,0),1.0F)\r\n            .build();\r\n\r\n    public static final FoodProperties EVOLUTCORN = new FoodProperties.Builder().nutrition(2)\r\n            .saturationMod(0.75f).build();\r\n\r\n    public static final FoodProperties ROAST_EVOLUTCORN = new FoodProperties.Builder().nutrition(4)\r\n            .saturationMod(0.625f).build();\r\n\r\n    public static final FoodProperties EVOLUTCORN_GRAINS = new FoodProperties.Builder().nutrition(2)\r\n            .saturationMod(0.75f).build();\r\n\r\n    public static final FoodProperties ROAST_EVOLUTCORN_CHOPS = new FoodProperties.Builder().nutrition(4)\r\n            .saturationMod(0.625f).build();\r\n\r\n    public static final FoodProperties CRETACEOUS_ZEA_BALL = new FoodProperties.Builder().nutrition(6)\r\n            .saturationMod(0.45f)\r\n            .effect(()-> new MobEffectInstance(ModEffects.NOURISHMENT.get(),800,0),1.0F)\r\n            .build();\r\n\r\n    public static final FoodProperties COLORFUL_GRILLED_SKEWERS = new FoodProperties.Builder().nutrition(9)\r\n            .saturationMod(0.85f).build();\r\n\r\n    public static final FoodProperties PEARLIP = new FoodProperties.Builder().nutrition(1)\r\n            .saturationMod(0.4f).build();\r\n\r\n    public static final FoodProperties POPOLUTCORN = new FoodProperties.Builder().nutrition(4).fast()\r\n            .saturationMod(0.625f).effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INCANDESCENCE.get(),600,0),1.0F).build();\r\n\r\n    public static final FoodProperties PEARLIPEARL = new FoodProperties.Builder().nutrition(1).fast()\r\n            .saturationMod(0.15f).build();\r\n\r\n    public static final FoodProperties PEATIC_MUSA_SALAD = new FoodProperties.Builder().nutrition(6).fast()\r\n            .saturationMod(0.6f).effect(()-> new MobEffectInstance(MobEffects.HEAL,1,0),1.0F).build();\r\n\r\n    public static final FoodProperties PEARLIP_MILK_SHAKE = new FoodProperties.Builder().alwaysEat()\r\n            .effect(()-> new MobEffectInstance(MobEffects.REGENERATION,600,0),1.0F)\r\n            .effect(()-> new MobEffectInstance(MobEffects.DAMAGE_RESISTANCE,600,0),1F).build();\r\n\r\n    public static final FoodProperties PEARLIP_PUMPKIN_PIE = new FoodProperties.Builder().nutrition(3).fast()\r\n            .saturationMod(1.0f).build();\r\n\r\n    public static final FoodProperties PEARLIPEARL_TART = new FoodProperties.Builder().nutrition(8)\r\n            .saturationMod(0.625f).build();\r\n\r\n    public static final FoodProperties PEARLIPEARL_EGGSTEAM = new FoodProperties.Builder().nutrition(2)\r\n            .saturationMod(0.3f).effect(()-> new MobEffectInstance(ModEffects.COMFORT.get(),1200,0),1.0F)\r\n            .build();\r\n\r\n    public static final FoodProperties PEARLIP_JELLY = new FoodProperties.Builder().nutrition(2)\r\n            .saturationMod(0.2f).effect(()-> new MobEffectInstance(MobEffects.JUMP,1200,0),1.0F)\r\n            .effect(()-> new MobEffectInstance(MobEffects.MOVEMENT_SPEED,1200,0),1.0F)\r\n            .build();\r\n\r\n    /*\r\n    姬海棠系列食物\r\n     */\r\n    public static final FoodProperties HIMEKAIDO = new FoodProperties.Builder()\r\n            .nutrition(3)\r\n            .saturationMod(0.6f)\r\n            .effect(() -> {\r\n                return new MobEffectInstance((MobEffect)ImmortalersDelightMobEffect.RELIEVE_POISON.get(), 25, 0);\r\n            }, 1.0F)\r\n            .build();\r\n    public static final FoodProperties HIMEKAIDO_JELLY = new FoodProperties.Builder().alwaysEat()\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.RELIEVE_POISON.get(),120,1),1.0F)\r\n            .effect(()-> new MobEffectInstance(MobEffects.SATURATION,4,0),1.0F).build();\r\n    public static final FoodProperties YOGURT = new FoodProperties.Builder().alwaysEat()\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.RELIEVE_POISON.get(),400,0),1.0F)\r\n            .effect(()-> new MobEffectInstance(MobEffects.SATURATION,4,0),0.51F).build();\r\n    public static final FoodProperties BAKED_POISONOUS_POTATO = new FoodProperties.Builder()\r\n            .nutrition(6)\r\n            .saturationMod(0.55f)\r\n            .effect(() -> {\r\n                return new MobEffectInstance((MobEffect)ImmortalersDelightMobEffect.WEAK_POISON.get(), 80, 0);\r\n            }, 0.6F)\r\n            .build();\r\n    public static final FoodProperties DIPPED_ROTTEN_FLESH = new FoodProperties.Builder()\r\n            .nutrition(4)\r\n            .saturationMod(0.45f)\r\n            .effect(() -> {\r\n                return new MobEffectInstance((MobEffect)ImmortalersDelightMobEffect.RESISTANCE_TO_UNDEAD.get(),320,0);\r\n            }, 0.6F)\r\n            .build();\r\n\r\n    public static final FoodProperties CRISPY_YOGURT_ROTTEN_FLESH = new FoodProperties.Builder()\r\n            .nutrition(6)\r\n            .saturationMod(0.6f)\r\n            .effect(() -> {\r\n                return new MobEffectInstance((MobEffect)ImmortalersDelightMobEffect.RESISTANCE_TO_UNDEAD.get(),720,0);\r\n            }, 1.0F)\r\n            .build();\r\n\r\n    public static final FoodProperties MEATY_ROTTEN_TOMATO_BROTH = new FoodProperties.Builder()\r\n            .nutrition(8)\r\n            .saturationMod(0.4f)\r\n            .effect(() -> {\r\n                return new MobEffectInstance((MobEffect)ImmortalersDelightMobEffect.RESISTANCE_TO_UNDEAD.get(),560,0);\r\n            }, 1.0F)\r\n            .effect(() -> {\r\n                return new MobEffectInstance((MobEffect)ImmortalersDelightMobEffect.RESISTANCE_TO_ILLAGER.get(),360,0);\r\n            }, 1.0F)\r\n            .effect(()-> new MobEffectInstance(ModEffects.COMFORT.get(),1800,0),1.0F)\r\n            .build();\r\n\r\n    public static final FoodProperties BRAISED_SPIDER_EYES_IN_GRAVY = new FoodProperties.Builder()\r\n            .nutrition(4)\r\n            .saturationMod(0.5f)\r\n            .effect(() -> {\r\n                return new MobEffectInstance((MobEffect)ImmortalersDelightMobEffect.RESISTANCE_TO_ARTHROPOD.get(),560,0);\r\n            }, 1.0F)\r\n            .effect(() -> {\r\n                return new MobEffectInstance((MobEffect)ImmortalersDelightMobEffect.RESISTANCE_TO_UNDEAD.get(),360,0);\r\n            }, 1.0F)\r\n            .effect(new MobEffectInstance(MobEffects.REGENERATION,150,0),1.0F)\r\n            .build();\r\n    public static final FoodProperties TARTARE_CHICKEN = new FoodProperties.Builder()\r\n            .nutrition(8)\r\n            .saturationMod(0.875f)\r\n            .effect(() -> {\r\n                return new MobEffectInstance((MobEffect)ImmortalersDelightMobEffect.RESISTANCE_TO_ARTHROPOD.get(),640,1);\r\n            }, 1.0F)\r\n            .effect(new MobEffectInstance(MobEffects.REGENERATION,450,0),1.0F)\r\n            .build();\r\n\r\n    public static final FoodProperties STUFFED_POISONOUS_POTATO = new FoodProperties.Builder()\r\n            .nutrition(10)\r\n            .saturationMod(0.6f)\r\n            .effect(() -> {\r\n                return new MobEffectInstance((MobEffect)ImmortalersDelightMobEffect.RESISTANCE_TO_UNDEAD.get(),360,0);\r\n            }, 1.0F)\r\n            .effect(() -> {\r\n                return new MobEffectInstance((MobEffect)ImmortalersDelightMobEffect.RESISTANCE_TO_ILLAGER.get(),800,0);\r\n            }, 1.0F)\r\n            .build();\r\n\r\n    public static final FoodProperties PUFFERFISH_ROLL = new FoodProperties.Builder()\r\n            .nutrition(4)\r\n            .saturationMod(1.2f)\r\n            .effect(() -> {\r\n                return new MobEffectInstance((MobEffect)ImmortalersDelightMobEffect.RESISTANCE_TO_ABYSSAL.get(),2000,0);\r\n            }, 1.0F)\r\n            .effect(new MobEffectInstance(MobEffects.HEALTH_BOOST,600,0),1.0F)\r\n            .effect(new MobEffectInstance(MobEffects.REGENERATION,250,1),1.0F)\r\n            .build();\r\n    public static final FoodProperties BOWL_OF_STEWED_ROTTEN_MEAT_IN_CLAY_POT = new FoodProperties.Builder()\r\n            .nutrition(8)\r\n            .saturationMod(1.2f)\r\n            .effect(() -> {\r\n                return new MobEffectInstance((MobEffect)ModEffects.NOURISHMENT.get(),2000,0);\r\n            }, 1.0F)\r\n            .effect(() -> {\r\n                return new MobEffectInstance((MobEffect)ImmortalersDelightMobEffect.RESISTANCE_TO_ABYSSAL.get(),1600,1);\r\n            }, 1.0F)\r\n            .effect(new MobEffectInstance(MobEffects.HEALTH_BOOST,2400,0),1.0F)\r\n            .effect(new MobEffectInstance(MobEffects.REGENERATION,250,1),1.0F)\r\n            .build();\r\n    public static final FoodProperties GOLDEN_HIMEKAIDO = new FoodProperties.Builder()\r\n            .nutrition(4)\r\n            .saturationMod(1.2f)\r\n            .effect(() -> {\r\n                return new MobEffectInstance((MobEffect)ImmortalersDelightMobEffect.MAGICAL_REVERSE.get(),3,1);\r\n            }, 1.0F)\r\n            .effect(new MobEffectInstance(MobEffects.ABSORPTION,2400,0),1.0F)\r\n            .alwaysEat()\r\n            .build();\r\n    public static final FoodProperties ENCHANTED_GOLDEN_HIMEKAIDO = new FoodProperties.Builder()\r\n            .nutrition(8)\r\n            .saturationMod(1.25f)\r\n            .effect(() -> {\r\n                return new MobEffectInstance((MobEffect)ImmortalersDelightMobEffect.MAGICAL_REVERSE.get(),20,3);\r\n            }, 1.0F)\r\n            .effect(() -> {\r\n                return new MobEffectInstance((MobEffect)ImmortalersDelightMobEffect.RELIEVE_POISON.get(),6000,0);\r\n            }, 1.0F)\r\n            .effect(new MobEffectInstance(MobEffects.ABSORPTION,2400,1),1.0F)\r\n            .effect(new MobEffectInstance(MobEffects.HEALTH_BOOST,2400,1),1.0F)\r\n            .alwaysEat()\r\n            .build();\r\n    public static final FoodProperties KWAT_WHEAT = new FoodProperties.Builder().alwaysEat()\r\n            .nutrition(3)\r\n            .saturationMod(0.1f)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.GAS_POISON.get(),100,0),1.0F)\r\n            .effect(()-> new MobEffectInstance(MobEffects.SATURATION,3,0),1.0F).build();\r\n    public static final FoodProperties RAW_SNIFFER_SLICE = new FoodProperties.Builder()\r\n            .nutrition(2)\r\n            .saturationMod(0.5f)\r\n            .effect(new MobEffectInstance(MobEffects.DIG_SPEED,60,0),1.0F)\r\n            .build();\r\n    public static final FoodProperties COOKED_SNIFFER_SLICE = new FoodProperties.Builder()\r\n            .nutrition(3)\r\n            .saturationMod(1.45f)\r\n            .effect(new MobEffectInstance(MobEffects.DIG_SPEED,80,0),1.0F).build();\r\n\r\n    public static final FoodProperties RAW_SNIFFER_STEAK = new FoodProperties.Builder()\r\n            .nutrition(4)\r\n            .saturationMod(0.5f)\r\n            .effect(new MobEffectInstance(MobEffects.DIG_SPEED,120,0),1.0F).build();\r\n\r\n    public static final FoodProperties COOKED_SNIFFER_STEAK = new FoodProperties.Builder()\r\n            .nutrition(9)\r\n            .saturationMod(0.8f)\r\n            .effect(new MobEffectInstance(MobEffects.DIG_SPEED,300,0),1.0F).build();\r\n\r\n    public static final FoodProperties CLEAR_WATER_VODKA = new FoodProperties.Builder()\r\n            .alwaysEat()\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INEBRIATED.get(),12000,0),1.0F)\r\n            .effect(new MobEffectInstance(MobEffects.REGENERATION,1500,0),1.0F)\r\n            .effect(new MobEffectInstance(MobEffects.ABSORPTION,900,9),1.0F)\r\n            .effect(new MobEffectInstance(MobEffects.HEAL,1,1),1.0F).build();\r\n\r\n    public static final FoodProperties ZEA_PANCAKE_SLICE = new FoodProperties.Builder().nutrition(3).saturationMod(0.65f).build();\r\n\r\n    public static final FoodProperties PEARLIP_PIE_SLICE = new FoodProperties.Builder().nutrition(3).saturationMod(0.65f).build();\r\n\r\n    public static final FoodProperties HIMEKAIDO_YOGURT_PIE_SLICE = new FoodProperties.Builder().nutrition(3).saturationMod(0.65f).build();\r\n\r\n    public static final FoodProperties EVOLUTCORN_BEER = new FoodProperties.Builder()\r\n            .effect(new MobEffectInstance(MobEffects.DAMAGE_BOOST,2700,2),1F)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INEBRIATED.get(),1800),1F).build();\r\n\r\n    public static final FoodProperties DREUMK_WINE = new FoodProperties.Builder()\r\n            .effect(new MobEffectInstance(MobEffects.DAMAGE_BOOST,1800,2),1F)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INEBRIATED.get(),1800),1F)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.RELIEVE_POISON.get(),6000),1.0F).build();\r\n\r\n    public static final FoodProperties VULCAN_COKTAIL = new FoodProperties.Builder()\r\n            .effect(() ->new MobEffectInstance(ImmortalersDelightMobEffect.INEBRIATED.get(),600),1F)\r\n            .effect(() -> new MobEffectInstance(ImmortalersDelightMobEffect.WARM_CURRENT_SURGES.get(),9600),1F).build();\r\n\r\n    public static final FoodProperties LEAF_TEA = new FoodProperties.Builder()\r\n            .effect(() ->new MobEffectInstance(MobEffects.MOVEMENT_SPEED,1800),1F)\r\n            .effect(() -> new MobEffectInstance(MobEffects.DIG_SPEED,360),1F).build();\r\n\r\n    public static final FoodProperties LEISAMBOO_TEA = new FoodProperties.Builder()\r\n            .effect(() ->new MobEffectInstance(MobEffects.NIGHT_VISION,1800),1F)\r\n            .effect(() ->new MobEffectInstance(MobEffects.DIG_SPEED,340),1F)\r\n            .effect(() -> new MobEffectInstance(MobEffects.DIG_SLOWDOWN,540),1F).build();\r\n\r\n    public static final FoodProperties ICED_BLACK_TEA = new FoodProperties.Builder()\r\n            .effect(() ->new MobEffectInstance(MobEffects.DAMAGE_BOOST,1440,2),1F)\r\n            .effect(() -> new MobEffectInstance(MobEffects.MOVEMENT_SLOWDOWN,1200,1),1F)\r\n            .effect(() -> new MobEffectInstance(MobEffects.JUMP,20,3),1F).build();\r\n\r\n    public static final FoodProperties PEARLIPEARL_MILK_TEA = new FoodProperties.Builder()\r\n            .effect(() ->new MobEffectInstance(MobEffects.DAMAGE_BOOST,2000,1),1F)\r\n            .effect(() ->new MobEffectInstance(MobEffects.SATURATION,3),1F)\r\n            .effect(() -> new MobEffectInstance(ImmortalersDelightMobEffect.RESISTANCE_TO_SURROUNDINGS.get(),2000,1),1F).build();\r\n\r\n    public static final FoodProperties PEARLIPEARL_MILK_GREEN = new FoodProperties.Builder()\r\n            .effect(() ->new MobEffectInstance(MobEffects.MOVEMENT_SPEED,1600,1),1F)\r\n            .effect(() ->new MobEffectInstance(MobEffects.SATURATION,1,2),1F)\r\n            .effect(() -> new MobEffectInstance(ImmortalersDelightMobEffect.RESISTANCE_TO_SURROUNDINGS.get(),4200),1F).build();\r\n\r\n    public static final FoodProperties STOVE_BLACK_TEA = new FoodProperties.Builder()\r\n            .effect(() ->new MobEffectInstance(MobEffects.DAMAGE_BOOST,2200),1F)\r\n            .effect(()-> new MobEffectInstance(ModEffects.COMFORT.get(),600,0),1.0F).build();\r\n\r\n    public static final FoodProperties LEAF_GREEN_TEA = new FoodProperties.Builder()\r\n            .effect(() ->new MobEffectInstance(MobEffects.MOVEMENT_SPEED,1350,1),1F)\r\n            .effect(() -> new MobEffectInstance(MobEffects.NIGHT_VISION,480),1F).build();\r\n\r\n    public static final FoodProperties BRITISH_YELLOW_TEA = new FoodProperties.Builder()\r\n            .effect(() ->new MobEffectInstance(MobEffects.DIG_SPEED,1800),1F)\r\n            .effect(() -> new MobEffectInstance(MobEffects.FIRE_RESISTANCE,300),1F).build();\r\n\r\n    public static final FoodProperties KWAT_WHEAT_DOUFU = new FoodProperties.Builder().nutrition(1).saturationMod(1F).build();\r\n\r\n    public static final FoodProperties FRY_KWAT_WHEAT_DOUFU = new FoodProperties.Builder().nutrition(4).saturationMod(0.5F)\r\n            .effect(new MobEffectInstance(MobEffects.DAMAGE_BOOST,400,1),1F).build();\r\n\r\n    public static final FoodProperties JADE_AND_RUBY_SOUP = new FoodProperties.Builder().nutrition(6).saturationMod(0.5F)\r\n            .effect(()->new MobEffectInstance(ImmortalersDelightMobEffect.KEEP_A_FAST.get(),200,1),1F)\r\n            .effect(()->new MobEffectInstance(ImmortalersDelightMobEffect.INCANDESCENCE.get(),800),1F)\r\n            .effect(()->new MobEffectInstance(ModEffects.COMFORT.get(),800),1F).build();\r\n\r\n    public static final FoodProperties KWAT_WHEAT_TOAST = new FoodProperties.Builder().nutrition(12).saturationMod(0.6f).build();\r\n\r\n    public static final FoodProperties KWAT_WHEAT_TOAST_SLICE = new FoodProperties.Builder().nutrition(4).saturationMod(0.4f).build();\r\n\r\n    public static final FoodProperties NETHER_CREAM_SOUP = new FoodProperties.Builder().nutrition(6).saturationMod(0.75f)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INCANDESCENCE.get(),600,1),1F)\r\n            .effect(()->new MobEffectInstance(ModEffects.COMFORT.get(),1200),1F).build();\r\n\r\n    public static final FoodProperties NETHER_CREAM_BREAD = new FoodProperties.Builder().nutrition(8).saturationMod(0.375f)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INCANDESCENCE.get(),2400),1F)\r\n            .effect(new MobEffectInstance(MobEffects.SATURATION,60),1F).build();\r\n\r\n    public static final FoodProperties HOT_HI_SOUP = new FoodProperties.Builder().nutrition(8).saturationMod(0.375f)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INCANDESCENCE.get(),600),1F).build();\r\n\r\n    public static final FoodProperties INCANDESCENCE_SUSHI = new FoodProperties.Builder().nutrition(8).saturationMod(0.375f)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INCANDESCENCE.get(),600),1F).build();\r\n\r\n    public static final FoodProperties TORCHFLOWER_CAKE = new FoodProperties.Builder().nutrition(4).saturationMod(0.5f)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INCANDESCENCE.get(),600),1F)\r\n            .effect(()-> new MobEffectInstance(ModEffects.COMFORT.get(),1200),1F).build();\r\n\r\n    public static final FoodProperties TORCHFLOWER_CURRY_RICE = new FoodProperties.Builder().nutrition(15).saturationMod(1f)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INCANDESCENCE.get(),1200),1F).build();\r\n    public static final FoodProperties HOT_HI_SOUP = new FoodProperties.Builder().nutrition(8).saturationMod(0.375f)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.WARM_CURRENT_SURGES.get(),600),1F).build();\r\n\r\n    public static final FoodProperties INCANDESCENCE_SUSHI = new FoodProperties.Builder().nutrition(8).saturationMod(0.375f)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.WARM_CURRENT_SURGES.get(),600),1F).build();\r\n\r\n    public static final FoodProperties TORCHFLOWER_CAKE = new FoodProperties.Builder().nutrition(4).saturationMod(0.5f)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.WARM_CURRENT_SURGES.get(),600),1F)\r\n            .effect(()-> new MobEffectInstance(ModEffects.COMFORT.get(),1200),1F).build();\r\n\r\n    public static final FoodProperties TORCHFLOWER_CURRY_RICE = new FoodProperties.Builder().nutrition(15).saturationMod(1f)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.WARM_CURRENT_SURGES.get(),1200),1F).build();\r\n\r\n    public static final FoodProperties EXTRA_SPICY_PASTA = new FoodProperties.Builder().nutrition(12).saturationMod(0.35f)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INCANDESCENCE.get(),1200),1F).build();\r\n    public static final FoodProperties EXTRA_SPICY_PASTA = new FoodProperties.Builder().nutrition(12).saturationMod(0.35f)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.WARM_CURRENT_SURGES.get(),1200),1F).build();\r\n\r\n    public static final FoodProperties TORCHFLOWER_COOKIE = new FoodProperties.Builder().nutrition(1).saturationMod(0.5f)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INCANDESCENCE.get(),200),1F).fast().build();\r\n\r\n    //TORCHFLOWER_COOKIE\r\n    public static final FoodProperties TORCHFLOWER_COOKIE = new FoodProperties.Builder().nutrition(1).saturationMod(0.5f)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.WARM_CURRENT_SURGES.get(),200),1F).fast().build();\r\n\r\n    public static final FoodProperties MASHED_POTATOES = new FoodProperties.Builder().nutrition(1).saturationMod(0.5f).fast().build();\r\n\r\n    public static final FoodProperties MASHED_POISONOUS_POTATO = new FoodProperties.Builder().nutrition(1).saturationMod(0.5f)\r\n            .effect(new MobEffectInstance(MobEffects.POISON,600),0.3F).fast().build();\r\n\r\n    public static final FoodProperties MASHED_POTATO_WITH_JAM = new FoodProperties.Builder().nutrition(6).saturationMod(0.6f)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.RELIEVE_POISON.get(),1200),1F).build();\r\n\r\n    public static final FoodProperties MASHED_POISONOUS_POTATO_WITH_JAM = new FoodProperties.Builder().nutrition(6).saturationMod(0.6f)\r\n            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.RESISTANCE_TO_ILLAGER.get(),1200),1F).build();\r\n\r\n    public static final FoodProperties SUTFFED_DOUFU = new FoodProperties.Builder().nutrition(6).saturationMod(0.65F)\r\n            .effect(new MobEffectInstance(MobEffects.DAMAGE_BOOST,1200,1),1F).build();\r\n\r\n    public static final FoodProperties ICE_PEARLIP = new FoodProperties.Builder().nutrition(4).saturationMod(0.25F).fast().build();\r\n\r\n    public static final FoodProperties CHOCOLATE_PEARLIP_STICKS = new FoodProperties.Builder().nutrition(6).saturationMod(0.165F).fast().build();\r\n\r\n    public static final FoodProperties NETHER_KVASS = new FoodProperties.Builder()\r\n            .effect(()->new MobEffectInstance(ImmortalersDelightMobEffect.INCANDESCENCE.get(),600,1),1F)\r\n            .effect(new MobEffectInstance(MobEffects.CONFUSION,100),1F)\r\n            .build();\r\n\r\n    public static final FoodProperties PITCHER_PLANT_BARBECUE = new FoodProperties.Builder().nutrition(8).saturationMod(0.375F)\r\n            .effect(()->new MobEffectInstance(ImmortalersDelightMobEffect.BURN_THE_BOATS.get(),1200),1F).build();\r\n\r\n    public static final FoodProperties POD_SHELL_BURGER_MEAT_CUBE = new FoodProperties.Builder().nutrition(6).saturationMod(0.55F)\r\n            .effect(()->new MobEffectInstance(ImmortalersDelightMobEffect.BURN_THE_BOATS.get(),1800),1F).build();\r\n\r\n    public static final FoodProperties PURGATORY_ALE = new FoodProperties.Builder()\r\n            .effect(()->new MobEffectInstance(ImmortalersDelightMobEffect.INCANDESCENCE.get(),3600),1F)\r\n            .effect(()->new MobEffectInstance(ImmortalersDelightMobEffect.INEBRIATED.get(),2400),1F).build();\r\n\r\n    //PURGATORY_ALE\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightFoodProperties.java b/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightFoodProperties.java
--- a/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightFoodProperties.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightFoodProperties.java	
@@ -78,10 +78,10 @@
             .build();
     public static final FoodProperties HIMEKAIDO_JELLY = new FoodProperties.Builder().alwaysEat()
             .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.RELIEVE_POISON.get(),120,1),1.0F)
-            .effect(()-> new MobEffectInstance(MobEffects.SATURATION,4,0),1.0F).build();
+            .effect(()-> new MobEffectInstance(MobEffects.SATURATION,5,0),1.0F).build();
     public static final FoodProperties YOGURT = new FoodProperties.Builder().alwaysEat()
             .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.RELIEVE_POISON.get(),400,0),1.0F)
-            .effect(()-> new MobEffectInstance(MobEffects.SATURATION,4,0),0.51F).build();
+            .effect(()-> new MobEffectInstance(MobEffects.SATURATION,4,0),1F).build();
     public static final FoodProperties BAKED_POISONOUS_POTATO = new FoodProperties.Builder()
             .nutrition(6)
             .saturationMod(0.55f)
@@ -219,8 +219,8 @@
     public static final FoodProperties CLEAR_WATER_VODKA = new FoodProperties.Builder()
             .alwaysEat()
             .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INEBRIATED.get(),12000,0),1.0F)
-            .effect(new MobEffectInstance(MobEffects.REGENERATION,1500,0),1.0F)
-            .effect(new MobEffectInstance(MobEffects.ABSORPTION,900,9),1.0F)
+            .effect(()-> new MobEffectInstance(MobEffects.REGENERATION,1500,0),1.0F)
+            .effect(()-> new MobEffectInstance(MobEffects.ABSORPTION,900,9),1.0F)
             .effect(new MobEffectInstance(MobEffects.HEAL,1,1),1.0F).build();
 
     public static final FoodProperties ZEA_PANCAKE_SLICE = new FoodProperties.Builder().nutrition(3).saturationMod(0.65f).build();
@@ -230,54 +230,96 @@
     public static final FoodProperties HIMEKAIDO_YOGURT_PIE_SLICE = new FoodProperties.Builder().nutrition(3).saturationMod(0.65f).build();
 
     public static final FoodProperties EVOLUTCORN_BEER = new FoodProperties.Builder()
-            .effect(new MobEffectInstance(MobEffects.DAMAGE_BOOST,2700,2),1F)
+            .alwaysEat()
+            .effect(()-> new MobEffectInstance(MobEffects.DAMAGE_BOOST,2700,2),1F)
             .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INEBRIATED.get(),1800),1F).build();
 
     public static final FoodProperties DREUMK_WINE = new FoodProperties.Builder()
-            .effect(new MobEffectInstance(MobEffects.DAMAGE_BOOST,1800,2),1F)
+            .alwaysEat()
             .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INEBRIATED.get(),1800),1F)
             .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.RELIEVE_POISON.get(),6000),1.0F).build();
 
     public static final FoodProperties VULCAN_COKTAIL = new FoodProperties.Builder()
+            .alwaysEat()
             .effect(() ->new MobEffectInstance(ImmortalersDelightMobEffect.INEBRIATED.get(),600),1F)
             .effect(() -> new MobEffectInstance(ImmortalersDelightMobEffect.WARM_CURRENT_SURGES.get(),9600),1F).build();
 
+    public static final FoodProperties PALE_DEW_WINE = new FoodProperties.Builder()
+            .alwaysEat()
+            .effect(() ->new MobEffectInstance(ImmortalersDelightMobEffect.INEBRIATED.get(),3700),1F)
+            .effect(() -> new MobEffectInstance(MobEffects.DAMAGE_RESISTANCE,12000,2),1F).build();
+
+    public static final FoodProperties ELIXIR_OF_IMMORTALITY = new FoodProperties.Builder()
+            .effect(new MobEffectInstance(MobEffects.MOVEMENT_SPEED,92390540),1.0F)
+            .effect(new MobEffectInstance(MobEffects.DIG_SPEED,92390540),1.0F)
+            .effect(new MobEffectInstance(MobEffects.JUMP,3240000),1.0F)
+            .effect(new MobEffectInstance(MobEffects.DAMAGE_RESISTANCE,3240000),1.0F)
+            .effect(new MobEffectInstance(MobEffects.DAMAGE_BOOST,72000,1),1.0F)
+            .effect(new MobEffectInstance(MobEffects.REGENERATION,72000),1.0F)
+            .effect(() ->new MobEffectInstance(ImmortalersDelightMobEffect.INEBRIATED.get(),2700),1F).build();
+
     public static final FoodProperties LEAF_TEA = new FoodProperties.Builder()
+            .alwaysEat()
             .effect(() ->new MobEffectInstance(MobEffects.MOVEMENT_SPEED,1800),1F)
             .effect(() -> new MobEffectInstance(MobEffects.DIG_SPEED,360),1F).build();
 
     public static final FoodProperties LEISAMBOO_TEA = new FoodProperties.Builder()
+            .alwaysEat()
             .effect(() ->new MobEffectInstance(MobEffects.NIGHT_VISION,1800),1F)
             .effect(() ->new MobEffectInstance(MobEffects.DIG_SPEED,340),1F)
             .effect(() -> new MobEffectInstance(MobEffects.DIG_SLOWDOWN,540),1F).build();
 
     public static final FoodProperties ICED_BLACK_TEA = new FoodProperties.Builder()
-            .effect(() ->new MobEffectInstance(MobEffects.DAMAGE_BOOST,1440,2),1F)
-            .effect(() -> new MobEffectInstance(MobEffects.MOVEMENT_SLOWDOWN,1200,1),1F)
-            .effect(() -> new MobEffectInstance(MobEffects.JUMP,20,3),1F).build();
+            .alwaysEat()
+            .effect(() ->new MobEffectInstance(MobEffects.JUMP,480,9),1F)
+            .effect(() -> new MobEffectInstance(MobEffects.DIG_SLOWDOWN,1000,2),1F)
+            .build();
 
     public static final FoodProperties PEARLIPEARL_MILK_TEA = new FoodProperties.Builder()
-            .effect(() ->new MobEffectInstance(MobEffects.DAMAGE_BOOST,2000,1),1F)
+            .alwaysEat()
+            .effect(() ->new MobEffectInstance(MobEffects.DAMAGE_BOOST,2000,2),1F)
             .effect(() ->new MobEffectInstance(MobEffects.SATURATION,3),1F)
             .effect(() -> new MobEffectInstance(ImmortalersDelightMobEffect.RESISTANCE_TO_SURROUNDINGS.get(),2000,1),1F).build();
 
     public static final FoodProperties PEARLIPEARL_MILK_GREEN = new FoodProperties.Builder()
+            .alwaysEat()
             .effect(() ->new MobEffectInstance(MobEffects.MOVEMENT_SPEED,1600,1),1F)
             .effect(() ->new MobEffectInstance(MobEffects.SATURATION,1,2),1F)
             .effect(() -> new MobEffectInstance(ImmortalersDelightMobEffect.RESISTANCE_TO_SURROUNDINGS.get(),4200),1F).build();
 
     public static final FoodProperties STOVE_BLACK_TEA = new FoodProperties.Builder()
-            .effect(() ->new MobEffectInstance(MobEffects.DAMAGE_BOOST,2200),1F)
-            .effect(()-> new MobEffectInstance(ModEffects.COMFORT.get(),600,0),1.0F).build();
+            .alwaysEat()
+            .effect(() ->new MobEffectInstance(MobEffects.JUMP,2000,1),1F)
+            .build();
 
     public static final FoodProperties LEAF_GREEN_TEA = new FoodProperties.Builder()
+            .alwaysEat()
             .effect(() ->new MobEffectInstance(MobEffects.MOVEMENT_SPEED,1350,1),1F)
             .effect(() -> new MobEffectInstance(MobEffects.NIGHT_VISION,480),1F).build();
 
     public static final FoodProperties BRITISH_YELLOW_TEA = new FoodProperties.Builder()
+            .alwaysEat()
             .effect(() ->new MobEffectInstance(MobEffects.DIG_SPEED,1800),1F)
             .effect(() -> new MobEffectInstance(MobEffects.FIRE_RESISTANCE,300),1F).build();
 
+    public static final FoodProperties RED_STUFFED_BUN = new FoodProperties.Builder()
+            .nutrition(10)
+            .saturationMod(0.77f)
+            .effect(() ->new MobEffectInstance(MobEffects.DAMAGE_BOOST,1800),1F)
+            .build();
+
+    public static final FoodProperties SPICY_PUDDING = new FoodProperties.Builder()
+            .alwaysEat()
+            .effect(() ->new MobEffectInstance(MobEffects.DAMAGE_BOOST,1440,2),1F)
+            .effect(() -> new MobEffectInstance(MobEffects.MOVEMENT_SLOWDOWN,1200,1),1F)
+            .effect(() -> new MobEffectInstance(MobEffects.JUMP,20,3),1F).build();
+
+    public static final FoodProperties SCARLET_DEVILS_CAKE_SLICE = new FoodProperties.Builder()
+            .nutrition(5)
+            .saturationMod(0.6f)
+            .effect(() ->new MobEffectInstance(MobEffects.DAMAGE_BOOST,500,1),1F)
+            .effect(()-> new MobEffectInstance(ModEffects.COMFORT.get(),600,0),1.0F)
+            .build();
     public static final FoodProperties KWAT_WHEAT_DOUFU = new FoodProperties.Builder().nutrition(1).saturationMod(1F).build();
 
     public static final FoodProperties FRY_KWAT_WHEAT_DOUFU = new FoodProperties.Builder().nutrition(4).saturationMod(0.5F)
@@ -299,19 +341,6 @@
     public static final FoodProperties NETHER_CREAM_BREAD = new FoodProperties.Builder().nutrition(8).saturationMod(0.375f)
             .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INCANDESCENCE.get(),2400),1F)
             .effect(new MobEffectInstance(MobEffects.SATURATION,60),1F).build();
-
-    public static final FoodProperties HOT_HI_SOUP = new FoodProperties.Builder().nutrition(8).saturationMod(0.375f)
-            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INCANDESCENCE.get(),600),1F).build();
-
-    public static final FoodProperties INCANDESCENCE_SUSHI = new FoodProperties.Builder().nutrition(8).saturationMod(0.375f)
-            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INCANDESCENCE.get(),600),1F).build();
-
-    public static final FoodProperties TORCHFLOWER_CAKE = new FoodProperties.Builder().nutrition(4).saturationMod(0.5f)
-            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INCANDESCENCE.get(),600),1F)
-            .effect(()-> new MobEffectInstance(ModEffects.COMFORT.get(),1200),1F).build();
-
-    public static final FoodProperties TORCHFLOWER_CURRY_RICE = new FoodProperties.Builder().nutrition(15).saturationMod(1f)
-            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INCANDESCENCE.get(),1200),1F).build();
     public static final FoodProperties HOT_HI_SOUP = new FoodProperties.Builder().nutrition(8).saturationMod(0.375f)
             .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.WARM_CURRENT_SURGES.get(),600),1F).build();
 
@@ -325,14 +354,8 @@
     public static final FoodProperties TORCHFLOWER_CURRY_RICE = new FoodProperties.Builder().nutrition(15).saturationMod(1f)
             .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.WARM_CURRENT_SURGES.get(),1200),1F).build();
 
-    public static final FoodProperties EXTRA_SPICY_PASTA = new FoodProperties.Builder().nutrition(12).saturationMod(0.35f)
-            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INCANDESCENCE.get(),1200),1F).build();
-    public static final FoodProperties EXTRA_SPICY_PASTA = new FoodProperties.Builder().nutrition(12).saturationMod(0.35f)
+      public static final FoodProperties EXTRA_SPICY_PASTA = new FoodProperties.Builder().nutrition(12).saturationMod(0.35f)
             .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.WARM_CURRENT_SURGES.get(),1200),1F).build();
-
-    public static final FoodProperties TORCHFLOWER_COOKIE = new FoodProperties.Builder().nutrition(1).saturationMod(0.5f)
-            .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.INCANDESCENCE.get(),200),1F).fast().build();
-
     //TORCHFLOWER_COOKIE
     public static final FoodProperties TORCHFLOWER_COOKIE = new FoodProperties.Builder().nutrition(1).saturationMod(0.5f)
             .effect(()-> new MobEffectInstance(ImmortalersDelightMobEffect.WARM_CURRENT_SURGES.get(),200),1F).fast().build();
Index: src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightEntities.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.init;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.entities.ImmortalersBoat;\r\nimport com.renyigesai.immortalers_delight.entities.ImmortalersChestBoat;\r\nimport net.minecraft.world.entity.EntityType;\r\nimport net.minecraft.world.entity.MobCategory;\r\nimport net.minecraftforge.registries.DeferredRegister;\r\nimport net.minecraftforge.registries.ForgeRegistries;\r\nimport net.minecraftforge.registries.RegistryObject;\r\n\r\npublic class ImmortalersDelightEntities {\r\n    public static final DeferredRegister<EntityType<?>> ENTITY_TYPES =\r\n            DeferredRegister.create(ForgeRegistries.ENTITY_TYPES, ImmortalersDelightMod.MODID);\r\n    public static final RegistryObject<EntityType<ImmortalersBoat>> HIMEKAIDO_BOAT =\r\n            ENTITY_TYPES.register(\"immortal_boat\", () -> EntityType.Builder.<ImmortalersBoat>of(ImmortalersBoat::new, MobCategory.MISC)\r\n                    .sized(1.375f, 0.5625f).build(\"immortal_boat\"));\r\n    public static final RegistryObject<EntityType<ImmortalersChestBoat>> HIMEKAIDO_CHEST_BOAT =\r\n            ENTITY_TYPES.register(\"immortal_chest_boat\", () -> EntityType.Builder.<ImmortalersChestBoat>of(ImmortalersChestBoat::new, MobCategory.MISC)\r\n                    .sized(1.375f, 0.5625f).build(\"immortal_chest_boat\"));\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightEntities.java b/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightEntities.java
--- a/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightEntities.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/init/ImmortalersDelightEntities.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.init;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.entities.ImmortalersBoat;
 import com.renyigesai.immortalers_delight.entities.ImmortalersChestBoat;
 import net.minecraft.world.entity.EntityType;
Index: src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/BaseImmortalEffectTask.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.potion.immortaleffects;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;\r\nimport com.renyigesai.immortalers_delight.util.task.ScheduledExecuteTask;\r\nimport com.renyigesai.immortalers_delight.util.task.TimekeepingTask;\r\nimport net.minecraft.world.effect.MobEffect;\r\nimport net.minecraft.world.entity.LivingEntity;\r\n\r\nimport java.util.Objects;\r\n\r\npublic class BaseImmortalEffectTask extends ScheduledExecuteTask {\r\n    private final MobEffect THIS_EFFECT = ImmortalersDelightMobEffect.LINGERING_FLAVOR.get();\r\n    private final LivingEntity pLivingEntity;\r\n    private final Long expireTime;\r\n    /*\r\n    最大持续时间，为防止修改系统时，保险起见使用双判定\r\n     */\r\n    private int maxDurationTicks;\r\n    private int amplifier;\r\n    /*\r\n    tick计数，用于dot伤害之类的计算\r\n     */\r\n    private int tick = 0;\r\n    public BaseImmortalEffectTask(int initialDelay, int delay, LivingEntity entity, Long durationSeconds, int amplifier) {\r\n            super(initialDelay, delay);\r\n            this.pLivingEntity = entity;\r\n            this.expireTime = TimekeepingTask.getImmortalTickTime() + (long) (durationSeconds * 1000);\r\n            this.amplifier = amplifier;\r\n            this.maxDurationTicks = (int) (durationSeconds * 20 > Integer.MAX_VALUE ? Integer.MAX_VALUE : durationSeconds * 20);\r\n    }\r\n    public BaseImmortalEffectTask(int initialDelay, int delay, int taskID, LivingEntity entity, Long durationSeconds, int amplifier) {\r\n        super(initialDelay, delay,taskID);\r\n        this.pLivingEntity = entity;\r\n        this.expireTime = TimekeepingTask.getImmortalTickTime() + (long) (durationSeconds * 1000);\r\n        this.amplifier = amplifier;\r\n        this.maxDurationTicks = (int) (durationSeconds * 20 > Integer.MAX_VALUE ? Integer.MAX_VALUE : durationSeconds * 20);\r\n    }\r\n    public synchronized void expireNow() {\r\n        maxDurationTicks = tick;\r\n    }\r\n    @Override\r\n    public void run() {\r\n        /*\r\n        这里是在超过结束时间时终止计划任务\r\n         */\r\n        if ((++tick > maxDurationTicks && TimekeepingTask.getImmortalTickTime()> expireTime )\r\n                || !pLivingEntity.isAlive()\r\n                || BaseImmortalEffect.getEntityMap().get(pLivingEntity.getUUID()) == null) {\r\n            if (pLivingEntity.hasEffect(THIS_EFFECT)) {\r\n                pLivingEntity.removeEffect(THIS_EFFECT);\r\n            }\r\n            this.cancel();\r\n            return;\r\n        }\r\n        int duration = maxDurationTicks - tick > 0 ? maxDurationTicks - tick : 1;\r\n        /*\r\n        这里是实现能解的行为，如果对象没有需要的Buff，计划任务将终止\r\n         */\r\n//        if (!pLivingEntity.hasEffect(THIS_EFFECT) && tick > 1) {\r\n//            ImmortalersDelightMod.LOGGER.info(\"这里是计划任务，检测到Buff被解，取消计划任务\");\r\n//            if (pLivingEntity.hasEffect(THIS_EFFECT)) {\r\n//                pLivingEntity.removeEffect(THIS_EFFECT);\r\n//            }\r\n//            this.cancel();\r\n//            return;\r\n//        }\r\n        /*\r\n        这里是实现能续的行为，如果Effect的持续时间更长，更新计划任务的持续时间\r\n         */\r\n        if (pLivingEntity.hasEffect(THIS_EFFECT)) {\r\n            int lv = pLivingEntity.hasEffect(THIS_EFFECT)?\r\n                    Objects.requireNonNull(pLivingEntity.getEffect(THIS_EFFECT).getAmplifier()):0;\r\n            int time = pLivingEntity.hasEffect(THIS_EFFECT)?\r\n                    Objects.requireNonNull(pLivingEntity.getEffect(THIS_EFFECT).getDuration()):0;\r\n            if (lv > amplifier) {amplifier = lv;ImmortalersDelightMod.LOGGER.info(\"Buff被强化，等级增加到\" + amplifier);}\r\n            if (time > duration) {maxDurationTicks = tick + time;ImmortalersDelightMod.LOGGER.info(\"Buff被续，时间延长到\" + maxDurationTicks);}\r\n        }\r\n        DoOnRun(pLivingEntity, amplifier,duration);\r\n    }\r\n    public void DoOnRun(LivingEntity pLivingEntity, int amplifier, int duration) {\r\n        if (tick % 20 == 0) ImmortalersDelightMod.LOGGER.info(\"这里是Buff模板的Task，剩余时间为：\" + duration);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/BaseImmortalEffectTask.java b/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/BaseImmortalEffectTask.java
--- a/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/BaseImmortalEffectTask.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/BaseImmortalEffectTask.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.potion.immortaleffects;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;
 import com.renyigesai.immortalers_delight.util.task.ScheduledExecuteTask;
 import com.renyigesai.immortalers_delight.util.task.TimekeepingTask;
Index: src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/BaseImmortalEffect.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.potion.immortaleffects;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;\r\nimport com.renyigesai.immortalers_delight.util.datautil.EffectData;\r\nimport com.renyigesai.immortalers_delight.util.datautil.datasaveloadhelper.BaseImmortalMapSaveLoadHelper;\r\nimport com.renyigesai.immortalers_delight.util.datautil.datasaveloadhelper.ExitTimeSaveLoadHelper;\r\nimport com.renyigesai.immortalers_delight.util.task.ScheduledExecuteTask;\r\nimport com.renyigesai.immortalers_delight.util.task.TimekeepingTask;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport net.minecraft.world.effect.MobEffect;\r\nimport net.minecraft.world.effect.MobEffectInstance;\r\nimport net.minecraft.world.entity.LivingEntity;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraftforge.event.entity.living.LivingEvent;\r\nimport net.minecraftforge.event.level.LevelEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\nimport java.util.Map;\r\nimport java.util.Objects;\r\nimport java.util.Random;\r\nimport java.util.UUID;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\n\r\n@Mod.EventBusSubscriber\r\npublic class BaseImmortalEffect {\r\n    /*\r\n    这个类能对实体进行标记（以及解除标记），\r\n     */\r\n    /*\r\n    用Map存储受到当前效果的实体与对应的持续时间（表示为结束时刻）\r\n     */\r\n    private static final Map<UUID, EffectData> entityHasEffect = new ConcurrentHashMap<>();\r\n    private static boolean pausing = true;\r\n    private MobEffect THIS_EFFECT = ImmortalersDelightMobEffect.LINGERING_FLAVOR.get();\r\n\r\n    public static void setPausing(boolean pFirst) {\r\n        pausing = pFirst;\r\n    }\r\n    public static Map<UUID, EffectData> getEntityMap() {\r\n        return entityHasEffect;\r\n    }\r\n\r\n    /**\r\n     * 对指定的生物实体应用特殊效果，输入实体与持续时间（秒）\r\n     * @param entity\r\n     * @param durationSeconds\r\n     */\r\n    public static void applyImmortalEffect(LivingEntity entity, double durationSeconds, int amplifier) {\r\n        /*\r\n        判断合理的实体目标\r\n         */\r\n        if (entity == null || entity.isRemoved()) {\r\n            return;\r\n        }\r\n        /*\r\n        获取实体UUID以唯一标记对应实体\r\n         */\r\n        UUID uuid = entity.getUUID();\r\n        /*\r\n        计算效果的结束时刻，使用自定义的计时器以绕开WorldTime相关操作\r\n         */\r\n        long expireTime = TimekeepingTask.getImmortalTickTime() + (long) (durationSeconds * 1000);\r\n        MobEffectInstance effectInstance = new MobEffectInstance(ImmortalersDelightMobEffect.LINGERING_FLAVOR.get(), (int) (durationSeconds *20), amplifier);\r\n        entity.addEffect(effectInstance);\r\n        /*\r\n        构造新的计划任务，在其中执行buff的逻辑\r\n         */\r\n        int taskID = new Random().nextInt(Short.MAX_VALUE);\r\n        ScheduledExecuteTask task = buildEffectTask(taskID,entity,durationSeconds,amplifier);\r\n        task.start();\r\n        /*\r\n        将实体与Buff相关数据保存到Map\r\n         */\r\n        EffectData effectData = new EffectData(entity.blockPosition(),expireTime,amplifier,taskID);\r\n        entityHasEffect.put(uuid,effectData);\r\n    }\r\n\r\n    /**\r\n     * 在生物的tick事件处理效果的逻辑\r\n     * @param event\r\n     */\r\n    @SubscribeEvent\r\n    public static void onTick(LivingEvent.LivingTickEvent event) {\r\n        /*\r\n        判断是否触发了暂停，由于暂停时系统时间依然是在跑的\r\n        又因为暂停时会触发WorldSave但解除暂停不会触发WorldLoad，因此在这里再触发一次读取实体Map矫正时间\r\n         */\r\n        if (pausing && !event.getEntity().level().isClientSide){\r\n            LoadEntityMap(event.getEntity().level());\r\n        }\r\n        /*\r\n        判断当前实体是否合法\r\n         */\r\n        LivingEntity entity = event.getEntity();\r\n        if (entity == null || entity.isRemoved() || !entity.isAlive()) {\r\n            return;\r\n        }\r\n        /*\r\n        获取当前实体的效果结束时刻\r\n         */\r\n        UUID uuid = entity.getUUID();\r\n        if (entityHasEffect.get(uuid) == null) {\r\n            return;\r\n        }\r\n        Long expireTime = entityHasEffect.get(uuid).getTime();\r\n        Long durationTime = (expireTime - TimekeepingTask.getImmortalTickTime()) / 1000;\r\n        /*\r\n        如果当前系统时间超过了结束时刻，取消效果（将实体从Map中移除，取消计划任务）\r\n         */\r\n//        ImmortalersDelightMod.LOGGER.info(\"你这B玩意还有多久结束？\" + durationTime + \"秒\");\r\n//        ImmortalersDelightMod.LOGGER.info(\"这里是Buff模板的Tick方法，汇报一个现在的时间\" + TimekeepingTask.getImmortalTickTime());\r\n        if (TimekeepingTask.getImmortalTickTime() > expireTime) {\r\n            removeImmortalEffect(entity);\r\n        }\r\n        else {\r\n             /*\r\n            此处为具体的效果方法逻辑\r\n            如果是用Task执行的效果，此处一般只用于与Effect交互（例如实现能解不能续或能续不能解）\r\n            如果不用Task，理论上也可以在这里执行效果的逻辑\r\n            但我不建议与Effect交互和具体效果写一起，以免逻辑没理顺导致时间失控等问题\r\n             */\r\n            int amplifier = entityHasEffect.get(uuid).getAmplifier();\r\n            Integer taskID = entityHasEffect.get(uuid).getTaskId();\r\n            DoOnTick(entity,durationTime,amplifier,taskID,uuid,expireTime);\r\n            /*\r\n             此处的处理为如果没找到实体对应的计划任务（例如退出重进导致计划任务丢失），补一个新的计划任务\r\n             */\r\n            ScheduledExecuteTask task = BaseImmortalEffectTask.getTaskFromID(taskID);\r\n            if (task == null) {\r\n//                ImmortalersDelightMod.LOGGER.info(\"WTF怎么没找到计划任务？让我看看现在的实体表是什么玩意\");\r\n                for (Map.Entry<UUID, EffectData> entry : entityHasEffect.entrySet()) {\r\n                    UUID uuid1 = entry.getKey();\r\n                    EffectData effectData = entry.getValue();\r\n//                    ImmortalersDelightMod.LOGGER.info(\"UUID: \" + uuid1 + \", Effect Level: \" + effectData.getAmplifier() +\r\n//                            \", Duration: \" + effectData.getTime() + \", Task ID \" + effectData.getTaskId());\r\n                }\r\n                ScheduledExecuteTask newTask = buildEffectTask(taskID,entity, (double) durationTime / 1000,amplifier);\r\n                newTask.start();\r\n//                System.out.println(\"计划任务异常！已创建新的计划任务\");\r\n//                ImmortalersDelightMod.LOGGER.info(\"计划任务异常！已创建新的计划任务\");\r\n            }\r\n        }\r\n    }\r\n    public static void DoOnTick (LivingEntity entity, Long durationTime, int amplifier, int taskID, UUID uuid, Long expireTime) {\r\n        int durationTicks = (int) (durationTime * 20);\r\n        /*\r\n        这是能解不能续的实现，其原理为如果断Effect则解除Buff状态\r\n        由于Task本身就是为了独立的持续时间而生，所以默认就是不能续的，只需要写一个解buff就好\r\n         */\r\n//        if (!entity.hasEffect(ImmortalersDelightMobEffect.LINGERING_FLAVOR.get())) {\r\n//            removeImmortalEffect(entity);\r\n//        }\r\n        /*\r\n        这是能续不能解的实现，其原理为如果Map内的实体没有对应Effect则一直给他补充Effect，使不能解除\r\n        而如果有，则会在Effect和Buff状态的持续时间取其大来更新Map的记录，使续药水效果可以作用于Buff状态\r\n         */\r\n        if (!entity.hasEffect(ImmortalersDelightMobEffect.LINGERING_FLAVOR.get())) {\r\n//            ImmortalersDelightMod.LOGGER.info(\"effect被解除，正在刷新effect！\");\r\n            MobEffectInstance newOne = new MobEffectInstance(ImmortalersDelightMobEffect.LINGERING_FLAVOR.get(),durationTicks ,amplifier);\r\n            entity.addEffect(newOne);\r\n            return;\r\n        }\r\n        int lv = Objects.requireNonNull(entity.getEffect(ImmortalersDelightMobEffect.LINGERING_FLAVOR.get())).getAmplifier();\r\n        int time = Objects.requireNonNull(entity.getEffect(ImmortalersDelightMobEffect.LINGERING_FLAVOR.get())).getDuration();\r\n//        ImmortalersDelightMod.LOGGER.info(\"目前的Effect时间是：\" + time);\r\n//        ImmortalersDelightMod.LOGGER.info(\"目前的Effect等级是：\" + lv);\r\n//        ImmortalersDelightMod.LOGGER.info(\"目前的Buff时间是：\" + durationTicks);\r\n//        ImmortalersDelightMod.LOGGER.info(\"目前的Buff等级是：\" + amplifier);\r\n//        ImmortalersDelightMod.LOGGER.info(\"目前的时间差是：\" + (time - durationTicks <= 0 ? -(time - durationTicks) : time - durationTicks));\r\n        if (lv > amplifier || (time - durationTicks <= 0 ? -(time - durationTicks) : time - durationTicks) > 50) {\r\n            ImmortalersDelightMod.LOGGER.info(\"Buff被续，即将更新Map\");\r\n            Long maxTime = time > durationTicks ? TimekeepingTask.getImmortalTickTime() + time*50 : expireTime;\r\n            int maxAmplifier = lv > amplifier ? lv : amplifier;\r\n            EffectData effectData = new EffectData(entity.blockPosition(), maxTime, maxAmplifier, taskID);\r\n            entityHasEffect.put(uuid,effectData);\r\n        }\r\n    }\r\n    /**\r\n     * 用于去除指定实体的特殊效果的方法\r\n     * @param entity\r\n     */\r\n    public static void removeImmortalEffect(LivingEntity entity) {\r\n        UUID uuid = entity.getUUID();\r\n        onImmortalEffectRemove(entity);\r\n        entityHasEffect.remove(uuid);\r\n    }\r\n    /**\r\n     * 用于去除指定实体的特殊效果时进行善后的方法\r\n     * @param entity\r\n     */\r\n    private static void onImmortalEffectRemove (LivingEntity entity) {\r\n        if (entity == null || entity.isRemoved()) {\r\n            return;\r\n        }\r\n        UUID uuid = entity.getUUID();\r\n        /*\r\n        在这里处理一些善后工作，这不是药水效果所以要记得手动善后\r\n         */\r\n        entity.removeEffect(ImmortalersDelightMobEffect.LINGERING_FLAVOR.get());\r\n        if (entityHasEffect.get(uuid) == null) {return;}\r\n        Integer taskID = entityHasEffect.get(uuid).getTaskId();\r\n        ScheduledExecuteTask task = BaseImmortalEffectTask.getTaskFromID(taskID);\r\n        if (task != null) {\r\n            task.stop();\r\n            task.cancel();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 监听世界加载事件，将存盘的实体Map读取出来\r\n     * @param event\r\n     */\r\n    @SubscribeEvent\r\n    public static void onWorldLoad(LevelEvent.Load event) {\r\n        if (event.getLevel() instanceof ServerLevel serverLevel) {\r\n            LoadEntityMap(serverLevel);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 这个方法用于修正时序以及从存盘数据中加载退出时的实体数据\r\n     * @param serverLevel\r\n     */\r\n    private static void LoadEntityMap(Level serverLevel) {\r\n\r\n//        ImmortalersDelightMod.LOGGER.info(\"正在读取存盘的Effect实体Map\");\r\n        Map<UUID, EffectData> oldMap = BaseImmortalMapSaveLoadHelper.loadEntityHasEffect(serverLevel);\r\n        if (oldMap == null) {\r\n//            ImmortalersDelightMod.LOGGER.info(\"存盘表为null！\");\r\n            pausing = false;\r\n            return;\r\n        }\r\n        //entityHasEffect = new ConcurrentHashMap<>();\r\n            /*\r\n            遍历存盘的Map，将存盘的Map数据同步到新Map\r\n             */\r\n        for (Map.Entry<UUID, EffectData> entry : oldMap.entrySet()) {\r\n            UUID uuidOld = entry.getKey();\r\n            EffectData dataOld = entry.getValue();\r\n            /*\r\n            修正时刻，存盘的Map里存的时间理论上为[上次关服时间 + 剩余持续时间]，因此减去一个上次关服时间再加上当前时间即可保持持续时间不变\r\n             */\r\n            Long trueTime = dataOld.getTime() - ExitTimeSaveLoadHelper.loadExitTime(serverLevel) + TimekeepingTask.getImmortalTickTime();\r\n            EffectData newOne = new EffectData(dataOld, trueTime, dataOld.getAmplifier(), dataOld.getTaskId());\r\n            entityHasEffect.put(uuidOld,newOne);\r\n        }\r\n//        ImmortalersDelightMod.LOGGER.info(\"存盘Map读取完毕，当前Effect实体Map为：\");\r\n        pausing = false;\r\n        // 输出读取到的 Map\r\n        for (Map.Entry<UUID, EffectData> entry : entityHasEffect.entrySet()) {\r\n            UUID uuid = entry.getKey();\r\n            EffectData effectData = entry.getValue();\r\n//            ImmortalersDelightMod.LOGGER.info(\"UUID: \" + uuid + \", Effect Level: \" + effectData.getAmplifier() +\r\n//                    \", Duration: \" + effectData.getTime() + \", Task ID \" + effectData.getTaskId());\r\n        }\r\n    }\r\n    /**\r\n     * 用于构建新的计划任务的方法\r\n     * @param id\r\n     * @param pLivingEntity\r\n     * @param durationSeconds\r\n     * @param amplifier\r\n     * @return\r\n     */\r\n    public static ScheduledExecuteTask buildEffectTask(int id, LivingEntity pLivingEntity, double durationSeconds, int amplifier) {\r\n\r\n        BaseImmortalEffectTask task = new BaseImmortalEffectTask(1,1,id,pLivingEntity, (long) durationSeconds,amplifier);\r\n        task.start();\r\n        return task;\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/BaseImmortalEffect.java b/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/BaseImmortalEffect.java
--- a/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/BaseImmortalEffect.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/BaseImmortalEffect.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.potion.immortaleffects;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;
 import com.renyigesai.immortalers_delight.util.datautil.EffectData;
 import com.renyigesai.immortalers_delight.util.datautil.datasaveloadhelper.BaseImmortalMapSaveLoadHelper;
Index: src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/GasPoisonEffectTask.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.potion.immortaleffects;\r\n\r\nimport com.google.common.collect.ImmutableMap;\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;\r\nimport com.renyigesai.immortalers_delight.util.task.ScheduledExecuteTask;\r\nimport com.renyigesai.immortalers_delight.util.task.TimekeepingTask;\r\nimport net.minecraft.core.registries.Registries;\r\nimport net.minecraft.resources.ResourceKey;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.damagesource.DamageSource;\r\nimport net.minecraft.world.effect.MobEffect;\r\nimport net.minecraft.world.effect.MobEffectInstance;\r\nimport net.minecraft.world.effect.MobEffects;\r\nimport net.minecraft.world.entity.LivingEntity;\r\nimport net.minecraft.world.entity.player.Player;\r\n\r\nimport java.util.*;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\n\r\npublic class GasPoisonEffectTask extends ScheduledExecuteTask {\r\n    private final MobEffect THIS_EFFECT = ImmortalersDelightMobEffect.GAS_POISON.get();\r\n    private final LivingEntity pLivingEntity;\r\n    private final Long expireTime;\r\n    /*\r\n    最大持续时间，为防止修改系统时，保险起见使用双判定\r\n     */\r\n    private int maxDurationTicks;\r\n    private int amplifier;\r\n    /*\r\n    tick计数，用于dot伤害之类的计算\r\n     */\r\n    private int tick = 0;\r\n    /*\r\n    这是瓦斯毒特有的信息，记录派生buff\r\n     */\r\n    public Map<MobEffect,Integer> derivativeEffect = new ConcurrentHashMap<MobEffect,Integer>();\r\n\r\n    public List<MobEffect> derivativeEffectName = new ArrayList<>();\r\n    public GasPoisonEffectTask(int initialDelay, int delay, LivingEntity entity, Long durationSeconds, int amplifier) {\r\n            super(initialDelay, delay);\r\n            this.pLivingEntity = entity;\r\n            this.expireTime = TimekeepingTask.getImmortalTickTime() + (long) (durationSeconds * 1000);\r\n            this.amplifier = amplifier;\r\n            this.maxDurationTicks = (int) (durationSeconds * 20 > Integer.MAX_VALUE ? Integer.MAX_VALUE : durationSeconds * 20);\r\n        this.derivativeEffect.put(MobEffects.MOVEMENT_SLOWDOWN,100);\r\n        this.derivativeEffect.put(MobEffects.BLINDNESS,900);\r\n        this.derivativeEffect.put(MobEffects.WEAKNESS,100);\r\n        this.derivativeEffect.put(MobEffects.CONFUSION,100);\r\n        this.derivativeEffect.put(MobEffects.HUNGER,100);\r\n\r\n    }\r\n    public GasPoisonEffectTask(int initialDelay, int delay, int taskID, LivingEntity entity, Long durationSeconds, int amplifier) {\r\n        super(initialDelay, delay,taskID);\r\n        this.pLivingEntity = entity;\r\n        this.expireTime = TimekeepingTask.getImmortalTickTime() + (long) (durationSeconds * 1000);\r\n        this.amplifier = amplifier;\r\n        this.maxDurationTicks = (int) (durationSeconds * 20 > Integer.MAX_VALUE ? Integer.MAX_VALUE : durationSeconds * 20);\r\n        this.derivativeEffect.put(MobEffects.MOVEMENT_SLOWDOWN,100);\r\n        this.derivativeEffect.put(MobEffects.BLINDNESS,900);\r\n        this.derivativeEffect.put(MobEffects.WEAKNESS,100);\r\n        this.derivativeEffect.put(MobEffects.CONFUSION,100);\r\n        this.derivativeEffect.put(MobEffects.HUNGER,100);\r\n    }\r\n    public synchronized void expireNow() {\r\n        maxDurationTicks = tick;\r\n    }\r\n    @Override\r\n    public void run() {\r\n        /*\r\n        这里是在超过结束时间时终止计划任务\r\n         */\r\n        if ((++tick > maxDurationTicks && TimekeepingTask.getImmortalTickTime()> expireTime )\r\n                || !pLivingEntity.isAlive()\r\n                || GasPoisonEffect.getEntityMap().get(pLivingEntity.getUUID()) == null) {\r\n            if (pLivingEntity.hasEffect(THIS_EFFECT)) {\r\n                pLivingEntity.removeEffect(THIS_EFFECT);\r\n            }\r\n            this.cancel();\r\n            return;\r\n        }\r\n        int duration = maxDurationTicks - tick > 0 ? maxDurationTicks - tick : 1;\r\n        /*\r\n        这里是实现能解的行为，如果对象没有需要的Buff，计划任务将终止\r\n         */\r\n//        if (!pLivingEntity.hasEffect(THIS_EFFECT) && tick > 1) {\r\n//            ImmortalersDelightMod.LOGGER.info(\"这里是计划任务，检测到Buff被解，取消计划任务\");\r\n//            if (pLivingEntity.hasEffect(THIS_EFFECT)) {\r\n//                pLivingEntity.removeEffect(THIS_EFFECT);\r\n//            }\r\n//            this.cancel();\r\n//            return;\r\n//        }\r\n        /*\r\n        这里是实现能续的行为，如果Effect的持续时间更长，更新计划任务的持续时间\r\n         */\r\n        if (pLivingEntity.hasEffect(THIS_EFFECT)) {\r\n            int lv = pLivingEntity.hasEffect(THIS_EFFECT)?\r\n                    Objects.requireNonNull(pLivingEntity.getEffect(THIS_EFFECT).getAmplifier()):0;\r\n            int time = pLivingEntity.hasEffect(THIS_EFFECT)?\r\n                    Objects.requireNonNull(pLivingEntity.getEffect(THIS_EFFECT).getDuration()):0;\r\n            if (lv > amplifier) {amplifier = lv;ImmortalersDelightMod.LOGGER.info(\"Buff被强化，等级增加到\" + amplifier);}\r\n            if (time > duration) {maxDurationTicks = tick + time;ImmortalersDelightMod.LOGGER.info(\"Buff被续，时间延长到\" + maxDurationTicks);}\r\n        }\r\n        DoOnRun(pLivingEntity, amplifier,duration);\r\n    }\r\n    public void DoOnRun(LivingEntity pLivingEntity, int amplifier, int duration) {\r\n        if (tick % 20 == 0) ImmortalersDelightMod.LOGGER.info(\"这里是Buff模板的Task，剩余时间为：\" + duration);\r\n        gasDamage(pLivingEntity,amplifier);\r\n    }\r\n\r\n    public void gasDamage(LivingEntity pEntity, int amplifier) {\r\n        float damage = (float) (pEntity.getMaxHealth() * 0.06 );\r\n        damage = pLivingEntity instanceof Player ? Math.max(damage, 1.2F) : Math.min(damage, 1.2F);\r\n        /*\r\n        瓦斯毒伤害，由于需要派生中毒，伤害由setHealth进行以免撞到无敌时间\r\n         */\r\n        if (pEntity.getHealth() - damage > 0) {\r\n            if (tick % (32 >> amplifier) == 0){//tick % (32 >> amplifier) == 0) pEntity.setHealth(pEntity.getHealth() - damage\r\n                pEntity.invulnerableTime = 0;\r\n                pEntity.hurt(new DamageSource(pEntity.level().registryAccess().registryOrThrow(Registries.DAMAGE_TYPE).getHolderOrThrow(ResourceKey.create(Registries.DAMAGE_TYPE, new ResourceLocation(\"immortalers_delight:gas\")))), damage);\r\n            }\r\n            /*\r\n            瓦斯毒派生其他DeBuff，通过Map记录DeBuff时间以使得派生的DeBuff也无法通过常规手段解掉\r\n             */\r\n            for (Map.Entry<MobEffect,Integer> entry : derivativeEffect.entrySet()) {\r\n                /*\r\n                如果Buff剩余时间是0，那我们就不管他\r\n                 */\r\n                int duration = entry.getValue();\r\n                if (duration >0) {\r\n                    MobEffect effect = entry.getKey();\r\n\r\n                    if (!pEntity.hasEffect(effect)) {\r\n                        MobEffectInstance effectInstance = new MobEffectInstance(effect,duration,amplifier);\r\n                        pEntity.addEffect(effectInstance);\r\n                    } else {\r\n                        /*\r\n                        如果在已经有了派生buff且持续时间比记录的更长，在此处令派生Buff的持续时间与表中的记录相加\r\n                        用于下面随机刷新DeBuff的方法，以绕开从Map随机的一坨\r\n                         */\r\n                        int time = pEntity.hasEffect(effect)? Objects.requireNonNull(pEntity.getEffect(effect)).getDuration():0;\r\n                        if (time > duration) {\r\n                            derivativeEffect.put(effect,duration + time);\r\n                        }\r\n                    }\r\n                    /*\r\n                    让Map的持续时间-1，不然buff结束不了了\r\n                     */\r\n                    derivativeEffect.put(effect, duration - 1);\r\n                }\r\n            }\r\n            /*\r\n            瓦斯毒刷新DeBuff,每秒令随机一个DeBuff的持续时间+100\r\n             */\r\n            if (tick % 20 == 0) {\r\n                derivativeEffectName = new ArrayList<>();\r\n                for (Map.Entry<MobEffect,Integer> entry : derivativeEffect.entrySet()) {\r\n                    derivativeEffectName.add(entry.getKey());\r\n                }\r\n                int size = derivativeEffectName.size() - 1 > 0 ? derivativeEffectName.size() - 1 : 0;\r\n                ImmortalersDelightMod.LOGGER.info(\"现在有几个能用的DeBuff？\" + derivativeEffectName.size());\r\n                MobEffect randEffect = derivativeEffectName.get(pEntity.getRandom().nextInt(size));\r\n                int time = derivativeEffect.get(randEffect) == null ? derivativeEffect.get(randEffect) : 0;\r\n                derivativeEffect.put(randEffect, time + 100);\r\n            }\r\n        } else {\r\n            /*\r\n            使用setHealth要管杀管埋，写一个秒杀处理负血量情况\r\n             */\r\n            pEntity.hurt(pEntity.damageSources().magic(),pEntity.getMaxHealth() * 2);\r\n            if (pEntity.isAlive() || !pEntity.isRemoved()) {\r\n                pEntity.setHealth(0);\r\n                pEntity.hurt(pEntity.damageSources().fellOutOfWorld(),pEntity.getMaxHealth() * 2);\r\n                //pEntity.die(pEntity.damageSources().fellOutOfWorld());\r\n            }\r\n            this.cancel();\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/GasPoisonEffectTask.java b/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/GasPoisonEffectTask.java
--- a/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/GasPoisonEffectTask.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/GasPoisonEffectTask.java	
@@ -1,7 +1,6 @@
 package com.renyigesai.immortalers_delight.potion.immortaleffects;
 
-import com.google.common.collect.ImmutableMap;
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;
 import com.renyigesai.immortalers_delight.util.task.ScheduledExecuteTask;
 import com.renyigesai.immortalers_delight.util.task.TimekeepingTask;
Index: src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/GasPoisonEffect.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.potion.immortaleffects;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;\r\nimport com.renyigesai.immortalers_delight.util.datautil.EffectData;\r\nimport com.renyigesai.immortalers_delight.util.datautil.datasaveloadhelper.GasPoisonMapSaveLoadHelper;\r\nimport com.renyigesai.immortalers_delight.util.datautil.datasaveloadhelper.ExitTimeSaveLoadHelper;\r\nimport com.renyigesai.immortalers_delight.util.task.ScheduledExecuteTask;\r\nimport com.renyigesai.immortalers_delight.util.task.TimekeepingTask;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport net.minecraft.world.effect.MobEffect;\r\nimport net.minecraft.world.effect.MobEffectInstance;\r\nimport net.minecraft.world.entity.LivingEntity;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraftforge.event.entity.living.LivingEvent;\r\nimport net.minecraftforge.event.level.LevelEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\nimport java.util.Map;\r\nimport java.util.Objects;\r\nimport java.util.Random;\r\nimport java.util.UUID;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\n\r\n@Mod.EventBusSubscriber\r\npublic class GasPoisonEffect {\r\n    /*\r\n    这个类能对实体进行标记（以及解除标记），\r\n     */\r\n    /*\r\n    用Map存储受到当前效果的实体与对应的持续时间（表示为结束时刻）\r\n     */\r\n    private static final Map<UUID, EffectData> entityHasEffect = new ConcurrentHashMap<>();\r\n    private static boolean pausing = true;\r\n    private MobEffect THIS_EFFECT = ImmortalersDelightMobEffect.GAS_POISON.get();\r\n\r\n    public static void setPausing(boolean pFirst) {\r\n        pausing = pFirst;\r\n    }\r\n    public static Map<UUID, EffectData> getEntityMap() {\r\n        return entityHasEffect;\r\n    }\r\n\r\n    /**\r\n     * 对指定的生物实体应用特殊效果，输入实体与持续时间（秒）\r\n     * @param entity\r\n     * @param durationSeconds\r\n     */\r\n    public static void applyImmortalEffect(LivingEntity entity, double durationSeconds, int amplifier) {\r\n        /*\r\n        判断合理的实体目标\r\n         */\r\n        if (entity == null || entity.isRemoved()) {\r\n            return;\r\n        }\r\n        /*\r\n        获取实体UUID以唯一标记对应实体\r\n         */\r\n        UUID uuid = entity.getUUID();\r\n        /*\r\n        计算效果的结束时刻，使用自定义的计时器以绕开WorldTime相关操作\r\n         */\r\n        long expireTime = TimekeepingTask.getImmortalTickTime() + (long) (durationSeconds * 1000);\r\n        MobEffectInstance effectInstance = new MobEffectInstance(ImmortalersDelightMobEffect.GAS_POISON.get(), (int) (durationSeconds *20), amplifier);\r\n        entity.addEffect(effectInstance);\r\n        /*\r\n        构造新的计划任务，在其中执行buff的逻辑\r\n         */\r\n        int taskID = new Random().nextInt(Short.MAX_VALUE);\r\n        ScheduledExecuteTask task = buildEffectTask(taskID,entity,durationSeconds,amplifier);\r\n        task.start();\r\n        /*\r\n        将实体与Buff相关数据保存到Map\r\n         */\r\n        EffectData effectData = new EffectData(entity.blockPosition(),expireTime,amplifier,taskID);\r\n        entityHasEffect.put(uuid,effectData);\r\n    }\r\n\r\n    /**\r\n     * 在生物的tick事件处理效果的逻辑\r\n     * @param event\r\n     */\r\n    @SubscribeEvent\r\n    public static void onTick(LivingEvent.LivingTickEvent event) {\r\n        /*\r\n        判断是否触发了暂停，由于暂停时系统时间依然是在跑的\r\n        又因为暂停时会触发WorldSave但解除暂停不会触发WorldLoad，因此在这里再触发一次读取实体Map矫正时间\r\n         */\r\n        if (pausing && !event.getEntity().level().isClientSide){\r\n            LoadEntityMap(event.getEntity().level());\r\n        }\r\n        /*\r\n        判断当前实体是否合法\r\n         */\r\n        LivingEntity entity = event.getEntity();\r\n        if (entity == null || entity.isRemoved() || !entity.isAlive()) {\r\n            return;\r\n        }\r\n        /*\r\n        获取当前实体的效果结束时刻\r\n         */\r\n        UUID uuid = entity.getUUID();\r\n        if (entityHasEffect.get(uuid) == null) {\r\n            return;\r\n        }\r\n        Long expireTime = entityHasEffect.get(uuid).getTime();\r\n        Long durationTime = (expireTime - TimekeepingTask.getImmortalTickTime()) / 1000;\r\n        /*\r\n        如果当前系统时间超过了结束时刻，取消效果（将实体从Map中移除，取消计划任务）\r\n         */\r\n        ImmortalersDelightMod.LOGGER.info(\"你这B玩意还有多久结束？\" + durationTime + \"秒\");\r\n        ImmortalersDelightMod.LOGGER.info(\"这里是Buff模板的Tick方法，汇报一个现在的时间\" + TimekeepingTask.getImmortalTickTime());\r\n        if (TimekeepingTask.getImmortalTickTime() > expireTime) {\r\n            removeImmortalEffect(entity);\r\n        }\r\n        else {\r\n             /*\r\n            此处为具体的效果方法逻辑\r\n            如果是用Task执行的效果，此处一般只用于与Effect交互（例如实现能解不能续或能续不能解）\r\n            如果不用Task，理论上也可以在这里执行效果的逻辑\r\n            但我不建议与Effect交互和具体效果写一起，以免逻辑没理顺导致时间失控等问题\r\n             */\r\n            int amplifier = entityHasEffect.get(uuid).getAmplifier();\r\n            Integer taskID = entityHasEffect.get(uuid).getTaskId();\r\n            DoOnTick(entity,durationTime,amplifier,taskID,uuid,expireTime);\r\n            /*\r\n             此处的处理为如果没找到实体对应的计划任务（例如退出重进导致计划任务丢失），补一个新的计划任务\r\n             */\r\n            ScheduledExecuteTask task = GasPoisonEffectTask.getTaskFromID(taskID);\r\n            if (task == null) {\r\n                ImmortalersDelightMod.LOGGER.info(\"WTF怎么没找到计划任务？让我看看现在的实体表是什么玩意\");\r\n                for (Map.Entry<UUID, EffectData> entry : entityHasEffect.entrySet()) {\r\n                    UUID uuid1 = entry.getKey();\r\n                    EffectData effectData = entry.getValue();\r\n                    ImmortalersDelightMod.LOGGER.info(\"UUID: \" + uuid1 + \", Effect Level: \" + effectData.getAmplifier() +\r\n                            \", Duration: \" + effectData.getTime() + \", Task ID \" + effectData.getTaskId());\r\n                }\r\n                ScheduledExecuteTask newTask = buildEffectTask(taskID,entity, (double) durationTime / 1000,amplifier);\r\n                newTask.start();\r\n                System.out.println(\"计划任务异常！已创建新的计划任务\");\r\n                ImmortalersDelightMod.LOGGER.info(\"计划任务异常！已创建新的计划任务\");\r\n            }\r\n        }\r\n    }\r\n    public static void DoOnTick (LivingEntity entity, Long durationTime, int amplifier, int taskID, UUID uuid, Long expireTime) {\r\n        int durationTicks = (int) (durationTime * 20);\r\n        /*\r\n        这是能解不能续的实现，其原理为如果断Effect则解除Buff状态\r\n        由于Task本身就是为了独立的持续时间而生，所以默认就是不能续的，只需要写一个解buff就好\r\n         */\r\n//        if (!entity.hasEffect(ImmortalersDelightMobEffect.GAS_POISON.get())) {\r\n//            removeImmortalEffect(entity);\r\n//        }\r\n        /*\r\n        这是能续不能解的实现，其原理为如果Map内的实体没有对应Effect则一直给他补充Effect，使不能解除\r\n        而如果有，则会在Effect和Buff状态的持续时间取其大来更新Map的记录，使续药水效果可以作用于Buff状态\r\n         */\r\n        if (!entity.hasEffect(ImmortalersDelightMobEffect.GAS_POISON.get())) {\r\n            ImmortalersDelightMod.LOGGER.info(\"effect被解除，正在刷新effect！\");\r\n            MobEffectInstance newOne = new MobEffectInstance(ImmortalersDelightMobEffect.GAS_POISON.get(),durationTicks ,amplifier);\r\n            entity.addEffect(newOne);\r\n            return;\r\n        }\r\n        int lv = Objects.requireNonNull(entity.getEffect(ImmortalersDelightMobEffect.GAS_POISON.get())).getAmplifier();\r\n        int time = Objects.requireNonNull(entity.getEffect(ImmortalersDelightMobEffect.GAS_POISON.get())).getDuration();\r\n        ImmortalersDelightMod.LOGGER.info(\"目前的Effect时间是：\" + time);\r\n        ImmortalersDelightMod.LOGGER.info(\"目前的Effect等级是：\" + lv);\r\n        ImmortalersDelightMod.LOGGER.info(\"目前的Buff时间是：\" + durationTicks);\r\n        ImmortalersDelightMod.LOGGER.info(\"目前的Buff等级是：\" + amplifier);\r\n        ImmortalersDelightMod.LOGGER.info(\"目前的时间差是：\" + (time - durationTicks <= 0 ? -(time - durationTicks) : time - durationTicks));\r\n        if (lv > amplifier || (time - durationTicks <= 0 ? -(time - durationTicks) : time - durationTicks) > 50) {\r\n            ImmortalersDelightMod.LOGGER.info(\"Buff被续，即将更新Map\");\r\n            Long maxTime = time > durationTicks ? TimekeepingTask.getImmortalTickTime() + time*50 : expireTime;\r\n            int maxAmplifier = lv > amplifier ? lv : amplifier;\r\n            EffectData effectData = new EffectData(entity.blockPosition(), maxTime, maxAmplifier, taskID);\r\n            entityHasEffect.put(uuid,effectData);\r\n        }\r\n    }\r\n    /**\r\n     * 用于去除指定实体的特殊效果的方法\r\n     * @param entity\r\n     */\r\n    public static void removeImmortalEffect(LivingEntity entity) {\r\n        UUID uuid = entity.getUUID();\r\n        onImmortalEffectRemove(entity);\r\n        entityHasEffect.remove(uuid);\r\n    }\r\n    /**\r\n     * 用于去除指定实体的特殊效果时进行善后的方法\r\n     * @param entity\r\n     */\r\n    private static void onImmortalEffectRemove (LivingEntity entity) {\r\n        if (entity == null || entity.isRemoved()) {\r\n            return;\r\n        }\r\n        UUID uuid = entity.getUUID();\r\n        /*\r\n        在这里处理一些善后工作，这不是药水效果所以要记得手动善后\r\n         */\r\n        entity.removeEffect(ImmortalersDelightMobEffect.GAS_POISON.get());\r\n        if (entityHasEffect.get(uuid) == null) {return;}\r\n        Integer taskID = entityHasEffect.get(uuid).getTaskId();\r\n        ScheduledExecuteTask task = GasPoisonEffectTask.getTaskFromID(taskID);\r\n        if (task != null) {\r\n            task.stop();\r\n            task.cancel();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 监听世界加载事件，将存盘的实体Map读取出来\r\n     * @param event\r\n     */\r\n    @SubscribeEvent\r\n    public static void onWorldLoad(LevelEvent.Load event) {\r\n        if (event.getLevel() instanceof ServerLevel serverLevel) {\r\n            LoadEntityMap(serverLevel);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 这个方法用于修正时序以及从存盘数据中加载退出时的实体数据\r\n     * @param serverLevel\r\n     */\r\n    private static void LoadEntityMap(Level serverLevel) {\r\n\r\n        ImmortalersDelightMod.LOGGER.info(\"正在读取存盘的Effect实体Map\");\r\n        Map<UUID, EffectData> oldMap = GasPoisonMapSaveLoadHelper.loadEntityHasEffect(serverLevel);\r\n        if (oldMap == null) {\r\n            ImmortalersDelightMod.LOGGER.info(\"存盘表为null！\");\r\n            pausing = false;\r\n            return;\r\n        }\r\n        //entityHasEffect = new ConcurrentHashMap<>();\r\n            /*\r\n            遍历存盘的Map，将存盘的Map数据同步到新Map\r\n             */\r\n        for (Map.Entry<UUID, EffectData> entry : oldMap.entrySet()) {\r\n            UUID uuidOld = entry.getKey();\r\n            EffectData dataOld = entry.getValue();\r\n            /*\r\n            修正时刻，存盘的Map里存的时间理论上为[上次关服时间 + 剩余持续时间]，因此减去一个上次关服时间再加上当前时间即可保持持续时间不变\r\n             */\r\n            Long trueTime = dataOld.getTime() - ExitTimeSaveLoadHelper.loadExitTime(serverLevel) + TimekeepingTask.getImmortalTickTime();\r\n            EffectData newOne = new EffectData(dataOld, trueTime, dataOld.getAmplifier(), dataOld.getTaskId());\r\n            entityHasEffect.put(uuidOld,newOne);\r\n        }\r\n        ImmortalersDelightMod.LOGGER.info(\"存盘Map读取完毕，当前Effect实体Map为：\");\r\n        pausing = false;\r\n        // 输出读取到的 Map\r\n        for (Map.Entry<UUID, EffectData> entry : entityHasEffect.entrySet()) {\r\n            UUID uuid = entry.getKey();\r\n            EffectData effectData = entry.getValue();\r\n            ImmortalersDelightMod.LOGGER.info(\"UUID: \" + uuid + \", Effect Level: \" + effectData.getAmplifier() +\r\n                    \", Duration: \" + effectData.getTime() + \", Task ID \" + effectData.getTaskId());\r\n        }\r\n    }\r\n    /**\r\n     * 用于构建新的计划任务的方法\r\n     * @param id\r\n     * @param pLivingEntity\r\n     * @param durationSeconds\r\n     * @param amplifier\r\n     * @return\r\n     */\r\n    public static ScheduledExecuteTask buildEffectTask(int id, LivingEntity pLivingEntity, double durationSeconds, int amplifier) {\r\n\r\n        GasPoisonEffectTask task = new GasPoisonEffectTask(1,1,id,pLivingEntity, (long) durationSeconds,amplifier);\r\n        task.start();\r\n        return task;\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/GasPoisonEffect.java b/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/GasPoisonEffect.java
--- a/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/GasPoisonEffect.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/GasPoisonEffect.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.potion.immortaleffects;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;
 import com.renyigesai.immortalers_delight.util.datautil.EffectData;
 import com.renyigesai.immortalers_delight.util.datautil.datasaveloadhelper.GasPoisonMapSaveLoadHelper;
Index: src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/MagicalReverseEffect.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.potion.immortaleffects;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.util.datautil.EffectData;\r\nimport com.renyigesai.immortalers_delight.util.task.TimekeepingTask;\r\nimport com.renyigesai.immortalers_delight.util.datautil.datasaveloadhelper.ExitTimeSaveLoadHelper;\r\nimport com.renyigesai.immortalers_delight.util.datautil.datasaveloadhelper.MagicalReverseMapSaveLoadHelper;\r\nimport com.renyigesai.immortalers_delight.util.task.ScheduledExecuteTask;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport net.minecraft.world.entity.LivingEntity;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraftforge.event.entity.living.LivingEvent;\r\nimport net.minecraftforge.event.level.LevelEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\nimport java.util.*;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\n\r\n@Mod.EventBusSubscriber\r\npublic class MagicalReverseEffect {\r\n    /*\r\n    这个类能对实体进行标记（以及解除标记），\r\n     */\r\n    /*\r\n    用Map存储受到当前效果的实体与对应的持续时间（表示为结束时刻）\r\n     */\r\n    private static final Map<UUID, EffectData> entityHasEffect = new ConcurrentHashMap<>();\r\n    private static boolean pausing = true;\r\n    public static void setPausing(boolean pFirst) {\r\n        pausing = pFirst;\r\n    }\r\n    /**\r\n     * 定义内部静态类 EffectData，用于存储实体所在位置和药水的效果等信息，继承自 BlockPos\r\n     */\r\n\r\n    public static Map<UUID, EffectData> getEntityMap() {\r\n        return entityHasEffect;\r\n    }\r\n\r\n//    public static void setEntityMap(Map<UUID, Long> pEntityMap) {\r\n//        timeToEntity.\r\n//    }\r\n\r\n    /**\r\n     * 对指定的生物实体应用特殊效果，输入实体与持续时间（秒）\r\n     * @param entity\r\n     * @param durationSeconds\r\n     */\r\n    public static void applyImmortalEffect(LivingEntity entity, double durationSeconds, int amplifier) {\r\n        /*\r\n        判断合理的实体目标\r\n         */\r\n        if (entity == null || entity.isRemoved()) {\r\n            return;\r\n        }\r\n\r\n        /*\r\n        获取实体UUID以唯一标记对应实体\r\n         */\r\n        UUID uuid = entity.getUUID();\r\n        /*\r\n        计算效果的结束时刻，使用系统时以绕开tick相关操作\r\n         */\r\n        long expireTime = TimekeepingTask.getImmortalTickTime() + (long) (durationSeconds * 1000);\r\n        int durationTicks = (int) (durationSeconds * 20);\r\n\r\n        /*\r\n        构造新的计划任务，在其中执行buff的逻辑\r\n         */\r\n        int taskID = new Random().nextInt(Short.MAX_VALUE);\r\n        ScheduledExecuteTask task = buildEffectTask(taskID,entity,durationSeconds,amplifier);\r\n        task.start();\r\n        /*\r\n        将实体与Buff相关数据保存到Map\r\n         */\r\n        EffectData effectData = new EffectData(entity.blockPosition(),expireTime,amplifier,taskID);\r\n        entityHasEffect.put(uuid,effectData);\r\n        System.out.println(\"应用了 \" + durationSeconds + \" 秒的特殊效果在实体 \" + uuid + \" 上\");\r\n        ImmortalersDelightMod.LOGGER.info(\"应用了 \" + durationSeconds + \" 秒的特殊效果在实体 \" + uuid + \" 上\");\r\n//        if (!entity.level().isClientSide()) {\r\n//            MagicalReverseMapSaveLoadHelper.saveEntityHasEffect(entity.level(), entityHasEffect);\r\n//        }\r\n    }\r\n\r\n    /**\r\n     * 在生物的tick事件处理效果的逻辑\r\n     * @param event\r\n     */\r\n    @SubscribeEvent\r\n    public static void onTick(LivingEvent.LivingTickEvent event) {\r\n        /*\r\n        判断是否触发了暂停，由于\r\n        又因为暂停时会触发WorldSave但解除暂停不会触发WorldLoad，因此在这里再触发一次读取实体Map\r\n         */\r\n        if (pausing && !event.getEntity().level().isClientSide){\r\n            LoadEntityMap(event.getEntity().level());\r\n        }\r\n\r\n        LivingEntity entity = event.getEntity();\r\n        if (entity == null || entity.isRemoved() || !entity.isAlive()) {\r\n            return;\r\n        }\r\n\r\n        /*\r\n        获取当前实体的效果结束时刻\r\n         */\r\n        UUID uuid = entity.getUUID();\r\n        if (entityHasEffect.get(uuid) == null) {\r\n            return;\r\n        }\r\n        Long expireTime = entityHasEffect.get(uuid).getTime();\r\n\r\n        /*\r\n        如果当前系统时间超过了结束时刻，取消效果（将实体从Map中移除，取消计划任务）\r\n         */\r\n//        ImmortalersDelightMod.LOGGER.info(\"你这B玩意还有多久结束？\" + (expireTime - TimekeepingTask.getImmortalTickTime()) / 1000 + \"秒\");\r\n//        ImmortalersDelightMod.LOGGER.info(\"附一个现在的时间\" + TimekeepingTask.getImmortalTickTime());\r\n        if (TimekeepingTask.getImmortalTickTime() > expireTime) {\r\n            removeImmortalEffect(entity);\r\n        } else {\r\n            /*\r\n            此处为具体的效果方法逻辑\r\n            此处的处理为如果没找到实体对应的计划任务（例如退出重进导致计划任务丢失），补一个新的计划任务\r\n             */\r\n            Integer taskID = entityHasEffect.get(uuid).getTaskId();\r\n            ScheduledExecuteTask task = MagicalReverseEffectTask.getTaskFromID(taskID);\r\n            // 输出读取到的 Map\r\n\r\n            if (task == null) {\r\n//                ImmortalersDelightMod.LOGGER.info(\"WTF怎么没找到计划任务？让我看看现在的实体表是什么玩意\");\r\n//                for (Map.Entry<UUID, EffectData> entry : entityHasEffect.entrySet()) {\r\n//                    UUID uuid1 = entry.getKey();\r\n//                    EffectData effectData = entry.getValue();\r\n//                    ImmortalersDelightMod.LOGGER.info(\"UUID: \" + uuid1 + \", Effect Level: \" + effectData.getAmplifier() +\r\n//                            \", Duration: \" + effectData.getTime() + \", Task ID \" + effectData.getTaskId());\r\n//                }\r\n\r\n                Long durationTime = expireTime - TimekeepingTask.getImmortalTickTime();\r\n//                ImmortalersDelightMod.LOGGER.info(\"你这B玩意还有多久结束？\" + durationTime);\r\n                ScheduledExecuteTask newTask = buildEffectTask(taskID,entity,durationTime,entityHasEffect.get(uuid).getAmplifier());\r\n                newTask.start();\r\n//                System.out.println(\"计划任务异常！已创建新的计划任务\");\r\n//                ImmortalersDelightMod.LOGGER.info(\"计划任务异常！已创建新的计划任务\");\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 用于去除指定实体的特殊效果的方法\r\n     * @param entity\r\n     */\r\n    public static void removeImmortalEffect(LivingEntity entity) {\r\n        UUID uuid = entity.getUUID();\r\n        onImmortalEffectRemove(entity);\r\n        entityHasEffect.remove(uuid);\r\n        System.out.println(\"已将实体\" + uuid + \"从携带者列表中移除\");\r\n        ImmortalersDelightMod.LOGGER.info(\"已将实体\" + uuid + \"从携带者列表中移除\");\r\n//        if (!entity.level().isClientSide()) {\r\n//            MagicalReverseMapSaveLoadHelper.saveEntityHasEffect(entity.level(), entityHasEffect);\r\n//        }\r\n    }\r\n    /**\r\n     * 用于去除指定实体的特殊效果时进行善后的方法\r\n     * @param entity\r\n     */\r\n    private static void onImmortalEffectRemove (LivingEntity entity) {\r\n        if (entity == null || entity.isRemoved()) {\r\n            return;\r\n        }\r\n\r\n        UUID uuid = entity.getUUID();\r\n        System.out.println(\"实体 \" + uuid + \" 解除了特殊效果\");\r\n        ImmortalersDelightMod.LOGGER.info(\"实体 \" + uuid + \" 解除了特殊效果\");\r\n        /*\r\n        在这里处理一些善后工作，这不是药水效果所以要记得手动善后\r\n         */\r\n        if (entityHasEffect.get(uuid) == null) {return;}\r\n        Integer taskID = entityHasEffect.get(uuid).getTaskId();\r\n        ScheduledExecuteTask task = MagicalReverseEffectTask.getTaskFromID(taskID);\r\n        if (task != null) {\r\n            task.cancel();\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * 监听世界保存事件，将实体Map存盘\r\n     * @param event\r\n     */\r\n    @SubscribeEvent\r\n    public static void onWorldLoad(LevelEvent.Load event) {\r\n        if (event.getLevel() instanceof ServerLevel serverLevel) {\r\n            LoadEntityMap(serverLevel);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 这个方法用于修正时序以及从存盘数据中加载退出时的实体数据\r\n     * @param serverLevel\r\n     */\r\n    private static void LoadEntityMap(Level serverLevel) {\r\n\r\n        ImmortalersDelightMod.LOGGER.info(\"正在读取存盘的Effect实体Map\");\r\n        Map<UUID, EffectData> oldMap = MagicalReverseMapSaveLoadHelper.loadEntityHasEffect(serverLevel);\r\n        if (oldMap == null) {\r\n            ImmortalersDelightMod.LOGGER.info(\"存盘表为null！\");\r\n            pausing = false;\r\n            return;\r\n        }\r\n        //entityHasEffect = new ConcurrentHashMap<>();\r\n            /*\r\n            遍历存盘的Map，将存盘的Map数据同步到新Map\r\n             */\r\n        for (Map.Entry<UUID, EffectData> entry : oldMap.entrySet()) {\r\n            UUID uuidOld = entry.getKey();\r\n            EffectData dataOld = entry.getValue();\r\n            /*\r\n            修正时刻，存盘的Map里存的时间理论上为[上次关服时间 + 剩余持续时间]，因此减去一个上次关服时间再加上当前时间即可保持持续时间不变\r\n             */\r\n            Long trueTime = dataOld.getTime() - ExitTimeSaveLoadHelper.loadExitTime(serverLevel) + TimekeepingTask.getImmortalTickTime();\r\n            EffectData newOne = new EffectData(dataOld, trueTime, dataOld.getAmplifier(), dataOld.getTaskId());\r\n            entityHasEffect.put(uuidOld,newOne);\r\n        }\r\n        ImmortalersDelightMod.LOGGER.info(\"存盘Map读取完毕，当前Effect实体Map为：\");\r\n        pausing = false;\r\n        // 输出读取到的 Map\r\n        for (Map.Entry<UUID, EffectData> entry : entityHasEffect.entrySet()) {\r\n            UUID uuid = entry.getKey();\r\n            EffectData effectData = entry.getValue();\r\n            ImmortalersDelightMod.LOGGER.info(\"UUID: \" + uuid + \", Effect Level: \" + effectData.getAmplifier() +\r\n                    \", Duration: \" + effectData.getTime() + \", Task ID \" + effectData.getTaskId());\r\n        }\r\n    }\r\n    /**\r\n     * 用于构建新的计划任务的方法\r\n     * @param id\r\n     * @param pLivingEntity\r\n     * @param durationSeconds\r\n     * @param amplifier\r\n     * @return\r\n     */\r\n    public static ScheduledExecuteTask buildEffectTask(int id, LivingEntity pLivingEntity, double durationSeconds, int amplifier) {\r\n\r\n        MagicalReverseEffectTask task = new MagicalReverseEffectTask(1,1,id,pLivingEntity, (long) durationSeconds,amplifier);\r\n        task.start();\r\n        return task;\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/MagicalReverseEffect.java b/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/MagicalReverseEffect.java
--- a/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/MagicalReverseEffect.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/MagicalReverseEffect.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.potion.immortaleffects;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.util.datautil.EffectData;
 import com.renyigesai.immortalers_delight.util.task.TimekeepingTask;
 import com.renyigesai.immortalers_delight.util.datautil.datasaveloadhelper.ExitTimeSaveLoadHelper;
Index: src/main/java/com/renyigesai/immortalers_delight/world/feature/ModConfigureFeature.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.world.feature;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport net.minecraft.core.registries.Registries;\r\nimport net.minecraft.data.worldgen.BootstapContext;\r\nimport net.minecraft.resources.ResourceKey;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.tags.BlockTags;\r\nimport net.minecraft.util.valueproviders.ConstantInt;\r\nimport net.minecraft.world.level.block.Blocks;\r\nimport net.minecraft.world.level.levelgen.feature.ConfiguredFeature;\r\nimport net.minecraft.world.level.levelgen.feature.Feature;\r\nimport net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration;\r\nimport net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration;\r\nimport net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration;\r\nimport net.minecraft.world.level.levelgen.feature.featuresize.TwoLayersFeatureSize;\r\nimport net.minecraft.world.level.levelgen.feature.foliageplacers.BlobFoliagePlacer;\r\nimport net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider;\r\nimport net.minecraft.world.level.levelgen.feature.trunkplacers.StraightTrunkPlacer;\r\nimport net.minecraft.world.level.levelgen.structure.templatesystem.BlockMatchTest;\r\nimport net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest;\r\nimport net.minecraft.world.level.levelgen.structure.templatesystem.TagMatchTest;\r\n\r\nimport java.util.List;\r\n\r\nimport static com.renyigesai.immortalers_delight.init.ImmortalersDelightBlocks.HIMEKAIDO_LEAVES;\r\nimport static com.renyigesai.immortalers_delight.init.ImmortalersDelightBlocks.HIMEKAIDO_LOG;\r\n\r\npublic class ModConfigureFeature {\r\n    /**\r\n     * 声明Key，在注册中将使用\r\n     */\r\n    public static final ResourceKey<ConfiguredFeature<?,?>> SUSPICIOUS_DIRT_COF = registerKey(\"suspicious_dirt_cof\");\r\n    public static final ResourceKey<ConfiguredFeature<?,?>> SUSPICIOUS_SOUL_SAND_COF = registerKey(\"suspicious_soul_sand_cof\");\r\n    public static final ResourceKey<ConfiguredFeature<?,?>> END_ORE_COF = registerKey(\"end_ore_cof\");\r\n\r\n\r\n    public static final ResourceKey<ConfiguredFeature<?,?>> OAK_LIKE_TREE_KEY = registerKey(\"end_ore_cof\");\r\n\r\n    /**\r\n     * 注册使用的主方法，实际矿物规则的注册在此处进行，这个方法应在Init或主类进行调用\r\n     * @param context\r\n     */\r\n    public static void bootrap(BootstapContext<ConfiguredFeature<?,?>> context) {\r\n        /*\r\n        声明替换规则，即指出可被替换的方块\r\n         */\r\n        RuleTest sandReplaceables = new TagMatchTest(BlockTags.SMELTS_TO_GLASS);\r\n        RuleTest dirtReplaceables = new TagMatchTest(BlockTags.DIRT);\r\n        RuleTest soulSandReplaceables = new TagMatchTest(BlockTags.SOUL_FIRE_BASE_BLOCKS);\r\n        RuleTest endReplaceables = new BlockMatchTest(Blocks.END_STONE);\r\n\r\n        /*\r\n        您可以用List将多个规则打包，以在不同方块中生成相同甚至不同种矿物，可以发现我们在此处已经指定需要生成的方块，因此这将对应双参数OreConfiguration\r\n         */\r\n        List<OreConfiguration.TargetBlockState> suspiciousDirt = List.of(\r\n                OreConfiguration.target(dirtReplaceables, Blocks.STONE.defaultBlockState()),\r\n                OreConfiguration.target(sandReplaceables, Blocks.SUSPICIOUS_SAND.defaultBlockState())\r\n        );\r\n        /*\r\n        使用双参数OreConfiguration注册方法，参考前文，配合List打包的规则使用，第二行的参数分别为\r\n        打包的OreList，矿脉规模\r\n         */\r\n        register(context, SUSPICIOUS_DIRT_COF, Feature.ORE, new OreConfiguration(\r\n                suspiciousDirt, 1\r\n        ));\r\n        /*\r\n        使用三参数OreConfiguration的注册方法，第二行的参数分别为\r\n        替换规则RuleTest，将生成的方块的BlockState，矿脉规模\r\n         */\r\n        register(context, SUSPICIOUS_SOUL_SAND_COF, Feature.ORE, new OreConfiguration(\r\n                soulSandReplaceables, Blocks.SOUL_SAND.defaultBlockState(), 2));\r\n\r\n        register(context, END_ORE_COF, Feature.ORE, new OreConfiguration(\r\n                endReplaceables, Blocks.END_STONE_BRICK_WALL.defaultBlockState(), 2));\r\n\r\n        /*\r\n        树的世界生成\r\n         */\r\n        register(context, OAK_LIKE_TREE_KEY, Feature.TREE, new TreeConfiguration.TreeConfigurationBuilder(\r\n                /*\r\n                确定树干方块，随后是树干放置器。其参数为基础高度+随机额外高度1+随机额外高度2\r\n                 */\r\n                BlockStateProvider.simple(HIMEKAIDO_LOG.get()),\r\n                new StraightTrunkPlacer(5,6,3),\r\n                /*\r\n                确定树叶方块，随后是树叶放置器（半圆形放置器），即金合欢或大丛林树的树冠\r\n                 */\r\n                BlockStateProvider.simple(HIMEKAIDO_LEAVES.get()),\r\n                new BlobFoliagePlacer(ConstantInt.of(2), ConstantInt.of(0), 4),\r\n                /*\r\n                对于树生长条件的检测器\r\n                 */\r\n                new TwoLayersFeatureSize(1,0,2)\r\n        ).build());\r\n    }\r\n\r\n    /**\r\n     * 我们在最顶部注册Key时使用的方法\r\n     * @param name\r\n     * @return\r\n     */\r\n    public static ResourceKey<ConfiguredFeature<?,?>> registerKey(String name) {\r\n        return ResourceKey.create(Registries.CONFIGURED_FEATURE, new ResourceLocation(ImmortalersDelightMod.MODID, name));\r\n    }\r\n\r\n    /**\r\n     * 四参注册机，\r\n     * @param context\r\n     * @param key\r\n     * 即为在最顶部注册的ResourceKey\r\n     * @param feature\r\n     * 生成阶段，如生成矿物使用Feature.ORE\r\n     * @param configuration\r\n     * 可以理解为矿物的生成方式，包含了“将被替换的方块”，“将生成的方块”，“矿脉规模”\r\n     * @param <FC>\r\n     * @param <F>\r\n     */\r\n    private static <FC extends FeatureConfiguration, F extends Feature<FC>> void register(\r\n            BootstapContext<ConfiguredFeature<?,?>> context, ResourceKey<ConfiguredFeature<?,?>> key, F feature, FC configuration) {\r\n        context.register(key, new ConfiguredFeature<>(feature, configuration));\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/world/feature/ModConfigureFeature.java b/src/main/java/com/renyigesai/immortalers_delight/world/feature/ModConfigureFeature.java
--- a/src/main/java/com/renyigesai/immortalers_delight/world/feature/ModConfigureFeature.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/world/feature/ModConfigureFeature.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.world.feature;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.data.worldgen.BootstapContext;
 import net.minecraft.resources.ResourceKey;
Index: src/main/java/com/renyigesai/immortalers_delight/item/GasToxicFoodItem.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.item;\r\n\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;\r\nimport com.renyigesai.immortalers_delight.potion.immortaleffects.GasPoisonEffect;\r\nimport net.minecraft.world.effect.MobEffectInstance;\r\nimport net.minecraft.world.entity.LivingEntity;\r\nimport net.minecraft.world.item.Item;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.level.Level;\r\nimport com.mojang.datafixers.util.Pair;\r\n\r\npublic class GasToxicFoodItem extends EnchantAbleFoodItem {\r\n    public GasToxicFoodItem(Properties properties, boolean hasFoodEffectTooltip, boolean hasCustomTooltip) {\r\n        super(properties,hasFoodEffectTooltip,hasCustomTooltip);\r\n    }\r\n    public GasToxicFoodItem(Properties properties, boolean hasFoodEffectTooltip, boolean hasCustomTooltip, boolean isFoil) {\r\n        super(properties,hasFoodEffectTooltip,hasCustomTooltip,isFoil);\r\n    }\r\n    @Override\r\n    public ItemStack finishUsingItem (ItemStack pStack, Level level, LivingEntity pLivingEntity) {\r\n        addGasPoisonEffect(pStack,level,pLivingEntity);\r\n        return super.finishUsingItem(pStack,level,pLivingEntity);\r\n    }\r\n    /**\r\n     * 该方法用于处理实体食用物品后添加对应的药水效果。\r\n     * 当实体食用某个可食用物品时，会根据物品的属性尝试为实体添加相应的药水效果。\r\n     *\r\n     * @param p_21064_ 被食用的物品栈，包含了具体的物品及其数量等信息。\r\n     * @param p_21065_ 实体所在的游戏世界，用于判断是否为客户端，以及获取随机数生成器。\r\n     * @param p_21066_ 食用物品的实体，即要添加药水效果的对象。\r\n     */\r\n    private void addGasPoisonEffect(ItemStack p_21064_, Level p_21065_, LivingEntity p_21066_) {\r\n        // 从物品栈中获取具体的物品\r\n        Item item = p_21064_.getItem();\r\n        // 检查该物品是否为可食用物品\r\n        if (item.isEdible()) {\r\n            // 遍历物品的食物属性中定义的所有药水效果及其概率\r\n            for (Pair<MobEffectInstance, Float> pair : p_21064_.getFoodProperties(p_21066_).getEffects()) {\r\n                // 条件判断：\r\n                // 1. 当前不是客户端，因为药水效果的添加通常在服务器端处理，以保证数据一致性。\r\n                // 2. 药水效果实例不为空，确保有有效的药水效果。\r\n                // 3. 药水效果为我们指定的瓦斯毒效果\r\n                if (!p_21065_.isClientSide && pair.getFirst() != null && pair.getFirst().getEffect() == ImmortalersDelightMobEffect.GAS_POISON.get()) {\r\n                    // 创建一个新的药水效果实例，使用原有的药水效果实例作为模板。\r\n                    // 然后将该药水效果添加到食用物品的实体上。\r\n                    p_21066_.addEffect(new MobEffectInstance(pair.getFirst()));\r\n                    double time = (double) pair.getFirst().getDuration() / 20;\r\n                    int lv = pair.getFirst().getAmplifier();\r\n                    GasPoisonEffect.applyImmortalEffect(p_21066_,time + 0.1,lv);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/item/GasToxicFoodItem.java b/src/main/java/com/renyigesai/immortalers_delight/item/GasToxicFoodItem.java
--- a/src/main/java/com/renyigesai/immortalers_delight/item/GasToxicFoodItem.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/item/GasToxicFoodItem.java	
@@ -3,6 +3,7 @@
 import com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;
 import com.renyigesai.immortalers_delight.potion.immortaleffects.GasPoisonEffect;
 import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.effect.MobEffects;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
@@ -19,6 +20,7 @@
     @Override
     public ItemStack finishUsingItem (ItemStack pStack, Level level, LivingEntity pLivingEntity) {
         addGasPoisonEffect(pStack,level,pLivingEntity);
+        //pLivingEntity.addEffect(new MobEffectInstance(MobEffects.LEVITATION, 1,99));
         return super.finishUsingItem(pStack,level,pLivingEntity);
     }
     /**
Index: src/main/java/com/renyigesai/immortalers_delight/world/feature/ModPlacedFeature.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.world.feature;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport net.minecraft.core.Holder;\r\nimport net.minecraft.core.HolderGetter;\r\nimport net.minecraft.core.registries.Registries;\r\nimport net.minecraft.data.worldgen.BootstapContext;\r\nimport net.minecraft.data.worldgen.placement.PlacementUtils;\r\nimport net.minecraft.resources.ResourceKey;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.level.levelgen.VerticalAnchor;\r\nimport net.minecraft.world.level.levelgen.feature.ConfiguredFeature;\r\nimport net.minecraft.world.level.levelgen.placement.HeightRangePlacement;\r\nimport net.minecraft.world.level.levelgen.placement.PlacedFeature;\r\nimport net.minecraft.world.level.levelgen.placement.PlacementModifier;\r\n\r\nimport java.util.List;\r\n\r\nimport static net.minecraft.data.worldgen.placement.PlacementUtils.RANGE_8_8;\r\n\r\npublic class ModPlacedFeature {\r\n    public static final ResourceKey<PlacedFeature> SUSPICIOUS_DIRT_PLACED = createKey(\"suspicious_dirt_placed\");\r\n    public static final ResourceKey<PlacedFeature> SUSPICIOUS_SOUL_SAND_PLACED = createKey(\"suspicious_soul_sand_placed\");\r\n    public static final ResourceKey<PlacedFeature> END_ORE_PLACED = createKey(\"end_ore_placed\");\r\n    /**\r\n     * 注册使用的主方法，实际矿物生成器的注册在此处进行，这个方法应在Init或主类进行调用\r\n     * @param context\r\n     */\r\n    public static void bootstrap(BootstapContext<PlacedFeature> context) {\r\n        HolderGetter<ConfiguredFeature<?,?>> configuredFeatures = context.lookup(Registries.CONFIGURED_FEATURE);\r\n\r\n        /*\r\n        在此处联系COF与PLACED，并传入放置方法以最终注册矿物放置器\r\n        commonOrePlacement为矿物放置的方法，其参数按顺序为：\r\n        每区块生成的尝试次数\r\n        高度分布的描述，.uniform为平均分布\r\n        最低生成高度，可以处在世界外\r\n        最高生成高度，也可以处在世界外\r\n         */\r\n        register(context,\r\n                SUSPICIOUS_DIRT_PLACED,\r\n                configuredFeatures.getOrThrow(ModConfigureFeature.SUSPICIOUS_DIRT_COF),\r\n                ModOrePlacement.commonOrePlacement(2,\r\n                        HeightRangePlacement.uniform(\r\n                        VerticalAnchor.absolute(56),\r\n                        VerticalAnchor.absolute(88)\r\n                        )\r\n                )\r\n        );\r\n        /*\r\n        commonOrePlacement为矿物放置的方法，其参数按顺序为：\r\n        每区块生成的尝试次数\r\n        高度分布的描述，此处使用PlacementUtils封装好的方法，该目录下还有其他方法可选\r\n         */\r\n        register(context,\r\n                SUSPICIOUS_SOUL_SAND_PLACED,\r\n                configuredFeatures.getOrThrow(ModConfigureFeature.SUSPICIOUS_SOUL_SAND_COF),\r\n                ModOrePlacement.commonOrePlacement(3,\r\n                        PlacementUtils.RANGE_8_8\r\n                )\r\n        );\r\n        /*\r\n        commonOrePlacement为矿物放置的方法，其参数按顺序为：\r\n        每区块生成的尝试次数\r\n        高度分布的描述，.triangle意为“三角分布”，即中间高度生成概率最大\r\n        最低生成高度，可以处在世界外\r\n        最高生成高度，也可以处在世界外\r\n         */\r\n        register(context,\r\n                END_ORE_PLACED,\r\n                configuredFeatures.getOrThrow(ModConfigureFeature.END_ORE_COF),\r\n                ModOrePlacement.commonOrePlacement(9,\r\n                        HeightRangePlacement.triangle(\r\n                                VerticalAnchor.absolute(-11),\r\n                                VerticalAnchor.absolute(96)\r\n                        )\r\n                )\r\n        );\r\n    }\r\n    private static ResourceKey<PlacedFeature> createKey(String name) {\r\n        return ResourceKey.create(Registries.PLACED_FEATURE, new ResourceLocation(ImmortalersDelightMod.MODID, name));\r\n    }\r\n\r\n    private static void register(BootstapContext<PlacedFeature> context,\r\n                                 ResourceKey<PlacedFeature> key,\r\n                                 Holder<ConfiguredFeature<?,?>> configuredFeature,\r\n                                 List<PlacementModifier> modifiers) {\r\n        context.register(key, new PlacedFeature(configuredFeature, List.copyOf(modifiers)));\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/world/feature/ModPlacedFeature.java b/src/main/java/com/renyigesai/immortalers_delight/world/feature/ModPlacedFeature.java
--- a/src/main/java/com/renyigesai/immortalers_delight/world/feature/ModPlacedFeature.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/world/feature/ModPlacedFeature.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.world.feature;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import net.minecraft.core.Holder;
 import net.minecraft.core.HolderGetter;
 import net.minecraft.core.registries.Registries;
@@ -16,8 +16,6 @@
 
 import java.util.List;
 
-import static net.minecraft.data.worldgen.placement.PlacementUtils.RANGE_8_8;
-
 public class ModPlacedFeature {
     public static final ResourceKey<PlacedFeature> SUSPICIOUS_DIRT_PLACED = createKey("suspicious_dirt_placed");
     public static final ResourceKey<PlacedFeature> SUSPICIOUS_SOUL_SAND_PLACED = createKey("suspicious_soul_sand_placed");
Index: src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/BaseImmortalWorldData.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.util.datautil.worlddata;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.util.datautil.datastorage.BaseImmortalDataStorage;\r\nimport net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport net.minecraft.world.level.saveddata.SavedData;\r\nimport net.minecraft.world.level.storage.DimensionDataStorage;\r\nimport net.minecraftforge.event.level.LevelEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\n// 自定义世界数据存储管理器类\r\n@Mod.EventBusSubscriber\r\npublic class BaseImmortalWorldData extends SavedData {\r\n    private static final String BASE_IMMORTAL_DATA_NAME = ImmortalersDelightMod.MODID + \"base_immortal_data\";\r\n    // 自定义数据存储实例\r\n    private final BaseImmortalDataStorage customData = new BaseImmortalDataStorage();\r\n    // 数据存储的名称\r\n    private static final String BASE_IMMORTAL_WORLD_DATA_NAME = ImmortalersDelightMod.MODID + \"base_immortal_world_data\";\r\n\r\n    // 构造函数\r\n    public BaseImmortalWorldData() {\r\n    }\r\n\r\n    // 从 NBT 标签加载数据的静态方法\r\n    public static BaseImmortalWorldData load(CompoundTag nbt) {\r\n        BaseImmortalWorldData data = new BaseImmortalWorldData();\r\n        // 从 NBT 标签中读取自定义数据\r\n        data.customData.deserializeNBT(nbt.getCompound(BASE_IMMORTAL_DATA_NAME));\r\n        return data;\r\n    }\r\n\r\n    // 将数据保存到 NBT 标签的方法\r\n    @Override\r\n    public CompoundTag save(CompoundTag nbt) {\r\n        // 将自定义数据写入 NBT 标签\r\n        nbt.put(BASE_IMMORTAL_DATA_NAME, customData.serializeNBT());\r\n        return nbt;\r\n    }\r\n\r\n    // 获取自定义数据存储实例的方法\r\n    public BaseImmortalDataStorage getCustomData() {\r\n        return customData;\r\n    }\r\n\r\n    // 订阅世界加载事件，在此处加载所保存的数据\r\n    @SubscribeEvent\r\n    public static void onWorldLoad(LevelEvent.Load event) {\r\n        if (event.getLevel() instanceof ServerLevel serverLevel) {\r\n            DimensionDataStorage storage = serverLevel.getDataStorage();\r\n            // 获取或创建自定义世界数据实例\r\n            BaseImmortalWorldData data = storage.computeIfAbsent(BaseImmortalWorldData::load, BaseImmortalWorldData::new, BASE_IMMORTAL_WORLD_DATA_NAME);\r\n        }\r\n    }\r\n\r\n    // 获取自定义世界数据实例的静态方法\r\n    public static BaseImmortalWorldData get(ServerLevel level) {\r\n        DimensionDataStorage storage = level.getDataStorage();\r\n        return storage.computeIfAbsent(BaseImmortalWorldData::load, BaseImmortalWorldData::new, BASE_IMMORTAL_WORLD_DATA_NAME);\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/BaseImmortalWorldData.java b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/BaseImmortalWorldData.java
--- a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/BaseImmortalWorldData.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/BaseImmortalWorldData.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.util.datautil.worlddata;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.util.datautil.datastorage.BaseImmortalDataStorage;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.server.level.ServerLevel;
Index: src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/ExitTimeWorldData.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.util.datautil.worlddata;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.util.datautil.datastorage.ExitTimeDataStorage;\r\nimport net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport net.minecraft.world.level.saveddata.SavedData;\r\nimport net.minecraft.world.level.storage.DimensionDataStorage;\r\nimport net.minecraftforge.event.level.LevelEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\n// 自定义世界数据存储管理器类\r\n@Mod.EventBusSubscriber\r\npublic class ExitTimeWorldData extends SavedData {\r\n\r\n    private static final String EXIT_TIME_DATA_NAME = ImmortalersDelightMod.MODID + \"exit_time_data\";\r\n    // 自定义数据存储实例\r\n    private final ExitTimeDataStorage customData = new ExitTimeDataStorage();\r\n    // 数据存储的名称\r\n    private static final String EXIT_TIME_WORLD_DATA_NAME = ImmortalersDelightMod.MODID + \"exit_time_world_data\";\r\n\r\n    // 构造函数\r\n    public ExitTimeWorldData() {\r\n    }\r\n\r\n    // 从 NBT 标签加载数据的静态方法\r\n    public static ExitTimeWorldData load(CompoundTag nbt) {\r\n        ExitTimeWorldData data = new ExitTimeWorldData();\r\n        // 从 NBT 标签中读取自定义数据\r\n        data.customData.deserializeNBT(nbt.getCompound(EXIT_TIME_DATA_NAME));\r\n        return data;\r\n    }\r\n\r\n    // 将数据保存到 NBT 标签的方法\r\n    @Override\r\n    public CompoundTag save(CompoundTag nbt) {\r\n        // 将自定义数据写入 NBT 标签\r\n        nbt.put(EXIT_TIME_DATA_NAME, customData.serializeNBT());\r\n        return nbt;\r\n    }\r\n\r\n    // 获取自定义数据存储实例的方法\r\n    public ExitTimeDataStorage getCustomData() {\r\n        return customData;\r\n    }\r\n\r\n    // 订阅世界加载事件，在此处加载所保存的数据\r\n    @SubscribeEvent\r\n    public static void onWorldLoad(LevelEvent.Load event) {\r\n        if (event.getLevel() instanceof ServerLevel serverLevel) {\r\n            DimensionDataStorage storage = serverLevel.getDataStorage();\r\n            // 获取或创建自定义世界数据实例\r\n            ExitTimeWorldData data = storage.computeIfAbsent(ExitTimeWorldData::load, ExitTimeWorldData::new, EXIT_TIME_WORLD_DATA_NAME);\r\n        }\r\n    }\r\n\r\n    // 获取自定义世界数据实例的静态方法\r\n    public static ExitTimeWorldData get(ServerLevel level) {\r\n        DimensionDataStorage storage = level.getDataStorage();\r\n        return storage.computeIfAbsent(ExitTimeWorldData::load, ExitTimeWorldData::new, EXIT_TIME_WORLD_DATA_NAME);\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/ExitTimeWorldData.java b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/ExitTimeWorldData.java
--- a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/ExitTimeWorldData.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/ExitTimeWorldData.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.util.datautil.worlddata;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.util.datautil.datastorage.ExitTimeDataStorage;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.server.level.ServerLevel;
Index: src/main/java/com/renyigesai/immortalers_delight/block/MetalCaltropBlock.java
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/block/MetalCaltropBlock.java b/src/main/java/com/renyigesai/immortalers_delight/block/MetalCaltropBlock.java
new file mode 100644
--- /dev/null	
+++ b/src/main/java/com/renyigesai/immortalers_delight/block/MetalCaltropBlock.java	
@@ -0,0 +1,583 @@
+package com.renyigesai.immortalers_delight.block;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import java.util.List;
+import java.util.Map;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.sounds.SoundEvents;
+import net.minecraft.sounds.SoundSource;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.context.BlockPlaceContext;
+import net.minecraft.world.level.BlockGetter;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.SignalGetter;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.DirectionalBlock;
+import net.minecraft.world.level.block.Mirror;
+import net.minecraft.world.level.block.Rotation;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.piston.MovingPistonBlock;
+import net.minecraft.world.level.block.piston.PistonHeadBlock;
+import net.minecraft.world.level.block.piston.PistonMovingBlockEntity;
+import net.minecraft.world.level.block.piston.PistonStructureResolver;
+import net.minecraft.world.level.block.state.BlockBehaviour;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.StateDefinition;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import net.minecraft.world.level.block.state.properties.BooleanProperty;
+import net.minecraft.world.level.block.state.properties.PistonType;
+import net.minecraft.world.level.gameevent.GameEvent;
+import net.minecraft.world.level.material.PushReaction;
+import net.minecraft.world.level.pathfinder.PathComputationType;
+import net.minecraft.world.phys.shapes.CollisionContext;
+import net.minecraft.world.phys.shapes.Shapes;
+import net.minecraft.world.phys.shapes.VoxelShape;
+
+/**
+ * 活塞基础方块类，继承自 DirectionalBlock，用于处理活塞方块的行为，包括放置、触发、移动方块等操作。
+ */
+public class MetalCaltropBlock extends DirectionalBlock {
+    // 定义活塞的扩展状态属性，用于表示活塞是否处于扩展状态
+    public static final BooleanProperty EXTENDED = BlockStateProperties.EXTENDED;
+    // 触发活塞扩展的事件编号
+    public static final int TRIGGER_EXTEND = 0;
+    // 触发活塞收缩的事件编号
+    public static final int TRIGGER_CONTRACT = 1;
+    // 触发活塞掉落的事件编号
+    public static final int TRIGGER_DROP = 2;
+    // 活塞平台的厚度
+    public static final float PLATFORM_THICKNESS = 4.0F;
+    // 活塞面向东方时的碰撞形状
+    protected static final VoxelShape EAST_AABB = Block.box(1.0D, 1.0D, 1.0D, 12.0D, 15.0D, 15.0D);
+    // 活塞面向西方时的碰撞形状
+    protected static final VoxelShape WEST_AABB = Block.box(4.0D, 1.0D, 1.0D, 15.0D, 15.0D, 15.0D);
+    // 活塞面向南方时的碰撞形状
+    protected static final VoxelShape SOUTH_AABB = Block.box(1.0D, 1.0D, 1.0D, 15.0D, 15.0D, 12.0D);
+    // 活塞面向北方时的碰撞形状
+    protected static final VoxelShape NORTH_AABB = Block.box(1.0D, 1.0D, 4.0D, 15.0D, 15.0D, 15.0D);
+    // 活塞面向上方时的碰撞形状
+    protected static final VoxelShape UP_AABB = Block.box(1.0D, 1.0D, 1.0D, 15.0D, 12.0D, 15.0D);
+    // 活塞面向下方时的碰撞形状
+    protected static final VoxelShape DOWN_AABB = Block.box(1.0D, 4.0D, 1.0D, 15.0D, 15.0D, 15.0D);
+    // 表示该活塞是否为粘性活塞
+    private final boolean isSticky;
+
+    /**
+     * 构造函数，初始化活塞方块的属性。
+     * @param pIsSticky 是否为粘性活塞
+     * @param pProperties 方块的行为属性
+     */
+    public MetalCaltropBlock(boolean pIsSticky, Properties pProperties) {
+        super(pProperties);
+        // 注册默认的方块状态，包括面向方向和扩展状态
+        this.registerDefaultState(this.stateDefinition.any().setValue(FACING, Direction.NORTH).setValue(EXTENDED, Boolean.valueOf(false)));
+        this.isSticky = pIsSticky;
+    }
+
+    /**
+     * 根据方块状态返回其碰撞形状。
+     * @param pState 方块状态
+     * @param pLevel 方块所在的世界
+     * @param pPos 方块的位置
+     * @param pContext 碰撞上下文
+     * @return 方块的碰撞形状
+     */
+    public VoxelShape getShape(BlockState pState, BlockGetter pLevel, BlockPos pPos, CollisionContext pContext) {
+        if (pState.getValue(EXTENDED)) {
+            // 根据活塞的面向方向返回对应的碰撞形状
+            switch ((Direction)pState.getValue(FACING)) {
+                case DOWN:
+                    return DOWN_AABB;
+                case UP:
+                default:
+                    return UP_AABB;
+                case NORTH:
+                    return NORTH_AABB;
+                case SOUTH:
+                    return SOUTH_AABB;
+                case WEST:
+                    return WEST_AABB;
+                case EAST:
+                    return EAST_AABB;
+            }
+        } else {
+            // 未扩展时返回完整方块的形状
+            return Shapes.block();
+        }
+    }
+
+    /**
+     * 当方块被放置后调用，检查是否需要扩展活塞。
+     * @param pLevel 方块所在的世界
+     * @param pPos 方块的位置
+     * @param pState 方块状态
+     * @param pPlacer 放置方块的实体
+     * @param pStack 放置方块的物品栈
+     */
+    public void setPlacedBy(Level pLevel, BlockPos pPos, BlockState pState, LivingEntity pPlacer, ItemStack pStack) {
+        if (!pLevel.isClientSide) {
+            // 在服务器端检查是否需要扩展活塞
+            this.checkIfExtend(pLevel, pPos, pState);
+        }
+    }
+
+    /**
+     * 当邻居方块发生变化时调用，检查是否需要扩展或收缩活塞。
+     * @param pState 方块状态
+     * @param pLevel 方块所在的世界
+     * @param pPos 方块的位置
+     * @param pBlock 发生变化的邻居方块
+     * @param pFromPos 邻居方块的位置
+     * @param pIsMoving 方块是否正在移动
+     */
+    public void neighborChanged(BlockState pState, Level pLevel, BlockPos pPos, Block pBlock, BlockPos pFromPos, boolean pIsMoving) {
+        if (!pLevel.isClientSide) {
+            // 在服务器端检查是否需要扩展或收缩活塞
+            this.checkIfExtend(pLevel, pPos, pState);
+        }
+    }
+
+    /**
+     * 当方块被放置时调用，检查是否需要扩展活塞。
+     * @param pState 方块状态
+     * @param pLevel 方块所在的世界
+     * @param pPos 方块的位置
+     * @param pOldState 旧的方块状态
+     * @param pIsMoving 方块是否正在移动
+     */
+    public void onPlace(BlockState pState, Level pLevel, BlockPos pPos, BlockState pOldState, boolean pIsMoving) {
+        if (!pOldState.is(pState.getBlock())) {
+            if (!pLevel.isClientSide && pLevel.getBlockEntity(pPos) == null) {
+                // 在服务器端且方块实体为空时检查是否需要扩展活塞
+                this.checkIfExtend(pLevel, pPos, pState);
+            }
+        }
+    }
+
+    /**
+     * 获取方块放置时的状态。
+     * @param pContext 方块放置上下文
+     * @return 方块放置时的状态
+     */
+    public BlockState getStateForPlacement(BlockPlaceContext pContext) {
+        return this.defaultBlockState().setValue(FACING, pContext.getNearestLookingDirection().getOpposite()).setValue(EXTENDED, Boolean.valueOf(false));
+    }
+
+    /**
+     * 检查活塞是否需要扩展或收缩。
+     * @param pLevel 方块所在的世界
+     * @param pPos 方块的位置
+     * @param pState 方块状态
+     */
+    private void checkIfExtend(Level pLevel, BlockPos pPos, BlockState pState) {
+        // 获取活塞的面向方向
+        Direction direction = pState.getValue(FACING);
+        // 检查活塞周围的方块是否提供信号
+        boolean flag = this.getNeighborSignal(pLevel, pPos, direction);
+        if (flag && !pState.getValue(EXTENDED)) {
+            // 如果有信号且活塞未扩展，尝试扩展活塞
+            if ((new PistonStructureResolver(pLevel, pPos, direction, true)).resolve()) {
+                pLevel.blockEvent(pPos, this, 0, direction.get3DDataValue());
+            }
+        } else if (!flag && pState.getValue(EXTENDED)) {
+            // 如果没有信号且活塞已扩展，尝试收缩活塞
+            BlockPos blockpos = pPos.relative(direction, 2);
+            BlockState blockstate = pLevel.getBlockState(blockpos);
+            int i = 1;
+            if (blockstate.is(Blocks.MOVING_PISTON) && blockstate.getValue(FACING) == direction) {
+                BlockEntity blockentity = pLevel.getBlockEntity(blockpos);
+                if (blockentity instanceof PistonMovingBlockEntity) {
+                    PistonMovingBlockEntity pistonmovingblockentity = (PistonMovingBlockEntity)blockentity;
+                    if (pistonmovingblockentity.isExtending() && (pistonmovingblockentity.getProgress(0.0F) < 0.5F || pLevel.getGameTime() == pistonmovingblockentity.getLastTicked() || ((ServerLevel)pLevel).isHandlingTick())) {
+                        i = 2;
+                    }
+                }
+            }
+            pLevel.blockEvent(pPos, this, i, direction.get3DDataValue());
+        }
+    }
+
+    /**
+     * 检查活塞周围的方块是否提供信号。
+     * @param pSignalGetter 信号获取器
+     * @param pPos 方块的位置
+     * @param pDirection 活塞的面向方向
+     * @return 是否有信号
+     */
+    private boolean getNeighborSignal(SignalGetter pSignalGetter, BlockPos pPos, Direction pDirection) {
+        // 检查除面向方向外的其他方向是否有信号
+        for(Direction direction : Direction.values()) {
+            if (direction != pDirection && pSignalGetter.hasSignal(pPos.relative(direction), direction)) {
+                return true;
+            }
+        }
+        // 检查下方是否有信号
+        if (pSignalGetter.hasSignal(pPos, Direction.DOWN)) {
+            return true;
+        } else {
+            BlockPos blockpos = pPos.above();
+            // 检查上方周围的方块是否有信号
+            for(Direction direction1 : Direction.values()) {
+                if (direction1 != Direction.DOWN && pSignalGetter.hasSignal(blockpos.relative(direction1), direction1)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+    }
+
+    /**
+     * 处理方块事件，包括活塞的扩展、收缩和掉落事件。
+     * @param pState 方块状态
+     * @param pLevel 方块所在的世界
+     * @param pPos 方块的位置
+     * @param pId 事件编号
+     * @param pParam 事件参数
+     * @return 是否处理成功
+     */
+    public boolean triggerEvent(BlockState pState, Level pLevel, BlockPos pPos, int pId, int pParam) {
+        // 获取活塞的面向方向
+        Direction direction = pState.getValue(FACING);
+        // 设置活塞为扩展状态
+        BlockState blockstate = pState.setValue(EXTENDED, Boolean.valueOf(true));
+        if (!pLevel.isClientSide) {
+            // 在服务器端检查是否有信号
+            boolean flag = this.getNeighborSignal(pLevel, pPos, direction);
+            if (flag && (pId == 1 || pId == 2)) {
+                // 如果有信号且是收缩或掉落事件，设置方块为扩展状态
+                pLevel.setBlock(pPos, blockstate, 2);
+                return false;
+            }
+            if (!flag && pId == 0) {
+                // 如果没有信号且是扩展事件，不处理
+                return false;
+            }
+        }
+        if (pId == 0) {
+            // 扩展事件
+            if (net.minecraftforge.event.ForgeEventFactory.onPistonMovePre(pLevel, pPos, direction, true)) return false;
+            if (!this.moveBlocks(pLevel, pPos, direction, true)) {
+                return false;
+            }
+            pLevel.setBlock(pPos, blockstate, 67);
+            pLevel.playSound((Player)null, pPos, SoundEvents.PISTON_EXTEND, SoundSource.BLOCKS, 0.5F, pLevel.random.nextFloat() * 0.25F + 0.6F);
+            pLevel.gameEvent(GameEvent.BLOCK_ACTIVATE, pPos, GameEvent.Context.of(blockstate));
+        } else if (pId == 1 || pId == 2) {
+            // 收缩或掉落事件
+            if (net.minecraftforge.event.ForgeEventFactory.onPistonMovePre(pLevel, pPos, direction, false)) return false;
+            BlockEntity blockentity1 = pLevel.getBlockEntity(pPos.relative(direction));
+            if (blockentity1 instanceof PistonMovingBlockEntity) {
+                ((PistonMovingBlockEntity)blockentity1).finalTick();
+            }
+            BlockState blockstate1 = Blocks.MOVING_PISTON.defaultBlockState().setValue(MovingPistonBlock.FACING, direction).setValue(MovingPistonBlock.TYPE, this.isSticky ? PistonType.STICKY : PistonType.DEFAULT);
+            pLevel.setBlock(pPos, blockstate1, 20);
+            pLevel.setBlockEntity(MovingPistonBlock.newMovingBlockEntity(pPos, blockstate1, this.defaultBlockState().setValue(FACING, Direction.from3DDataValue(pParam & 7)), direction, false, true));
+            pLevel.blockUpdated(pPos, blockstate1.getBlock());
+            blockstate1.updateNeighbourShapes(pLevel, pPos, 2);
+            if (this.isSticky) {
+                BlockPos blockpos = pPos.offset(direction.getStepX() * 2, direction.getStepY() * 2, direction.getStepZ() * 2);
+                BlockState blockstate2 = pLevel.getBlockState(blockpos);
+                boolean flag1 = false;
+                if (blockstate2.is(Blocks.MOVING_PISTON)) {
+                    BlockEntity blockentity = pLevel.getBlockEntity(blockpos);
+                    if (blockentity instanceof PistonMovingBlockEntity) {
+                        PistonMovingBlockEntity pistonmovingblockentity = (PistonMovingBlockEntity)blockentity;
+                        if (pistonmovingblockentity.getDirection() == direction && pistonmovingblockentity.isExtending()) {
+                            pistonmovingblockentity.finalTick();
+                            flag1 = true;
+                        }
+                    }
+                }
+                if (!flag1) {
+                    if (pId != 1 || blockstate2.isAir() || !isPushable(blockstate2, pLevel, blockpos, direction.getOpposite(), false, direction) || blockstate2.getPistonPushReaction() != PushReaction.NORMAL && !blockstate2.is(Blocks.PISTON) && !blockstate2.is(Blocks.STICKY_PISTON)) {
+                        pLevel.removeBlock(pPos.relative(direction), false);
+                    } else {
+                        this.moveBlocks(pLevel, pPos, direction, false);
+                    }
+                }
+            } else {
+                pLevel.removeBlock(pPos.relative(direction), false);
+            }
+            pLevel.playSound((Player)null, pPos, SoundEvents.PISTON_CONTRACT, SoundSource.BLOCKS, 0.5F, pLevel.random.nextFloat() * 0.15F + 0.6F);
+            pLevel.gameEvent(GameEvent.BLOCK_DEACTIVATE, pPos, GameEvent.Context.of(blockstate1));
+        }
+        net.minecraftforge.event.ForgeEventFactory.onPistonMovePost(pLevel, pPos, direction, (pId == 0));
+        return true;
+    }
+
+       /**
+    * Checks if the piston can push the given BlockState.
+    * 检查活塞是否可以推动给定的方块状态。
+    * 
+    * @param pState            要检查的方块状态
+    * @param pLevel            方块所在的世界
+    * @param pPos              方块的位置
+    * @param pMovementDirection 活塞推动的方向
+    * @param pAllowDestroy     是否允许破坏方块
+    * @param pPistonFacing     活塞的朝向
+    * @return 如果可以推动返回true，否则返回false
+    */
+   public static boolean isPushable(BlockState pState, Level pLevel, BlockPos pPos, Direction pMovementDirection, boolean pAllowDestroy, Direction pPistonFacing) {
+      // 检查方块位置是否在世界的有效高度范围内，并且在世界边界内
+      if (pPos.getY() >= pLevel.getMinBuildHeight() && pPos.getY() <= pLevel.getMaxBuildHeight() - 1 && pLevel.getWorldBorder().isWithinBounds(pPos)) {
+         // 如果方块是空气，直接返回true，因为空气可以被推动
+         if (pState.isAir()) {
+            return true;
+         // 排除一些无法被推动的方块，如黑曜石、哭泣的黑曜石、重生锚和强化深板岩
+         } else if (!pState.is(Blocks.OBSIDIAN) && !pState.is(Blocks.CRYING_OBSIDIAN) && !pState.is(Blocks.RESPAWN_ANCHOR) && !pState.is(Blocks.REINFORCED_DEEPSLATE)) {
+            // 检查推动方向是否为向下且方块位于世界的最低高度，若是则不能推动
+            if (pMovementDirection == Direction.DOWN && pPos.getY() == pLevel.getMinBuildHeight()) {
+               return false;
+            // 检查推动方向是否为向上且方块位于世界的最高高度，若是则不能推动
+            } else if (pMovementDirection == Direction.UP && pPos.getY() == pLevel.getMaxBuildHeight() - 1) {
+               return false;
+            } else {
+               // 排除活塞方块，如果不是活塞方块
+               if (!pState.is(Blocks.PISTON) && !pState.is(Blocks.STICKY_PISTON)) {
+                  // 如果方块的破坏速度为 -1.0F，表示不可破坏，不能推动
+                  if (pState.getDestroySpeed(pLevel, pPos) == -1.0F) {
+                     return false;
+                  }
+                  // 根据方块的活塞推动反应类型进行判断
+                  switch (pState.getPistonPushReaction()) {
+                     // 若反应类型为 BLOCK，表示方块会阻挡推动，不能推动
+                     case BLOCK:
+                        return false;
+                     // 若反应类型为 DESTROY，根据是否允许破坏方块来决定是否可以推动
+                     case DESTROY:
+                        return pAllowDestroy;
+                     // 若反应类型为 PUSH_ONLY，只有推动方向与活塞朝向一致时才能推动
+                     case PUSH_ONLY:
+                        return pMovementDirection == pPistonFacing;
+                  }
+               // 如果是活塞方块且处于伸展状态，不能推动
+               } else if (pState.getValue(EXTENDED)) {
+                  return false;
+               }
+               // 若方块没有方块实体，则可以推动
+               return !pState.hasBlockEntity();
+            }
+         } else {
+            return false;
+         }
+      } else {
+         return false;
+      }
+   }
+
+   /**
+    * 移动方块的方法，用于处理活塞伸展或收缩时方块的移动操作。
+    * 
+    * @param pLevel    方块所在的世界
+    * @param pPos      活塞的位置
+    * @param pFacing   活塞的朝向
+    * @param pExtending  是否为伸展操作
+    * @return 如果方块移动成功返回true，否则返回false
+    */
+   private boolean moveBlocks(Level pLevel, BlockPos pPos, Direction pFacing, boolean pExtending) {
+      // 获取活塞朝向的相邻方块位置
+      BlockPos blockpos = pPos.relative(pFacing);
+      // 如果是收缩操作且相邻方块是活塞头，则将其替换为空气
+      if (!pExtending && pLevel.getBlockState(blockpos).is(Blocks.PISTON_HEAD)) {
+         pLevel.setBlock(blockpos, Blocks.AIR.defaultBlockState(), 20);
+      }
+      // 创建一个活塞结构解析器，用于解析需要推动和破坏的方块
+      PistonStructureResolver pistonstructureresolver = new PistonStructureResolver(pLevel, pPos, pFacing, pExtending);
+      // 解析需要推动和破坏的方块，如果解析失败则返回false
+      if (!pistonstructureresolver.resolve()) {
+         return false;
+      } else {
+         // 创建一个映射，用于存储方块位置和对应的方块状态
+         Map<BlockPos, BlockState> map = Maps.newHashMap();
+         // 获取需要推动的方块位置列表
+         List<BlockPos> list = pistonstructureresolver.getToPush();
+         // 创建一个列表，用于存储需要推动的方块状态
+         List<BlockState> list1 = Lists.newArrayList();
+         // 遍历需要推动的方块位置列表，将方块状态添加到列表中，并存储到映射中
+         for(int i = 0; i < list.size(); ++i) {
+            BlockPos blockpos1 = list.get(i);
+            BlockState blockstate = pLevel.getBlockState(blockpos1);
+            list1.add(blockstate);
+            map.put(blockpos1, blockstate);
+         }
+         // 获取需要破坏的方块位置列表
+         List<BlockPos> list2 = pistonstructureresolver.getToDestroy();
+         // 创建一个数组，用于存储所有需要处理的方块状态
+         BlockState[] ablockstate = new BlockState[list.size() + list2.size()];
+         // 根据是否伸展操作确定方块移动的方向
+         Direction direction = pExtending ? pFacing : pFacing.getOpposite();
+         int j = 0;
+         // 遍历需要破坏的方块位置列表，依次处理这些方块
+         for(int k = list2.size() - 1; k >= 0; --k) {
+            BlockPos blockpos2 = list2.get(k);
+            BlockState blockstate1 = pLevel.getBlockState(blockpos2);
+            // 获取方块实体，如果有的话
+            BlockEntity blockentity = blockstate1.hasBlockEntity() ? pLevel.getBlockEntity(blockpos2) : null;
+            // 掉落方块的资源
+            dropResources(blockstate1, pLevel, blockpos2, blockentity);
+            // 将方块替换为空气
+            pLevel.setBlock(blockpos2, Blocks.AIR.defaultBlockState(), 18);
+            // 触发方块破坏的游戏事件
+            pLevel.gameEvent(GameEvent.BLOCK_DESTROY, blockpos2, GameEvent.Context.of(blockstate1));
+            // 如果方块不是火，则添加方块破坏的效果
+            if (!blockstate1.is(BlockTags.FIRE)) {
+               pLevel.addDestroyBlockEffect(blockpos2, blockstate1);
+            }
+            // 将方块状态存储到数组中
+            ablockstate[j++] = blockstate1;
+         }
+         // 遍历需要推动的方块位置列表，依次处理这些方块
+         for(int l = list.size() - 1; l >= 0; --l) {
+            BlockPos blockpos3 = list.get(l);
+            BlockState blockstate5 = pLevel.getBlockState(blockpos3);
+            // 计算方块移动后的位置
+            blockpos3 = blockpos3.relative(direction);
+            // 从映射中移除移动后的位置
+            map.remove(blockpos3);
+            // 获取移动活塞方块的默认状态，并设置朝向
+            BlockState blockstate8 = Blocks.MOVING_PISTON.defaultBlockState().setValue(FACING, pFacing);
+            // 将方块设置为移动活塞方块
+            pLevel.setBlock(blockpos3, blockstate8, 68);
+            // 创建移动活塞方块实体
+            pLevel.setBlockEntity(MovingPistonBlock.newMovingBlockEntity(blockpos3, blockstate8, list1.get(l), pFacing, pExtending, false));
+            // 将方块状态存储到数组中
+            ablockstate[j++] = blockstate5;
+         }
+         // 如果是伸展操作
+         if (pExtending) {
+            // 根据活塞是否为粘性活塞确定活塞头的类型
+            PistonType pistontype = this.isSticky ? PistonType.STICKY : PistonType.DEFAULT;
+            // 获取活塞头方块的默认状态，并设置朝向和类型
+            BlockState blockstate4 = Blocks.PISTON_HEAD.defaultBlockState().setValue(PistonHeadBlock.FACING, pFacing).setValue(PistonHeadBlock.TYPE, pistontype);
+            // 获取移动活塞方块的默认状态，并设置朝向和类型
+            BlockState blockstate6 = Blocks.MOVING_PISTON.defaultBlockState().setValue(MovingPistonBlock.FACING, pFacing).setValue(MovingPistonBlock.TYPE, this.isSticky ? PistonType.STICKY : PistonType.DEFAULT);
+            // 从映射中移除活塞朝向的相邻方块位置
+            map.remove(blockpos);
+            // 将活塞朝向的相邻方块设置为移动活塞方块
+            pLevel.setBlock(blockpos, blockstate6, 68);
+            // 创建移动活塞方块实体
+            pLevel.setBlockEntity(MovingPistonBlock.newMovingBlockEntity(blockpos, blockstate6, blockstate4, pFacing, true, true));
+         }
+         // 获取空气方块的默认状态
+         BlockState blockstate3 = Blocks.AIR.defaultBlockState();
+         // 遍历映射中的所有方块位置，将这些位置的方块设置为空气
+         for(BlockPos blockpos4 : map.keySet()) {
+            pLevel.setBlock(blockpos4, blockstate3, 82);
+         }
+         // 遍历映射中的所有方块位置和状态，更新方块的邻居形状
+         for(Map.Entry<BlockPos, BlockState> entry : map.entrySet()) {
+            BlockPos blockpos5 = entry.getKey();
+            BlockState blockstate2 = entry.getValue();
+            blockstate2.updateIndirectNeighbourShapes(pLevel, blockpos5, 2);
+            blockstate3.updateNeighbourShapes(pLevel, blockpos5, 2);
+            blockstate3.updateIndirectNeighbourShapes(pLevel, blockpos5, 2);
+         }
+         j = 0;
+         // 遍历需要破坏的方块状态数组，更新方块的间接邻居形状和邻居方块
+         for(int i1 = list2.size() - 1; i1 >= 0; --i1) {
+            BlockState blockstate7 = ablockstate[j++];
+            BlockPos blockpos6 = list2.get(i1);
+            blockstate7.updateIndirectNeighbourShapes(pLevel, blockpos6, 2);
+            pLevel.updateNeighborsAt(blockpos6, blockstate7.getBlock());
+         }
+         // 遍历需要推动的方块状态数组，更新邻居方块
+         for(int j1 = list.size() - 1; j1 >= 0; --j1) {
+            pLevel.updateNeighborsAt(list.get(j1), ablockstate[j++].getBlock());
+         }
+         // 如果是伸展操作，更新活塞头方块的邻居方块
+         if (pExtending) {
+            pLevel.updateNeighborsAt(blockpos, Blocks.PISTON_HEAD);
+         }
+         // 方块移动成功，返回true
+         return true;
+      }
+   }
+
+   /**
+    * Returns the blockstate with the given rotation from the passed blockstate. If inapplicable, returns the passed
+    * blockstate.
+    * 根据给定的旋转方向旋转方块状态。如果不适用，则返回传入的方块状态。
+    * 
+    * @param pState 要旋转的方块状态
+    * @param pRot   旋转方向
+    * @return 旋转后的方块状态
+    * @deprecated call via {@link BlockStateBase#rotate} whenever
+    * possible. Implementing/overriding is fine.
+    */
+   public BlockState rotate(BlockState pState, Rotation pRot) {
+      // 根据旋转方向更新方块的朝向属性
+      return pState.setValue(FACING, pRot.rotate(pState.getValue(FACING)));
+   }
+
+   /**
+    * 根据给定的旋转方向旋转方块状态，考虑方块是否伸展的情况。
+    * 
+    * @param state     要旋转的方块状态
+    * @param world     方块所在的世界访问器
+    * @param pos       方块的位置
+    * @param direction 旋转方向
+    * @return 旋转后的方块状态
+    */
+   public BlockState rotate(BlockState state, net.minecraft.world.level.LevelAccessor world, BlockPos pos, Rotation direction) {
+       // 如果方块处于伸展状态，则不进行旋转，直接返回原状态；否则调用父类的旋转方法
+       return state.getValue(EXTENDED) ? state : super.rotate(state, world, pos, direction);
+   }
+
+   /**
+    * Returns the blockstate with the given mirror of the passed blockstate. If inapplicable, returns the passed
+    * blockstate.
+    * 根据给定的镜像方式镜像方块状态。如果不适用，则返回传入的方块状态。
+    * 
+    * @param pState 要镜像的方块状态
+    * @param pMirror 镜像方式
+    * @return 镜像后的方块状态
+    * @deprecated call via {@link BlockStateBase#mirror} whenever
+    * possible. Implementing/overriding is fine.
+    */
+   public BlockState mirror(BlockState pState, Mirror pMirror) {
+      // 根据镜像方式获取旋转方向，然后旋转方块状态
+      return pState.rotate(pMirror.getRotation(pState.getValue(FACING)));
+   }
+
+   /**
+    * 创建方块状态定义，添加方块的朝向和伸展属性。
+    * 
+    * @param pBuilder 方块状态定义构建器
+    */
+   protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> pBuilder) {
+      // 向构建器中添加方块的朝向和伸展属性
+      pBuilder.add(FACING, EXTENDED);
+   }
+
+   /**
+    * 判断方块是否使用形状进行光照遮挡。
+    * 
+    * @param pState 方块状态
+    * @return 如果方块处于伸展状态则返回true，否则返回false
+    */
+   public boolean useShapeForLightOcclusion(BlockState pState) {
+      // 根据方块的伸展属性判断是否使用形状进行光照遮挡
+      return pState.getValue(EXTENDED);
+   }
+
+   /**
+    * 判断方块是否可用于路径计算。
+    * 
+    * @param pState 方块状态
+    * @param pLevel 方块所在的世界
+    * @param pPos   方块的位置
+    * @param pType  路径计算类型
+    * @return 始终返回false，表示方块不可用于路径计算
+    */
+   public boolean isPathfindable(BlockState pState, BlockGetter pLevel, BlockPos pPos, PathComputationType pType) {
+      // 活塞方块不可用于路径计算，返回false
+      return false;
+   }
+}
\ No newline at end of file
Index: src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/InebriatedWorldData.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.util.datautil.worlddata;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.util.datautil.datastorage.InebriatedDataStorage;\r\nimport net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport net.minecraft.world.level.saveddata.SavedData;\r\nimport net.minecraft.world.level.storage.DimensionDataStorage;\r\nimport net.minecraftforge.event.level.LevelEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\n// 自定义世界数据存储管理器类\r\n@Mod.EventBusSubscriber\r\npublic class InebriatedWorldData extends SavedData {\r\n    private static final String INEBRIATED_DATA_NAME = ImmortalersDelightMod.MODID + \"inebriated_data\";\r\n    // 自定义数据存储实例\r\n    private final InebriatedDataStorage customData = new InebriatedDataStorage();\r\n    // 数据存储的名称\r\n    private static final String INEBRIATED_WORLD_DATA_NAME = ImmortalersDelightMod.MODID + \"inebriated_world_data\";\r\n\r\n    // 构造函数\r\n    public InebriatedWorldData() {\r\n    }\r\n\r\n    // 从 NBT 标签加载数据的静态方法\r\n    public static InebriatedWorldData load(CompoundTag nbt) {\r\n        InebriatedWorldData data = new InebriatedWorldData();\r\n        // 从 NBT 标签中读取自定义数据\r\n        data.customData.deserializeNBT(nbt.getCompound(INEBRIATED_DATA_NAME));\r\n        return data;\r\n    }\r\n\r\n    // 将数据保存到 NBT 标签的方法\r\n    @Override\r\n    public CompoundTag save(CompoundTag nbt) {\r\n        // 将自定义数据写入 NBT 标签\r\n        nbt.put(INEBRIATED_DATA_NAME, customData.serializeNBT());\r\n        return nbt;\r\n    }\r\n\r\n    // 获取自定义数据存储实例的方法\r\n    public InebriatedDataStorage getCustomData() {\r\n        return customData;\r\n    }\r\n\r\n    // 订阅世界加载事件，在此处加载所保存的数据\r\n    @SubscribeEvent\r\n    public static void onWorldLoad(LevelEvent.Load event) {\r\n        if (event.getLevel() instanceof ServerLevel serverLevel) {\r\n            DimensionDataStorage storage = serverLevel.getDataStorage();\r\n            // 获取或创建自定义世界数据实例\r\n            InebriatedWorldData data = storage.computeIfAbsent(InebriatedWorldData::load, InebriatedWorldData::new, INEBRIATED_WORLD_DATA_NAME);\r\n        }\r\n    }\r\n\r\n    // 获取自定义世界数据实例的静态方法\r\n    public static InebriatedWorldData get(ServerLevel level) {\r\n        DimensionDataStorage storage = level.getDataStorage();\r\n        return storage.computeIfAbsent(InebriatedWorldData::load, InebriatedWorldData::new, INEBRIATED_WORLD_DATA_NAME);\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/InebriatedWorldData.java b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/InebriatedWorldData.java
--- a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/InebriatedWorldData.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/InebriatedWorldData.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.util.datautil.worlddata;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.util.datautil.datastorage.InebriatedDataStorage;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.server.level.ServerLevel;
Index: src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/InebriatedEffect.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.potion.immortaleffects;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;\r\nimport com.renyigesai.immortalers_delight.util.datautil.EffectData;\r\nimport com.renyigesai.immortalers_delight.util.datautil.datasaveloadhelper.ExitTimeSaveLoadHelper;\r\nimport com.renyigesai.immortalers_delight.util.datautil.datasaveloadhelper.InebriatedMapSaveLoadHelper;\r\nimport com.renyigesai.immortalers_delight.util.task.ScheduledExecuteTask;\r\nimport com.renyigesai.immortalers_delight.util.task.TimekeepingTask;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport net.minecraft.world.effect.MobEffectInstance;\r\nimport net.minecraft.world.entity.LivingEntity;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraftforge.event.entity.living.LivingEvent;\r\nimport net.minecraftforge.event.level.LevelEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\nimport java.util.Map;\r\nimport java.util.Random;\r\nimport java.util.UUID;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\n\r\n@Mod.EventBusSubscriber\r\npublic class InebriatedEffect {\r\n    /*\r\n    这个类能对实体进行标记（以及解除标记），\r\n     */\r\n    /*\r\n    用Map存储受到当前效果的实体与对应的持续时间（表示为结束时刻）\r\n     */\r\n    private static final Map<UUID, EffectData> entityHasEffect = new ConcurrentHashMap<>();\r\n    private static boolean pausing = true;\r\n    public static void setPausing(boolean pFirst) {\r\n        pausing = pFirst;\r\n    }\r\n    /**\r\n     * 定义内部静态类 EffectData，用于存储实体所在位置和药水的效果等信息，继承自 BlockPos\r\n     */\r\n\r\n    public static Map<UUID, EffectData> getEntityMap() {\r\n        return entityHasEffect;\r\n    }\r\n\r\n//    public static void setEntityMap(Map<UUID, Long> pEntityMap) {\r\n//        timeToEntity.\r\n//    }\r\n\r\n    /**\r\n     * 对指定的生物实体应用特殊效果，输入实体与持续时间（秒）\r\n     * @param entity\r\n     * @param durationSeconds\r\n     */\r\n    public static void applyImmortalEffect(LivingEntity entity, double durationSeconds, int amplifier) {\r\n        /*\r\n        判断合理的实体目标\r\n         */\r\n        if (entity == null || entity.isRemoved()) {\r\n            return;\r\n        }\r\n\r\n        /*\r\n        获取实体UUID以唯一标记对应实体\r\n         */\r\n        UUID uuid = entity.getUUID();\r\n        /*\r\n        计算效果的结束时刻，使用系统时以绕开tick相关操作\r\n         */\r\n        long expireTime = TimekeepingTask.getImmortalTickTime() + (long) (durationSeconds * 1000);\r\n        int durationTicks = (int) (durationSeconds * 20);\r\n\r\n        /*\r\n        构造新的计划任务，在其中执行buff的逻辑\r\n         */\r\n        int taskID = new Random().nextInt(Short.MAX_VALUE);\r\n        ScheduledExecuteTask task = buildEffectTask(taskID,entity,durationSeconds,amplifier);\r\n        task.start();\r\n        /*\r\n        将实体与Buff相关数据保存到Map\r\n         */\r\n        EffectData effectData = new EffectData(entity.blockPosition(),expireTime,amplifier,taskID);\r\n        entityHasEffect.put(uuid,effectData);\r\n        System.out.println(\"应用了 \" + durationSeconds + \" 秒的特殊效果在实体 \" + uuid + \" 上\");\r\n        ImmortalersDelightMod.LOGGER.info(\"应用了 \" + durationSeconds + \" 秒的特殊效果在实体 \" + uuid + \" 上\");\r\n//        if (!entity.level().isClientSide()) {\r\n//            InebriatedMapSaveLoadHelper.saveEntityHasEffect(entity.level(), entityHasEffect);\r\n//        }\r\n    }\r\n\r\n    /**\r\n     * 在生物的tick事件处理效果的逻辑\r\n     * @param event\r\n     */\r\n    @SubscribeEvent\r\n    public static void onTick(LivingEvent.LivingTickEvent event) {\r\n        /*\r\n        判断是否触发了暂停，由于\r\n        又因为暂停时会触发WorldSave但解除暂停不会触发WorldLoad，因此在这里再触发一次读取实体Map\r\n         */\r\n        if (pausing && !event.getEntity().level().isClientSide){\r\n            LoadEntityMap(event.getEntity().level());\r\n        }\r\n\r\n        LivingEntity entity = event.getEntity();\r\n        if (entity == null || entity.isRemoved() || !entity.isAlive()) {\r\n            return;\r\n        }\r\n\r\n        /*\r\n        获取当前实体的效果结束时刻\r\n         */\r\n        UUID uuid = entity.getUUID();\r\n        if (entityHasEffect.get(uuid) == null) {\r\n            return;\r\n        }\r\n        Long expireTime = entityHasEffect.get(uuid).getTime();\r\n\r\n        /*\r\n        如果当前系统时间超过了结束时刻，取消效果（将实体从Map中移除，取消计划任务）\r\n         */\r\n//        ImmortalersDelightMod.LOGGER.info(\"你这B玩意还有多久结束？\" + (expireTime - TimekeepingTask.getImmortalTickTime()) / 1000 + \"秒\");\r\n//        ImmortalersDelightMod.LOGGER.info(\"附一个现在的时间\" + TimekeepingTask.getImmortalTickTime());\r\n        if (TimekeepingTask.getImmortalTickTime() > expireTime) {\r\n            removeImmortalEffect(entity);\r\n            entity.addEffect(new MobEffectInstance(ImmortalersDelightMobEffect.INEBRIATED.get(),1,0,false,false));\r\n        } else {\r\n            /*\r\n            此处为具体的效果方法逻辑\r\n            此处的处理为如果没找到实体对应的计划任务（例如退出重进导致计划任务丢失），补一个新的计划任务\r\n             */\r\n            Integer taskID = entityHasEffect.get(uuid).getTaskId();\r\n            ScheduledExecuteTask task = InebriatedEffectTask.getTaskFromID(taskID);\r\n            // 输出读取到的 Map\r\n\r\n            if (task == null) {\r\n//                ImmortalersDelightMod.LOGGER.info(\"WTF怎么没找到计划任务？让我看看现在的实体表是什么玩意\");\r\n//                for (Map.Entry<UUID, EffectData> entry : entityHasEffect.entrySet()) {\r\n//                    UUID uuid1 = entry.getKey();\r\n//                    EffectData effectData = entry.getValue();\r\n//                    ImmortalersDelightMod.LOGGER.info(\"UUID: \" + uuid1 + \", Effect Level: \" + effectData.getAmplifier() +\r\n//                            \", Duration: \" + effectData.getTime() + \", Task ID \" + effectData.getTaskId());\r\n//                }\r\n\r\n                Long durationTime = expireTime - TimekeepingTask.getImmortalTickTime();\r\n//                ImmortalersDelightMod.LOGGER.info(\"你这B玩意还有多久结束？\" + durationTime);\r\n                ScheduledExecuteTask newTask = buildEffectTask(taskID,entity,durationTime/1000,entityHasEffect.get(uuid).getAmplifier());\r\n                newTask.start();\r\n//                System.out.println(\"计划任务异常！已创建新的计划任务\");\r\n//                ImmortalersDelightMod.LOGGER.info(\"计划任务异常！已创建新的计划任务\");\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 用于去除指定实体的特殊效果的方法\r\n     * @param entity\r\n     */\r\n    public static void removeImmortalEffect(LivingEntity entity) {\r\n        UUID uuid = entity.getUUID();\r\n        onImmortalEffectRemove(entity);\r\n        entityHasEffect.remove(uuid);\r\n        System.out.println(\"已将实体\" + uuid + \"从携带者列表中移除\");\r\n        ImmortalersDelightMod.LOGGER.info(\"已将实体\" + uuid + \"从携带者列表中移除\");\r\n//        if (!entity.level().isClientSide()) {\r\n//            InebriatedMapSaveLoadHelper.saveEntityHasEffect(entity.level(), entityHasEffect);\r\n//        }\r\n    }\r\n    /**\r\n     * 用于去除指定实体的特殊效果时进行善后的方法\r\n     * @param entity\r\n     */\r\n    private static void onImmortalEffectRemove (LivingEntity entity) {\r\n        if (entity == null || entity.isRemoved()) {\r\n            return;\r\n        }\r\n\r\n        UUID uuid = entity.getUUID();\r\n        System.out.println(\"实体 \" + uuid + \" 解除了特殊效果\");\r\n        ImmortalersDelightMod.LOGGER.info(\"实体 \" + uuid + \" 解除了特殊效果\");\r\n        /*\r\n        在这里处理一些善后工作，这不是药水效果所以要记得手动善后\r\n         */\r\n        if (entityHasEffect.get(uuid) == null) {return;}\r\n        Integer taskID = entityHasEffect.get(uuid).getTaskId();\r\n        ScheduledExecuteTask task = InebriatedEffectTask.getTaskFromID(taskID);\r\n        if (task != null) {\r\n            task.cancel();\r\n            ImmortalersDelightMod.LOGGER.info(\"我们已经取消了Task\");\r\n        } else ImmortalersDelightMod.LOGGER.info(\"怎么会没找到Task？\");\r\n\r\n    }\r\n\r\n    /**\r\n     * 监听世界保存事件，将实体Map存盘\r\n     * @param event\r\n     */\r\n    @SubscribeEvent\r\n    public static void onWorldLoad(LevelEvent.Load event) {\r\n        if (event.getLevel() instanceof ServerLevel serverLevel) {\r\n            LoadEntityMap(serverLevel);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 这个方法用于修正时序以及从存盘数据中加载退出时的实体数据\r\n     * @param serverLevel\r\n     */\r\n    private static void LoadEntityMap(Level serverLevel) {\r\n\r\n        ImmortalersDelightMod.LOGGER.info(\"正在读取存盘的Effect实体Map\");\r\n        entityHasEffect.clear();\r\n        Map<UUID, EffectData> oldMap = InebriatedMapSaveLoadHelper.loadEntityHasEffect(serverLevel);\r\n\r\n        if (oldMap == null) {\r\n            ImmortalersDelightMod.LOGGER.info(\"存盘表为null！\");\r\n            pausing = false;\r\n            return;\r\n        }\r\n        ImmortalersDelightMod.LOGGER.info(\"正在检查存盘的Map，读取到的存盘Map是：\");\r\n        // 输出读取到的 Map\r\n        for (Map.Entry<UUID, EffectData> entry : oldMap.entrySet()) {\r\n            UUID uuid = entry.getKey();\r\n            EffectData effectData = entry.getValue();\r\n            ImmortalersDelightMod.LOGGER.info(\"UUID: \" + uuid + \", Effect Level: \" + effectData.getAmplifier() +\r\n                    \", Duration: \" + effectData.getTime() + \", Task ID \" + effectData.getTaskId());\r\n        }\r\n        //entityHasEffect = new ConcurrentHashMap<>();\r\n            /*\r\n            遍历存盘的Map，将存盘的Map数据同步到新Map\r\n             */\r\n        for (Map.Entry<UUID, EffectData> entry : oldMap.entrySet()) {\r\n            UUID uuidOld = entry.getKey();\r\n            EffectData dataOld = entry.getValue();\r\n            /*\r\n            修正时刻，存盘的Map里存的时间理论上为[上次关服时间 + 剩余持续时间]，因此减去一个上次关服时间再加上当前时间即可保持持续时间不变\r\n             */\r\n            Long trueTime = dataOld.getTime() - ExitTimeSaveLoadHelper.loadExitTime(serverLevel) + TimekeepingTask.getImmortalTickTime();\r\n            if (trueTime > TimekeepingTask.getImmortalTickTime()) {\r\n                EffectData newOne = new EffectData(dataOld, trueTime, dataOld.getAmplifier(), dataOld.getTaskId());\r\n                entityHasEffect.put(uuidOld,newOne);\r\n            }\r\n        }\r\n        ImmortalersDelightMod.LOGGER.info(\"存盘Map读取完毕，当前Effect实体Map为：\");\r\n        pausing = false;\r\n        // 输出读取到的 Map\r\n        for (Map.Entry<UUID, EffectData> entry : entityHasEffect.entrySet()) {\r\n            UUID uuid = entry.getKey();\r\n            EffectData effectData = entry.getValue();\r\n            ImmortalersDelightMod.LOGGER.info(\"UUID: \" + uuid + \", Effect Level: \" + effectData.getAmplifier() +\r\n                    \", Duration: \" + effectData.getTime() + \", Task ID \" + effectData.getTaskId());\r\n        }\r\n    }\r\n    /**\r\n     * 用于构建新的计划任务的方法\r\n     * @param id\r\n     * @param pLivingEntity\r\n     * @param durationSeconds\r\n     * @param amplifier\r\n     * @return\r\n     */\r\n    public static ScheduledExecuteTask buildEffectTask(int id, LivingEntity pLivingEntity, double durationSeconds, int amplifier) {\r\n\r\n        InebriatedEffectTask task = new InebriatedEffectTask(1,1,id,pLivingEntity, (long) durationSeconds,amplifier);\r\n        task.start();\r\n        return task;\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/InebriatedEffect.java b/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/InebriatedEffect.java
--- a/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/InebriatedEffect.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/InebriatedEffect.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.potion.immortaleffects;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;
 import com.renyigesai.immortalers_delight.util.datautil.EffectData;
 import com.renyigesai.immortalers_delight.util.datautil.datasaveloadhelper.ExitTimeSaveLoadHelper;
Index: src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/GasPoisonWorldData.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.util.datautil.worlddata;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.util.datautil.datastorage.GasPoisonDataStorage;\r\nimport net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport net.minecraft.world.level.saveddata.SavedData;\r\nimport net.minecraft.world.level.storage.DimensionDataStorage;\r\nimport net.minecraftforge.event.level.LevelEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\n// 自定义世界数据存储管理器类\r\n@Mod.EventBusSubscriber\r\npublic class GasPoisonWorldData extends SavedData {\r\n    private static final String GAS_POISON_DATA_NAME = ImmortalersDelightMod.MODID + \"gas_poison_data\";\r\n    // 自定义数据存储实例\r\n    private final GasPoisonDataStorage customData = new GasPoisonDataStorage();\r\n    // 数据存储的名称\r\n    private static final String GAS_POISON_WORLD_DATA_NAME = ImmortalersDelightMod.MODID + \"gas_poison_world_data\";\r\n\r\n    // 构造函数\r\n    public GasPoisonWorldData() {\r\n    }\r\n\r\n    // 从 NBT 标签加载数据的静态方法\r\n    public static GasPoisonWorldData load(CompoundTag nbt) {\r\n        GasPoisonWorldData data = new GasPoisonWorldData();\r\n        // 从 NBT 标签中读取自定义数据\r\n        data.customData.deserializeNBT(nbt.getCompound(GAS_POISON_DATA_NAME));\r\n        return data;\r\n    }\r\n\r\n    // 将数据保存到 NBT 标签的方法\r\n    @Override\r\n    public CompoundTag save(CompoundTag nbt) {\r\n        // 将自定义数据写入 NBT 标签\r\n        nbt.put(GAS_POISON_DATA_NAME, customData.serializeNBT());\r\n        return nbt;\r\n    }\r\n\r\n    // 获取自定义数据存储实例的方法\r\n    public GasPoisonDataStorage getCustomData() {\r\n        return customData;\r\n    }\r\n\r\n    // 订阅世界加载事件，在此处加载所保存的数据\r\n    @SubscribeEvent\r\n    public static void onWorldLoad(LevelEvent.Load event) {\r\n        if (event.getLevel() instanceof ServerLevel serverLevel) {\r\n            DimensionDataStorage storage = serverLevel.getDataStorage();\r\n            // 获取或创建自定义世界数据实例\r\n            GasPoisonWorldData data = storage.computeIfAbsent(GasPoisonWorldData::load, GasPoisonWorldData::new, GAS_POISON_WORLD_DATA_NAME);\r\n        }\r\n    }\r\n\r\n    // 获取自定义世界数据实例的静态方法\r\n    public static GasPoisonWorldData get(ServerLevel level) {\r\n        DimensionDataStorage storage = level.getDataStorage();\r\n        return storage.computeIfAbsent(GasPoisonWorldData::load, GasPoisonWorldData::new, GAS_POISON_WORLD_DATA_NAME);\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/GasPoisonWorldData.java b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/GasPoisonWorldData.java
--- a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/GasPoisonWorldData.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/GasPoisonWorldData.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.util.datautil.worlddata;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.util.datautil.datastorage.GasPoisonDataStorage;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.server.level.ServerLevel;
Index: src/main/java/com/renyigesai/immortalers_delight/Test.java
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/Test.java b/src/main/java/com/renyigesai/immortalers_delight/Test.java
new file mode 100644
--- /dev/null	
+++ b/src/main/java/com/renyigesai/immortalers_delight/Test.java	
@@ -0,0 +1,5 @@
+package com.renyigesai.immortalers_delight;
+
+public class Test {
+    public static final String TEST_TEST = "test";
+}
Index: src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/MagicalReverseWorldData.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.util.datautil.worlddata;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.util.datautil.datastorage.MagicalReverseDataStorage;\r\nimport net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport net.minecraft.world.level.saveddata.SavedData;\r\nimport net.minecraft.world.level.storage.DimensionDataStorage;\r\nimport net.minecraftforge.event.level.LevelEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\n// 自定义世界数据存储管理器类\r\n@Mod.EventBusSubscriber\r\npublic class MagicalReverseWorldData extends SavedData {\r\n    private static final String MAGICAL_REVERSE_DATA_NAME = ImmortalersDelightMod.MODID + \"magical_reverse_data\";\r\n    // 自定义数据存储实例\r\n    private final MagicalReverseDataStorage customData = new MagicalReverseDataStorage();\r\n    // 数据存储的名称\r\n    private static final String MAGICAL_REVERSE_WORLD_DATA_NAME = ImmortalersDelightMod.MODID + \"magical_reverse_world_data\";\r\n\r\n    // 构造函数\r\n    public MagicalReverseWorldData() {\r\n    }\r\n\r\n    // 从 NBT 标签加载数据的静态方法\r\n    public static MagicalReverseWorldData load(CompoundTag nbt) {\r\n        MagicalReverseWorldData data = new MagicalReverseWorldData();\r\n        // 从 NBT 标签中读取自定义数据\r\n        data.customData.deserializeNBT(nbt.getCompound(MAGICAL_REVERSE_DATA_NAME));\r\n        return data;\r\n    }\r\n\r\n    // 将数据保存到 NBT 标签的方法\r\n    @Override\r\n    public CompoundTag save(CompoundTag nbt) {\r\n        // 将自定义数据写入 NBT 标签\r\n        nbt.put(MAGICAL_REVERSE_DATA_NAME, customData.serializeNBT());\r\n        return nbt;\r\n    }\r\n\r\n    // 获取自定义数据存储实例的方法\r\n    public MagicalReverseDataStorage getCustomData() {\r\n        return customData;\r\n    }\r\n\r\n    // 订阅世界加载事件，在此处加载所保存的数据\r\n    @SubscribeEvent\r\n    public static void onWorldLoad(LevelEvent.Load event) {\r\n        if (event.getLevel() instanceof ServerLevel serverLevel) {\r\n            DimensionDataStorage storage = serverLevel.getDataStorage();\r\n            // 获取或创建自定义世界数据实例\r\n            MagicalReverseWorldData data = storage.computeIfAbsent(MagicalReverseWorldData::load, MagicalReverseWorldData::new, MAGICAL_REVERSE_WORLD_DATA_NAME);\r\n        }\r\n    }\r\n\r\n    // 获取自定义世界数据实例的静态方法\r\n    public static MagicalReverseWorldData get(ServerLevel level) {\r\n        DimensionDataStorage storage = level.getDataStorage();\r\n        return storage.computeIfAbsent(MagicalReverseWorldData::load, MagicalReverseWorldData::new, MAGICAL_REVERSE_WORLD_DATA_NAME);\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/MagicalReverseWorldData.java b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/MagicalReverseWorldData.java
--- a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/MagicalReverseWorldData.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/worlddata/MagicalReverseWorldData.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.util.datautil.worlddata;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.util.datautil.datastorage.MagicalReverseDataStorage;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.server.level.ServerLevel;
Index: src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/InebriatedEffectTask.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.potion.immortaleffects;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;\r\nimport com.renyigesai.immortalers_delight.util.task.ScheduledExecuteTask;\r\nimport com.renyigesai.immortalers_delight.util.task.TimekeepingTask;\r\nimport net.minecraft.world.effect.MobEffect;\r\nimport net.minecraft.world.effect.MobEffectInstance;\r\nimport net.minecraft.world.effect.MobEffects;\r\nimport net.minecraft.world.entity.LivingEntity;\r\nimport net.minecraft.world.entity.MobType;\r\nimport net.minecraft.world.entity.player.Player;\r\n\r\nimport java.util.*;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\n\r\npublic class InebriatedEffectTask extends ScheduledExecuteTask {\r\n    private final LivingEntity pLivingEntity;\r\n    private final Long expireTime;\r\n    /*\r\n    最大持续时间，为防止修改系统时，保险起见使用双判定\r\n     */\r\n    private int maxDurationTicks;\r\n    private int amplifier;\r\n    /*\r\n    tick计数，用于dot伤害之类的计算\r\n     */\r\n    private int tick = 0;\r\n    public InebriatedEffectTask(int initialDelay, int delay, LivingEntity entity, Long durationSeconds, int amplifier) {\r\n            super(initialDelay, delay);\r\n            this.pLivingEntity = entity;\r\n            this.expireTime = TimekeepingTask.getImmortalTickTime() + (long) (durationSeconds * 1000);\r\n            this.amplifier = amplifier;\r\n            this.maxDurationTicks = (int) (durationSeconds * 20 > Integer.MAX_VALUE ? Integer.MAX_VALUE : durationSeconds * 20);\r\n        derivativeEffect.put(MobEffects.MOVEMENT_SLOWDOWN,3600);\r\n        derivativeEffect.put(MobEffects.BLINDNESS,100);\r\n        derivativeEffect.put(MobEffects.WEAKNESS,3600);\r\n        derivativeEffect.put(MobEffects.CONFUSION,3600);\r\n        derivativeEffect.put(MobEffects.POISON,3600);\r\n    }\r\n    public InebriatedEffectTask(int initialDelay, int delay, int taskID, LivingEntity entity, Long durationSeconds, int amplifier) {\r\n        super(initialDelay, delay,taskID);\r\n        this.pLivingEntity = entity;\r\n        this.expireTime = TimekeepingTask.getImmortalTickTime() + (long) (durationSeconds * 1000);\r\n        this.amplifier = amplifier;\r\n        this.maxDurationTicks = (int) (durationSeconds * 20 > Integer.MAX_VALUE ? Integer.MAX_VALUE : durationSeconds * 20);\r\n        ImmortalersDelightMod.LOGGER.info(\"这里是酒精Buff的Task，开始执行，定义的持续时间是\" + maxDurationTicks);\r\n        derivativeEffect.put(MobEffects.MOVEMENT_SLOWDOWN,3600);\r\n        derivativeEffect.put(MobEffects.BLINDNESS,100);\r\n        derivativeEffect.put(MobEffects.WEAKNESS,3600);\r\n        derivativeEffect.put(MobEffects.CONFUSION,3600);\r\n        derivativeEffect.put(MobEffects.POISON,3600);\r\n    }\r\n\r\n    public Map<MobEffect,Integer> derivativeEffect = new ConcurrentHashMap<MobEffect,Integer>();\r\n\r\n    public List<MobEffect> derivativeEffectName = new ArrayList<>();\r\n\r\n    @Override\r\n    public void run() {\r\n        if ((++tick > maxDurationTicks && TimekeepingTask.getImmortalTickTime()> expireTime )\r\n                || !pLivingEntity.isAlive()\r\n                || InebriatedEffect.getEntityMap().get(pLivingEntity.getUUID()) == null) {\r\n            this.cancel();\r\n            return;\r\n        }\r\n        int duration = maxDurationTicks - tick > 0 ? maxDurationTicks - tick : 1;\r\n        int lv = 0;\r\n        int time = 0;\r\n        /*\r\n        实现能续的行为，如果Effect的持续时间更长，更新计划任务的持续时间\r\n         */\r\n        if (pLivingEntity.hasEffect(ImmortalersDelightMobEffect.INEBRIATED.get())) {\r\n            lv = pLivingEntity.hasEffect(ImmortalersDelightMobEffect.INEBRIATED.get())?\r\n                    Objects.requireNonNull(pLivingEntity.getEffect(ImmortalersDelightMobEffect.INEBRIATED.get()).getAmplifier()):0;\r\n            time = pLivingEntity.hasEffect(ImmortalersDelightMobEffect.INEBRIATED.get())?\r\n                    Objects.requireNonNull(pLivingEntity.getEffect(ImmortalersDelightMobEffect.INEBRIATED.get()).getDuration()):0;\r\n            if (lv > amplifier) amplifier = lv;\r\n            if (time - duration > 20) {maxDurationTicks = tick + time;}\r\n        } else if (tick > 1){\r\n            /*\r\n            实现不能解的行为：不断给实体补充对应效果，使得Effect的最短持续时间依赖于计划任务的持续时间\r\n             */\r\n            ImmortalersDelightMod.LOGGER.info(\"持续时间的原始值是\" + (maxDurationTicks - tick) + \",\");\r\n            MobEffectInstance mobEffectInstance = new MobEffectInstance(ImmortalersDelightMobEffect.INEBRIATED.get(),duration,amplifier);\r\n            ImmortalersDelightMod.LOGGER.info(\"这里是酒精的计划任务，检查到buff被解，正在补充buff，数据为\" + duration + \" \" + amplifier);\r\n            pLivingEntity.addEffect(mobEffectInstance);\r\n        }\r\n        /*\r\n        实现醉酒的具体效果\r\n         */\r\n        if (duration > 3600 || time > 3600) ethanolDamage(pLivingEntity, amplifier > lv ? amplifier : lv);\r\n    }\r\n\r\n    public void ethanolDamage (LivingEntity pEntity, int amplifier) {\r\n        float damage = (float) (pEntity.getMaxHealth() * 0.08 );\r\n        damage = pLivingEntity instanceof Player ? Math.max(damage, 1.6F) : Math.min(damage, 1.6F);\r\n        /*\r\n        瓦斯毒伤害，由于需要派生中毒，伤害由setHealth进行以免撞到无敌时间\r\n         */\r\n        if (pEntity.getHealth() - damage > 0) {\r\n            if (tick % (64 >> amplifier) == 0\r\n                    && pEntity.getMobType() != MobType.UNDEAD\r\n                    && pEntity.getHealth() - (damage * 2) > 0) pEntity.setHealth(pEntity.getHealth() - damage);\r\n            /*\r\n            瓦斯毒派生其他DeBuff，通过Map记录DeBuff时间以使得派生的DeBuff也无法通过常规手段解掉\r\n             */\r\n            for (Map.Entry<MobEffect,Integer> entry : derivativeEffect.entrySet()) {\r\n                /*\r\n                如果Buff剩余时间是0，那我们就不管他\r\n                 */\r\n                int duration = entry.getValue();\r\n                if (duration >0) {\r\n                    MobEffect effect = entry.getKey();\r\n\r\n                    if (!pEntity.hasEffect(effect)) {\r\n                        MobEffectInstance effectInstance = new MobEffectInstance(effect,duration,amplifier);\r\n                        pEntity.addEffect(effectInstance);\r\n                    } else {\r\n                        /*\r\n                        如果在已经有了派生buff且持续时间比记录的更长，在此处令派生Buff的持续时间与表中的记录相加\r\n                        用于下面随机刷新DeBuff的方法，以绕开从Map随机的一坨\r\n                         */\r\n                        int time = pEntity.hasEffect(effect)? Objects.requireNonNull(pEntity.getEffect(effect)).getDuration():0;\r\n                        if (time > duration) {\r\n                            derivativeEffect.put(effect,duration + time);\r\n                        }\r\n                    }\r\n                    /*\r\n                    让Map的持续时间-1，不然buff结束不了了\r\n                     */\r\n                    derivativeEffect.put(effect, duration - 1);\r\n                }\r\n            }\r\n            /*\r\n            瓦斯毒刷新DeBuff,每秒令随机一个DeBuff的持续时间+100\r\n             */\r\n            if (tick % 20 == 0) {\r\n                derivativeEffectName = new ArrayList<>();\r\n                for (Map.Entry<MobEffect,Integer> entry : derivativeEffect.entrySet()) {\r\n                    derivativeEffectName.add(entry.getKey());\r\n                }\r\n                int size = derivativeEffectName.size() - 1 > 0 ? derivativeEffectName.size() - 1 : 0;\r\n                ImmortalersDelightMod.LOGGER.info(\"这里是酒精的计划任务，现在有几个能用的DeBuff？\" + derivativeEffectName.size());\r\n                MobEffect randEffect = derivativeEffectName.get(pEntity.getRandom().nextInt(size));\r\n                int time = derivativeEffect.get(randEffect) == null ? derivativeEffect.get(randEffect) : 0;\r\n                derivativeEffect.put(randEffect, time + 100);\r\n            }\r\n        } else {\r\n            /*\r\n            使用setHealth要管杀管埋，写一个秒杀处理负血量情况\r\n             */\r\n            pEntity.hurt(pEntity.damageSources().magic(),pEntity.getMaxHealth() * 2);\r\n            if (pEntity.isAlive() || !pEntity.isRemoved()) {\r\n                pEntity.setHealth(0);\r\n                pEntity.hurt(pEntity.damageSources().fellOutOfWorld(),pEntity.getMaxHealth() * 2);\r\n                //pEntity.die(pEntity.damageSources().fellOutOfWorld());\r\n            }\r\n            this.cancel();\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/InebriatedEffectTask.java b/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/InebriatedEffectTask.java
--- a/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/InebriatedEffectTask.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/potion/immortaleffects/InebriatedEffectTask.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.potion.immortaleffects;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.init.ImmortalersDelightMobEffect;
 import com.renyigesai.immortalers_delight.util.task.ScheduledExecuteTask;
 import com.renyigesai.immortalers_delight.util.task.TimekeepingTask;
Index: src/main/java/com/renyigesai/immortalers_delight/datagen/DataGenerators.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.datagen;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport net.minecraft.core.HolderLookup;\r\nimport net.minecraft.data.DataGenerator;\r\nimport net.minecraft.data.PackOutput;\r\nimport net.minecraftforge.common.data.ExistingFileHelper;\r\nimport net.minecraftforge.data.event.GatherDataEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\nimport java.util.concurrent.CompletableFuture;\r\n\r\n@Mod.EventBusSubscriber(modid = ImmortalersDelightMod.MODID,bus = Mod.EventBusSubscriber.Bus.MOD)\r\npublic class DataGenerators {\r\n    @SubscribeEvent\r\n    public static void gatherData(GatherDataEvent event) {\r\n        DataGenerator generators = event.getGenerator();\r\n        PackOutput output = generators.getPackOutput();\r\n        CompletableFuture<HolderLookup.Provider> lookupProvider = event.getLookupProvider();\r\n\r\n        ExistingFileHelper helper = event.getExistingFileHelper();\r\n\r\n        generators.addProvider(event.includeServer(), new ModWorldGen(output, lookupProvider));\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/datagen/DataGenerators.java b/src/main/java/com/renyigesai/immortalers_delight/datagen/DataGenerators.java
--- a/src/main/java/com/renyigesai/immortalers_delight/datagen/DataGenerators.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/datagen/DataGenerators.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.datagen;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import net.minecraft.core.HolderLookup;
 import net.minecraft.data.DataGenerator;
 import net.minecraft.data.PackOutput;
Index: src/main/java/com/renyigesai/immortalers_delight/datagen/ModWorldGen.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.datagen;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.world.feature.ModConfigureFeature;\r\nimport com.renyigesai.immortalers_delight.world.feature.ModPlacedFeature;\r\nimport net.minecraft.core.HolderLookup;\r\nimport net.minecraft.core.RegistrySetBuilder;\r\nimport net.minecraft.core.registries.Registries;\r\nimport net.minecraft.data.PackOutput;\r\nimport net.minecraftforge.common.data.DatapackBuiltinEntriesProvider;\r\n\r\nimport java.util.Set;\r\nimport java.util.concurrent.CompletableFuture;\r\n\r\npublic class ModWorldGen extends DatapackBuiltinEntriesProvider {\r\n    public static final RegistrySetBuilder BUILDER = new RegistrySetBuilder()\r\n            .add(Registries.CONFIGURED_FEATURE, ModConfigureFeature::bootrap)\r\n            .add(Registries.PLACED_FEATURE, ModPlacedFeature::bootstrap);\r\n    public ModWorldGen(PackOutput output, CompletableFuture<HolderLookup.Provider> registries) {\r\n        super(output, registries, Set.of(ImmortalersDelightMod.MODID));\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/datagen/ModWorldGen.java b/src/main/java/com/renyigesai/immortalers_delight/datagen/ModWorldGen.java
--- a/src/main/java/com/renyigesai/immortalers_delight/datagen/ModWorldGen.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/datagen/ModWorldGen.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.datagen;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.world.feature.ModConfigureFeature;
 import com.renyigesai.immortalers_delight.world.feature.ModPlacedFeature;
 import net.minecraft.core.HolderLookup;
Index: src/main/java/com/renyigesai/immortalers_delight/recipe/EnchantalCoolerRecipe.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.recipe;\r\n\r\nimport com.google.gson.JsonArray;\r\nimport com.google.gson.JsonObject;\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport net.minecraft.core.NonNullList;\r\nimport net.minecraft.core.RegistryAccess;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.util.GsonHelper;\r\nimport net.minecraft.world.SimpleContainer;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.item.crafting.*;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraftforge.common.crafting.CraftingHelper;\r\nimport org.jetbrains.annotations.NotNull;\r\nimport org.jetbrains.annotations.Nullable;\r\nimport org.openjdk.nashorn.internal.objects.annotations.Getter;\r\n\r\npublic class EnchantalCoolerRecipe implements Recipe<SimpleContainer> {\r\n    private final NonNullList<Ingredient> inputItems;\r\n    private final ItemStack output;\r\n    private final ResourceLocation id;\r\n    private final ItemStack container;\r\n\r\n    public EnchantalCoolerRecipe(NonNullList<Ingredient> ingredient, ItemStack output,ItemStack container, ResourceLocation id) {\r\n        this.inputItems = ingredient;\r\n        this.output = output;\r\n        this.id = id;\r\n        if (container.isEmpty()){\r\n            this.container = ItemStack.EMPTY;\r\n        }else {\r\n            this.container = container;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean matches(SimpleContainer pContainer, Level pLevel) {\r\n        if (pLevel.isClientSide) {\r\n            return false;\r\n        }\r\n\r\n        // 检查输入容器中的物品是否与配方匹配\r\n        for (int i = 0; i < inputItems.size(); i++) {\r\n            if (!inputItems.get(i).test(pContainer.getItem(i))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public ItemStack assemble(SimpleContainer pContainer, RegistryAccess pRegistryAccess) {\r\n        return output.copy();\r\n    }\r\n\r\n    @Override\r\n    public boolean canCraftInDimensions(int pWidth, int pHeight) {\r\n        return true;\r\n    }\r\n\r\n    public ItemStack getContainer() {\r\n        return container.copy();\r\n    }\r\n\r\n    @Override\r\n    public ItemStack getResultItem(RegistryAccess pRegistryAccess) {\r\n        return output.copy();\r\n    }\r\n\r\n    @Override\r\n    public ResourceLocation getId() {\r\n        return id;\r\n    }\r\n\r\n    @Override\r\n    public RecipeSerializer<?> getSerializer() {\r\n        return Serializer.INSTANCE;\r\n    }\r\n\r\n    @Override\r\n    public RecipeType<?> getType() {\r\n        return Type.INSTANCE;\r\n    }\r\n\r\n    public static class Type implements RecipeType<EnchantalCoolerRecipe> {\r\n        public static final Type INSTANCE = new Type();\r\n        public static final String ID = \"enchantal_cooler\";\r\n    }\r\n\r\n    public static class Serializer implements RecipeSerializer<EnchantalCoolerRecipe> {\r\n        public static final Serializer INSTANCE = new Serializer();\r\n        public static final ResourceLocation ID = new ResourceLocation(ImmortalersDelightMod.MODID, \"enchantal_cooler\");\r\n\r\n        @Override\r\n        public EnchantalCoolerRecipe fromJson(ResourceLocation pRecipeId, JsonObject pSerializedRecipe) {\r\n            ItemStack output = ShapedRecipe.itemStackFromJson(GsonHelper.getAsJsonObject(pSerializedRecipe, \"output\"));\r\n\r\n            // 动态获取原料数量\r\n            JsonArray ingredients = GsonHelper.getAsJsonArray(pSerializedRecipe, \"ingredients\");\r\n            NonNullList<Ingredient> inputs = NonNullList.create();\r\n\r\n            for (int i = 0; i < ingredients.size(); i++) {\r\n                inputs.add(Ingredient.fromJson(ingredients.get(i)));\r\n            }\r\n            ItemStack container = GsonHelper.isValidNode(pSerializedRecipe, \"container\") ? CraftingHelper.getItemStack(GsonHelper.getAsJsonObject(pSerializedRecipe, \"container\"), true) : ItemStack.EMPTY;\r\n\r\n            return new EnchantalCoolerRecipe(inputs, output,container,pRecipeId);\r\n        }\r\n\r\n        @Override\r\n        public @Nullable EnchantalCoolerRecipe fromNetwork(ResourceLocation pRecipeId, FriendlyByteBuf pBuffer) {\r\n            int ingredientCount = pBuffer.readInt();\r\n            NonNullList<Ingredient> inputs = NonNullList.withSize(ingredientCount, Ingredient.EMPTY);\r\n\r\n            for (int i = 0; i < ingredientCount; i++) {\r\n                inputs.set(i, Ingredient.fromNetwork(pBuffer));\r\n            }\r\n            ItemStack container = pBuffer.readItem();\r\n            ItemStack output = pBuffer.readItem();\r\n            return new EnchantalCoolerRecipe(inputs, output,container,pRecipeId);\r\n        }\r\n\r\n        @Override\r\n        public void toNetwork(FriendlyByteBuf pBuffer, EnchantalCoolerRecipe pRecipe) {\r\n            pBuffer.writeInt(pRecipe.inputItems.size());\r\n\r\n            for (Ingredient ingredient : pRecipe.getIngredients()) {\r\n                ingredient.toNetwork(pBuffer);\r\n            }\r\n            pBuffer.writeItemStack(pRecipe.getResultItem(null), false);\r\n            pBuffer.writeItem(pRecipe.container);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public @NotNull NonNullList<Ingredient> getIngredients() {\r\n        return inputItems;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/recipe/EnchantalCoolerRecipe.java b/src/main/java/com/renyigesai/immortalers_delight/recipe/EnchantalCoolerRecipe.java
--- a/src/main/java/com/renyigesai/immortalers_delight/recipe/EnchantalCoolerRecipe.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/recipe/EnchantalCoolerRecipe.java	
@@ -2,7 +2,7 @@
 
 import com.google.gson.JsonArray;
 import com.google.gson.JsonObject;
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import net.minecraft.core.NonNullList;
 import net.minecraft.core.RegistryAccess;
 import net.minecraft.network.FriendlyByteBuf;
@@ -15,7 +15,6 @@
 import net.minecraftforge.common.crafting.CraftingHelper;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
-import org.openjdk.nashorn.internal.objects.annotations.Getter;
 
 public class EnchantalCoolerRecipe implements Recipe<SimpleContainer> {
     private final NonNullList<Ingredient> inputItems;
Index: src/main/java/com/renyigesai/immortalers_delight/recipe/EnchantalCoolerCategory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.recipe;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightItems;\r\nimport mezz.jei.api.constants.VanillaTypes;\r\nimport mezz.jei.api.gui.builder.IRecipeLayoutBuilder;\r\nimport mezz.jei.api.gui.drawable.IDrawable;\r\nimport mezz.jei.api.helpers.IGuiHelper;\r\nimport mezz.jei.api.recipe.IFocusGroup;\r\nimport mezz.jei.api.recipe.RecipeIngredientRole;\r\nimport mezz.jei.api.recipe.RecipeType;\r\nimport mezz.jei.api.recipe.category.IRecipeCategory;\r\nimport net.minecraft.core.NonNullList;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.item.crafting.Ingredient;\r\nimport org.jetbrains.annotations.Nullable;\r\n\r\nimport java.util.Arrays;\r\n\r\npublic class EnchantalCoolerCategory implements IRecipeCategory<EnchantalCoolerRecipe> {\r\n    public final static ResourceLocation UID = new ResourceLocation(ImmortalersDelightMod.MODID, \"enchantal_cooler\");\r\n    public static final ResourceLocation TEXTURE =\r\n            new ResourceLocation(ImmortalersDelightMod.MODID, \"textures/gui/enchantal_cooler_jei.png\");\r\n\r\n    public final IDrawable back;\r\n    public final IDrawable icon;\r\n\r\n    public EnchantalCoolerCategory(IGuiHelper helper) {\r\n        this.back = helper.createDrawable(TEXTURE,0, 0, 138, 86);\r\n        this.icon = helper.createDrawableIngredient(VanillaTypes.ITEM_STACK,new ItemStack(ImmortalersDelightItems.ENCHANTAL_COOLER.get()));\r\n    }\r\n\r\n    @Override\r\n    public RecipeType<EnchantalCoolerRecipe> getRecipeType() {\r\n        return JEIImmortalersDelightPlugin.ENCHANTAL_COOLER_TYPE;\r\n    }\r\n\r\n    @Override\r\n    public Component getTitle() {\r\n        return Component.translatable(\"container.enchantal_cooler\");\r\n    }\r\n\r\n    @Override\r\n    public @Nullable IDrawable getIcon() {\r\n        return this.icon;\r\n    }\r\n\r\n    @SuppressWarnings(\"removal\")\r\n    @Override\r\n    public IDrawable getBackground() {\r\n        return this.back;\r\n    }\r\n\r\n    @Override\r\n    public void setRecipe(IRecipeLayoutBuilder builder, EnchantalCoolerRecipe recipe, IFocusGroup iFocusGroup) {\r\n        NonNullList<Ingredient> recipeIngredients = recipe.getIngredients();\r\n        int borderSlotSize = 18;\r\n        //x和y轴的初始坐标，取值为gui贴图的x,y初始位置减一\r\n        int x = 13;\r\n        int y = 16;\r\n        //添加原料槽\r\n        for (int row = 0; row < 2; ++row) {\r\n            for (int column = 0; column < 2; ++column) {\r\n                int inputIndex = row * 2 + column;\r\n                if (inputIndex < recipeIngredients.size()) {\r\n                    builder.addSlot(RecipeIngredientRole.INPUT, x + (column * borderSlotSize) + 1, y + (row * borderSlotSize) + 1)\r\n                            .addItemStacks(Arrays.asList(recipeIngredients.get(inputIndex).getItems()));\r\n                }\r\n            }\r\n        }\r\n        //添加容器槽\r\n        builder.addSlot(RecipeIngredientRole.INPUT,99,55).addItemStack(recipe.getContainer());\r\n        //添加输出槽\r\n        builder.addSlot(RecipeIngredientRole.OUTPUT,99,25).addItemStack(recipe.getResultItem(null));\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/recipe/EnchantalCoolerCategory.java b/src/main/java/com/renyigesai/immortalers_delight/recipe/EnchantalCoolerCategory.java
--- a/src/main/java/com/renyigesai/immortalers_delight/recipe/EnchantalCoolerCategory.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/recipe/EnchantalCoolerCategory.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.recipe;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.init.ImmortalersDelightItems;
 import mezz.jei.api.constants.VanillaTypes;
 import mezz.jei.api.gui.builder.IRecipeLayoutBuilder;
Index: src/main/java/com/renyigesai/immortalers_delight/recipe/ImmortalersDelightRecipeTypes.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.recipe;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport net.minecraft.world.item.crafting.RecipeSerializer;\r\nimport net.minecraft.world.item.crafting.RecipeType;\r\nimport net.minecraftforge.eventbus.api.IEventBus;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\nimport net.minecraftforge.fml.event.lifecycle.FMLConstructModEvent;\r\nimport net.minecraftforge.fml.javafmlmod.FMLJavaModLoadingContext;\r\nimport net.minecraftforge.registries.DeferredRegister;\r\nimport net.minecraftforge.registries.ForgeRegistries;\r\n\r\n@Mod.EventBusSubscriber(modid = ImmortalersDelightMod.MODID, bus = Mod.EventBusSubscriber.Bus.MOD)\r\npublic class ImmortalersDelightRecipeTypes {\r\n    public static final DeferredRegister<RecipeSerializer<?>> SERIALIZERS = DeferredRegister.create(ForgeRegistries.RECIPE_SERIALIZERS, ImmortalersDelightMod.MODID);\r\n    public static final DeferredRegister<RecipeType<?>> RECIPE_TYPE = DeferredRegister.create(ForgeRegistries.RECIPE_TYPES, ImmortalersDelightMod.MODID);\r\n\r\n    @SuppressWarnings(\"removal\")\r\n    @SubscribeEvent\r\n    public static void register(FMLConstructModEvent event) {\r\n        IEventBus bus = FMLJavaModLoadingContext.get().getModEventBus();\r\n        event.enqueueWork(() -> {\r\n            SERIALIZERS.register(bus);\r\n            RECIPE_TYPE.register(bus);\r\n\t\t\tSERIALIZERS.register(EnchantalCoolerRecipe.Type.ID,() ->EnchantalCoolerRecipe.Serializer.INSTANCE);\r\n\t\t\tRECIPE_TYPE.register(EnchantalCoolerRecipe.Type.ID,() ->EnchantalCoolerRecipe.Type.INSTANCE);\r\n        });\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/recipe/ImmortalersDelightRecipeTypes.java b/src/main/java/com/renyigesai/immortalers_delight/recipe/ImmortalersDelightRecipeTypes.java
--- a/src/main/java/com/renyigesai/immortalers_delight/recipe/ImmortalersDelightRecipeTypes.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/recipe/ImmortalersDelightRecipeTypes.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.recipe;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import net.minecraft.world.item.crafting.RecipeSerializer;
 import net.minecraft.world.item.crafting.RecipeType;
 import net.minecraftforge.eventbus.api.IEventBus;
Index: src/main/java/com/renyigesai/immortalers_delight/recipe/JEIImmortalersDelightPlugin.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.recipe;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.init.ImmortalersDelightBlocks;\r\nimport com.renyigesai.immortalers_delight.screen.EnchantalCoolerScreen;\r\nimport mezz.jei.api.IModPlugin;\r\nimport mezz.jei.api.JeiPlugin;\r\nimport mezz.jei.api.registration.IGuiHandlerRegistration;\r\nimport mezz.jei.api.registration.IRecipeCatalystRegistration;\r\nimport mezz.jei.api.registration.IRecipeCategoryRegistration;\r\nimport mezz.jei.api.registration.IRecipeRegistration;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.item.crafting.RecipeManager;\r\n\r\nimport java.util.List;\r\nimport java.util.Objects;\r\n\r\n@JeiPlugin\r\npublic class JEIImmortalersDelightPlugin implements IModPlugin {\r\n    public static final mezz.jei.api.recipe.RecipeType<EnchantalCoolerRecipe> ENCHANTAL_COOLER_TYPE = new mezz.jei.api.recipe.RecipeType<>(EnchantalCoolerCategory.UID, EnchantalCoolerRecipe.class);\r\n    @Override\r\n    public ResourceLocation getPluginUid() {\r\n        return new ResourceLocation(ImmortalersDelightMod.MODID,\"jei_plugin\");\r\n    }\r\n\r\n    @Override\r\n    public void registerCategories(IRecipeCategoryRegistration registration) {\r\n        registration.addRecipeCategories(new EnchantalCoolerCategory(registration.getJeiHelpers().getGuiHelper()));\r\n    }\r\n\r\n    @Override\r\n    public void registerRecipes(IRecipeRegistration registration) {\r\n        RecipeManager recipeManager = Objects.requireNonNull(Minecraft.getInstance().level).getRecipeManager();\r\n        List<EnchantalCoolerRecipe> enchantalCoolerRecipes = recipeManager.getAllRecipesFor(EnchantalCoolerRecipe.Type.INSTANCE);\r\n        registration.addRecipes(ENCHANTAL_COOLER_TYPE,enchantalCoolerRecipes);\r\n    }\r\n\r\n    @Override\r\n    public void registerGuiHandlers(IGuiHandlerRegistration registration) {\r\n        registration.addRecipeClickArea(EnchantalCoolerScreen.class,110,16,8,54,\r\n                ENCHANTAL_COOLER_TYPE);\r\n    }\r\n    @Override\r\n    public void registerRecipeCatalysts(IRecipeCatalystRegistration registration) {\r\n        registration.addRecipeCatalyst(new ItemStack(ImmortalersDelightBlocks.ENCHANTAL_COOLER.get()), ENCHANTAL_COOLER_TYPE);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/recipe/JEIImmortalersDelightPlugin.java b/src/main/java/com/renyigesai/immortalers_delight/recipe/JEIImmortalersDelightPlugin.java
--- a/src/main/java/com/renyigesai/immortalers_delight/recipe/JEIImmortalersDelightPlugin.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/recipe/JEIImmortalersDelightPlugin.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.recipe;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.init.ImmortalersDelightBlocks;
 import com.renyigesai.immortalers_delight.screen.EnchantalCoolerScreen;
 import mezz.jei.api.IModPlugin;
Index: src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/MagicalReverseDataStorage.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.util.datautil.datastorage;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.util.datautil.EffectData;\r\nimport net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.nbt.ListTag;\r\nimport net.minecraft.nbt.StringTag;\r\nimport net.minecraft.nbt.Tag;\r\nimport net.minecraftforge.common.util.INBTSerializable;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.UUID;\r\n\r\n// 自定义数据存储类，实现 INBTSerializable 接口\r\npublic class MagicalReverseDataStorage implements INBTSerializable<CompoundTag> {\r\n    private static final String MAGICAL_REVERSE_INFO_NAME = ImmortalersDelightMod.MODID + \"magical_reverse_info\";\r\n    // 要存储的自定义信息\r\n    private Map<UUID, EffectData> entitiesHasMagicalReverseEffect;\r\n\r\n    // 获取自定义信息的方法\r\n    public Map<UUID, EffectData> getEntitiesHasMagicalReverseEffect() {\r\n        return entitiesHasMagicalReverseEffect;\r\n    }\r\n\r\n    // 设置自定义信息的方法\r\n    public void setEntitiesHasMagicalReverseEffect(Map<UUID, EffectData> entitiesHasMagicalReverseEffect) {\r\n        this.entitiesHasMagicalReverseEffect = entitiesHasMagicalReverseEffect;\r\n    }\r\n\r\n    // 将数据写入 NBT 标签的方法\r\n    @Override\r\n    public CompoundTag serializeNBT() {\r\n        CompoundTag tag = new CompoundTag();\r\n        // 将自定义信息写入 NBT 标签\r\n        saveEffectMapToCompoundTag(entitiesHasMagicalReverseEffect, tag, MAGICAL_REVERSE_INFO_NAME);\r\n        return tag;\r\n    }\r\n\r\n    // 从 NBT 标签读取数据的方法\r\n    @Override\r\n    public void deserializeNBT(CompoundTag nbt) {\r\n        // 从 NBT 标签中读取自定义信息\r\n        this.entitiesHasMagicalReverseEffect = loadEffectMapFromCompoundTag(nbt, MAGICAL_REVERSE_INFO_NAME);\r\n    }\r\n\r\n\r\n    /**\r\n     * 将 Map<UUID, EffectData> 保存到 CompoundTag 中\r\n     * @param map 要保存的 Map\r\n     * @return 包含 Map 数据的 CompoundTag\r\n     */\r\n    public static CompoundTag saveEffectMapToCompoundTag(Map<UUID, EffectData> map, CompoundTag compoundTag, String effectID) {\r\n        ListTag uuidList = new ListTag();\r\n        ListTag effectDataList = new ListTag();\r\n\r\n        // 遍历 Map 的键值对\r\n        for (Map.Entry<UUID, EffectData> entry : map.entrySet()) {\r\n            UUID uuid = entry.getKey();\r\n            EffectData effectData = entry.getValue();\r\n\r\n            // 将 UUID 作为字符串添加到 UUID 列表中\r\n            uuidList.add(StringTag.valueOf(uuid.toString()));\r\n            // 将 EffectData 保存到 CompoundTag 并添加到效果数据列表中\r\n            effectDataList.add(effectData.saveToNBT(effectID));\r\n        }\r\n\r\n        // 将 UUID 列表和效果数据列表保存到 CompoundTag 中\r\n        compoundTag.put(effectID + \"uuids\", uuidList);\r\n        compoundTag.put(effectID + \"effectDataList\", effectDataList);\r\n\r\n        return compoundTag;\r\n    }\r\n\r\n    /**\r\n     * 从 CompoundTag 中读取 Map<UUID, EffectData>\r\n     * @param compoundTag 包含 Map 数据的 CompoundTag\r\n     * @return 读取到的 Map\r\n     */\r\n    public static Map<UUID, EffectData> loadEffectMapFromCompoundTag(CompoundTag compoundTag, String effectID) {\r\n        Map<UUID, EffectData> map = new HashMap<>();\r\n\r\n        // 从 CompoundTag 中获取 UUID 列表和效果数据列表\r\n        ListTag uuidList = compoundTag.getList(effectID + \"uuids\", Tag.TAG_STRING);\r\n        ListTag effectDataList = compoundTag.getList(effectID + \"effectDataList\", Tag.TAG_COMPOUND);\r\n\r\n        // 确保 UUID 列表和效果数据列表的长度相同\r\n        if (uuidList.size() == effectDataList.size()) {\r\n            for (int i = 0; i < uuidList.size(); i++) {\r\n                // 获取 UUID\r\n                UUID uuid = UUID.fromString(uuidList.getString(i));\r\n                // 从效果数据列表中获取对应的 CompoundTag 并加载 EffectData\r\n                CompoundTag effectDataTag = effectDataList.getCompound(i);\r\n                EffectData effectData = EffectData.loadFromNBT(effectDataTag,effectID);\r\n\r\n                // 将键值对添加到 Map 中\r\n                map.put(uuid, effectData);\r\n            }\r\n        }\r\n\r\n        return map;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/MagicalReverseDataStorage.java b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/MagicalReverseDataStorage.java
--- a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/MagicalReverseDataStorage.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/MagicalReverseDataStorage.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.util.datautil.datastorage;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.util.datautil.EffectData;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.ListTag;
Index: src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/BaseImmortalDataStorage.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.util.datautil.datastorage;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.util.datautil.EffectData;\r\nimport net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.nbt.ListTag;\r\nimport net.minecraft.nbt.StringTag;\r\nimport net.minecraft.nbt.Tag;\r\nimport net.minecraftforge.common.util.INBTSerializable;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.UUID;\r\n\r\n// 自定义数据存储类，实现 INBTSerializable 接口\r\npublic class BaseImmortalDataStorage implements INBTSerializable<CompoundTag> {\r\n    private static final String BASE_IMMORTAL_INFO_NAME = ImmortalersDelightMod.MODID + \"base_immortal_info\";\r\n    // 要存储的自定义信息\r\n    private Map<UUID, EffectData> entitiesHasBaseImmortalEffect;\r\n\r\n    // 获取自定义信息的方法\r\n    public Map<UUID, EffectData> getEntitiesHasBaseImmortalEffect() {\r\n        return entitiesHasBaseImmortalEffect;\r\n    }\r\n\r\n    // 设置自定义信息的方法\r\n    public void setEntitiesHasBaseImmortalEffect(Map<UUID, EffectData> entitiesHasBaseImmortalEffect) {\r\n        this.entitiesHasBaseImmortalEffect = entitiesHasBaseImmortalEffect;\r\n    }\r\n\r\n    // 将数据写入 NBT 标签的方法\r\n    @Override\r\n    public CompoundTag serializeNBT() {\r\n        CompoundTag tag = new CompoundTag();\r\n        // 将自定义信息写入 NBT 标签\r\n        saveEffectMapToCompoundTag(entitiesHasBaseImmortalEffect, tag, BASE_IMMORTAL_INFO_NAME);\r\n        return tag;\r\n    }\r\n\r\n    // 从 NBT 标签读取数据的方法\r\n    @Override\r\n    public void deserializeNBT(CompoundTag nbt) {\r\n        // 从 NBT 标签中读取自定义信息\r\n        this.entitiesHasBaseImmortalEffect = loadEffectMapFromCompoundTag(nbt, BASE_IMMORTAL_INFO_NAME);\r\n    }\r\n\r\n\r\n    /**\r\n     * 将 Map<UUID, EffectData> 保存到 CompoundTag 中\r\n     * @param map 要保存的 Map\r\n     * @return 包含 Map 数据的 CompoundTag\r\n     */\r\n    public static CompoundTag saveEffectMapToCompoundTag(Map<UUID, EffectData> map, CompoundTag compoundTag, String effectID) {\r\n        ListTag uuidList = new ListTag();\r\n        ListTag effectDataList = new ListTag();\r\n\r\n        // 遍历 Map 的键值对\r\n        for (Map.Entry<UUID, EffectData> entry : map.entrySet()) {\r\n            UUID uuid = entry.getKey();\r\n            EffectData effectData = entry.getValue();\r\n\r\n            // 将 UUID 作为字符串添加到 UUID 列表中\r\n            uuidList.add(StringTag.valueOf(uuid.toString()));\r\n            // 将 EffectData 保存到 CompoundTag 并添加到效果数据列表中\r\n            effectDataList.add(effectData.saveToNBT(effectID));\r\n        }\r\n\r\n        // 将 UUID 列表和效果数据列表保存到 CompoundTag 中\r\n        compoundTag.put(effectID + \"uuids\", uuidList);\r\n        compoundTag.put(effectID + \"effectDataList\", effectDataList);\r\n\r\n        return compoundTag;\r\n    }\r\n\r\n    /**\r\n     * 从 CompoundTag 中读取 Map<UUID, EffectData>\r\n     * @param compoundTag 包含 Map 数据的 CompoundTag\r\n     * @return 读取到的 Map\r\n     */\r\n    public static Map<UUID, EffectData> loadEffectMapFromCompoundTag(CompoundTag compoundTag, String effectID) {\r\n        Map<UUID, EffectData> map = new HashMap<>();\r\n\r\n        // 从 CompoundTag 中获取 UUID 列表和效果数据列表\r\n        ListTag uuidList = compoundTag.getList(effectID + \"uuids\", Tag.TAG_STRING);\r\n        ListTag effectDataList = compoundTag.getList(effectID + \"effectDataList\", Tag.TAG_COMPOUND);\r\n\r\n        // 确保 UUID 列表和效果数据列表的长度相同\r\n        if (uuidList.size() == effectDataList.size()) {\r\n            for (int i = 0; i < uuidList.size(); i++) {\r\n                // 获取 UUID\r\n                UUID uuid = UUID.fromString(uuidList.getString(i));\r\n                // 从效果数据列表中获取对应的 CompoundTag 并加载 EffectData\r\n                CompoundTag effectDataTag = effectDataList.getCompound(i);\r\n                EffectData effectData = EffectData.loadFromNBT(effectDataTag,effectID);\r\n\r\n                // 将键值对添加到 Map 中\r\n                map.put(uuid, effectData);\r\n            }\r\n        }\r\n\r\n        return map;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/BaseImmortalDataStorage.java b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/BaseImmortalDataStorage.java
--- a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/BaseImmortalDataStorage.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/BaseImmortalDataStorage.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.util.datautil.datastorage;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.util.datautil.EffectData;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.ListTag;
Index: src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/ExitTimeDataStorage.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.util.datautil.datastorage;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.util.datautil.EffectData;\r\nimport net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.nbt.ListTag;\r\nimport net.minecraft.nbt.StringTag;\r\nimport net.minecraft.nbt.Tag;\r\nimport net.minecraftforge.common.util.INBTSerializable;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.UUID;\r\n\r\n// 自定义数据存储类，实现 INBTSerializable 接口\r\npublic class ExitTimeDataStorage implements INBTSerializable<CompoundTag> {\r\n    private static final String EXIT_TIME_INFO_NAME = ImmortalersDelightMod.MODID + \"exit_time_info\";\r\n    // 要存储的自定义信息\r\n    private Long exitTime;\r\n\r\n    // 获取自定义信息的方法\r\n    public Long getExitTime() {\r\n        return exitTime;\r\n    }\r\n\r\n    // 设置自定义信息的方法\r\n    public void setExitTime(Long exitTime) {\r\n        this.exitTime = exitTime;\r\n    }\r\n\r\n    // 将数据写入 NBT 标签的方法\r\n    @Override\r\n    public CompoundTag serializeNBT() {\r\n        CompoundTag tag = new CompoundTag();\r\n        // 将自定义信息写入 NBT 标签\r\n        tag.putLong(EXIT_TIME_INFO_NAME, exitTime);\r\n        return tag;\r\n    }\r\n\r\n    // 从 NBT 标签读取数据的方法\r\n    @Override\r\n    public void deserializeNBT(CompoundTag nbt) {\r\n        // 从 NBT 标签中读取自定义信息\r\n        this.exitTime = nbt.getLong(EXIT_TIME_INFO_NAME);\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/ExitTimeDataStorage.java b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/ExitTimeDataStorage.java
--- a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/ExitTimeDataStorage.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/ExitTimeDataStorage.java	
@@ -1,17 +1,9 @@
 package com.renyigesai.immortalers_delight.util.datautil.datastorage;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
-import com.renyigesai.immortalers_delight.util.datautil.EffectData;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import net.minecraft.nbt.CompoundTag;
-import net.minecraft.nbt.ListTag;
-import net.minecraft.nbt.StringTag;
-import net.minecraft.nbt.Tag;
 import net.minecraftforge.common.util.INBTSerializable;
 
-import java.util.HashMap;
-import java.util.Map;
-import java.util.UUID;
-
 // 自定义数据存储类，实现 INBTSerializable 接口
 public class ExitTimeDataStorage implements INBTSerializable<CompoundTag> {
     private static final String EXIT_TIME_INFO_NAME = ImmortalersDelightMod.MODID + "exit_time_info";
Index: src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/GasPoisonDataStorage.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.util.datautil.datastorage;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.util.datautil.EffectData;\r\nimport net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.nbt.ListTag;\r\nimport net.minecraft.nbt.StringTag;\r\nimport net.minecraft.nbt.Tag;\r\nimport net.minecraftforge.common.util.INBTSerializable;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.UUID;\r\n\r\n// 自定义数据存储类，实现 INBTSerializable 接口\r\npublic class GasPoisonDataStorage implements INBTSerializable<CompoundTag> {\r\n    private static final String GAS_POISON_INFO_NAME = ImmortalersDelightMod.MODID + \"gas_poison_info\";\r\n    // 要存储的自定义信息\r\n    private Map<UUID, EffectData> entitiesHasGasPoisonEffect;\r\n\r\n    // 获取自定义信息的方法\r\n    public Map<UUID, EffectData> getEntitiesHasGasPoisonEffect() {\r\n        return entitiesHasGasPoisonEffect;\r\n    }\r\n\r\n    // 设置自定义信息的方法\r\n    public void setEntitiesHasGasPoisonEffect(Map<UUID, EffectData> entitiesHasGasPoisonEffect) {\r\n        this.entitiesHasGasPoisonEffect = entitiesHasGasPoisonEffect;\r\n    }\r\n\r\n    // 将数据写入 NBT 标签的方法\r\n    @Override\r\n    public CompoundTag serializeNBT() {\r\n        CompoundTag tag = new CompoundTag();\r\n        // 将自定义信息写入 NBT 标签\r\n        saveEffectMapToCompoundTag(entitiesHasGasPoisonEffect, tag, GAS_POISON_INFO_NAME);\r\n        return tag;\r\n    }\r\n\r\n    // 从 NBT 标签读取数据的方法\r\n    @Override\r\n    public void deserializeNBT(CompoundTag nbt) {\r\n        // 从 NBT 标签中读取自定义信息\r\n        this.entitiesHasGasPoisonEffect = loadEffectMapFromCompoundTag(nbt, GAS_POISON_INFO_NAME);\r\n    }\r\n\r\n\r\n    /**\r\n     * 将 Map<UUID, EffectData> 保存到 CompoundTag 中\r\n     * @param map 要保存的 Map\r\n     * @return 包含 Map 数据的 CompoundTag\r\n     */\r\n    public static CompoundTag saveEffectMapToCompoundTag(Map<UUID, EffectData> map, CompoundTag compoundTag, String effectID) {\r\n        ListTag uuidList = new ListTag();\r\n        ListTag effectDataList = new ListTag();\r\n\r\n        // 遍历 Map 的键值对\r\n        for (Map.Entry<UUID, EffectData> entry : map.entrySet()) {\r\n            UUID uuid = entry.getKey();\r\n            EffectData effectData = entry.getValue();\r\n\r\n            // 将 UUID 作为字符串添加到 UUID 列表中\r\n            uuidList.add(StringTag.valueOf(uuid.toString()));\r\n            // 将 EffectData 保存到 CompoundTag 并添加到效果数据列表中\r\n            effectDataList.add(effectData.saveToNBT(effectID));\r\n        }\r\n\r\n        // 将 UUID 列表和效果数据列表保存到 CompoundTag 中\r\n        compoundTag.put(effectID + \"uuids\", uuidList);\r\n        compoundTag.put(effectID + \"effectDataList\", effectDataList);\r\n\r\n        return compoundTag;\r\n    }\r\n\r\n    /**\r\n     * 从 CompoundTag 中读取 Map<UUID, EffectData>\r\n     * @param compoundTag 包含 Map 数据的 CompoundTag\r\n     * @return 读取到的 Map\r\n     */\r\n    public static Map<UUID, EffectData> loadEffectMapFromCompoundTag(CompoundTag compoundTag, String effectID) {\r\n        Map<UUID, EffectData> map = new HashMap<>();\r\n\r\n        // 从 CompoundTag 中获取 UUID 列表和效果数据列表\r\n        ListTag uuidList = compoundTag.getList(effectID + \"uuids\", Tag.TAG_STRING);\r\n        ListTag effectDataList = compoundTag.getList(effectID + \"effectDataList\", Tag.TAG_COMPOUND);\r\n\r\n        // 确保 UUID 列表和效果数据列表的长度相同\r\n        if (uuidList.size() == effectDataList.size()) {\r\n            for (int i = 0; i < uuidList.size(); i++) {\r\n                // 获取 UUID\r\n                UUID uuid = UUID.fromString(uuidList.getString(i));\r\n                // 从效果数据列表中获取对应的 CompoundTag 并加载 EffectData\r\n                CompoundTag effectDataTag = effectDataList.getCompound(i);\r\n                EffectData effectData = EffectData.loadFromNBT(effectDataTag,effectID);\r\n\r\n                // 将键值对添加到 Map 中\r\n                map.put(uuid, effectData);\r\n            }\r\n        }\r\n\r\n        return map;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/GasPoisonDataStorage.java b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/GasPoisonDataStorage.java
--- a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/GasPoisonDataStorage.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/GasPoisonDataStorage.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.util.datautil.datastorage;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.util.datautil.EffectData;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.ListTag;
Index: src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/InebriatedDataStorage.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.util.datautil.datastorage;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.util.datautil.EffectData;\r\nimport net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.nbt.ListTag;\r\nimport net.minecraft.nbt.StringTag;\r\nimport net.minecraft.nbt.Tag;\r\nimport net.minecraftforge.common.util.INBTSerializable;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.UUID;\r\n\r\n// 自定义数据存储类，实现 INBTSerializable 接口\r\npublic class InebriatedDataStorage implements INBTSerializable<CompoundTag> {\r\n    private static final String INEBRIATED_INFO_NAME = ImmortalersDelightMod.MODID + \"inebriated_info\";\r\n    // 要存储的自定义信息\r\n    private Map<UUID, EffectData> entitiesHasInebriatedEffect;\r\n\r\n    // 获取自定义信息的方法\r\n    public Map<UUID, EffectData> getEntitiesHasInebriatedEffect() {\r\n        return entitiesHasInebriatedEffect;\r\n    }\r\n\r\n    // 设置自定义信息的方法\r\n    public void setEntitiesHasInebriatedEffect(Map<UUID, EffectData> entitiesHasInebriatedEffect) {\r\n        this.entitiesHasInebriatedEffect = entitiesHasInebriatedEffect;\r\n    }\r\n\r\n    // 将数据写入 NBT 标签的方法\r\n    @Override\r\n    public CompoundTag serializeNBT() {\r\n        CompoundTag tag = new CompoundTag();\r\n        // 将自定义信息写入 NBT 标签\r\n        saveEffectMapToCompoundTag(entitiesHasInebriatedEffect, tag, INEBRIATED_INFO_NAME);\r\n        return tag;\r\n    }\r\n\r\n    // 从 NBT 标签读取数据的方法\r\n    @Override\r\n    public void deserializeNBT(CompoundTag nbt) {\r\n        // 从 NBT 标签中读取自定义信息\r\n        this.entitiesHasInebriatedEffect = loadEffectMapFromCompoundTag(nbt, INEBRIATED_INFO_NAME);\r\n    }\r\n\r\n\r\n    /**\r\n     * 将 Map<UUID, EffectData> 保存到 CompoundTag 中\r\n     * @param map 要保存的 Map\r\n     * @return 包含 Map 数据的 CompoundTag\r\n     */\r\n    public static CompoundTag saveEffectMapToCompoundTag(Map<UUID, EffectData> map, CompoundTag compoundTag, String effectID) {\r\n        ListTag uuidList = new ListTag();\r\n        ListTag effectDataList = new ListTag();\r\n\r\n        // 遍历 Map 的键值对\r\n        for (Map.Entry<UUID, EffectData> entry : map.entrySet()) {\r\n            UUID uuid = entry.getKey();\r\n            EffectData effectData = entry.getValue();\r\n\r\n            // 将 UUID 作为字符串添加到 UUID 列表中\r\n            uuidList.add(StringTag.valueOf(uuid.toString()));\r\n            // 将 EffectData 保存到 CompoundTag 并添加到效果数据列表中\r\n            effectDataList.add(effectData.saveToNBT(effectID));\r\n        }\r\n\r\n        // 将 UUID 列表和效果数据列表保存到 CompoundTag 中\r\n        compoundTag.put(effectID + \"uuids\", uuidList);\r\n        compoundTag.put(effectID + \"effectDataList\", effectDataList);\r\n\r\n        return compoundTag;\r\n    }\r\n\r\n    /**\r\n     * 从 CompoundTag 中读取 Map<UUID, EffectData>\r\n     * @param compoundTag 包含 Map 数据的 CompoundTag\r\n     * @return 读取到的 Map\r\n     */\r\n    public static Map<UUID, EffectData> loadEffectMapFromCompoundTag(CompoundTag compoundTag, String effectID) {\r\n        Map<UUID, EffectData> map = new HashMap<>();\r\n\r\n        // 从 CompoundTag 中获取 UUID 列表和效果数据列表\r\n        ListTag uuidList = compoundTag.getList(effectID + \"uuids\", Tag.TAG_STRING);\r\n        ListTag effectDataList = compoundTag.getList(effectID + \"effectDataList\", Tag.TAG_COMPOUND);\r\n\r\n        // 确保 UUID 列表和效果数据列表的长度相同\r\n        if (uuidList.size() == effectDataList.size()) {\r\n            for (int i = 0; i < uuidList.size(); i++) {\r\n                // 获取 UUID\r\n                UUID uuid = UUID.fromString(uuidList.getString(i));\r\n                // 从效果数据列表中获取对应的 CompoundTag 并加载 EffectData\r\n                CompoundTag effectDataTag = effectDataList.getCompound(i);\r\n                EffectData effectData = EffectData.loadFromNBT(effectDataTag,effectID);\r\n\r\n                // 将键值对添加到 Map 中\r\n                map.put(uuid, effectData);\r\n            }\r\n        }\r\n\r\n        return map;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/InebriatedDataStorage.java b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/InebriatedDataStorage.java
--- a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/InebriatedDataStorage.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datastorage/InebriatedDataStorage.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.util.datautil.datastorage;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.util.datautil.EffectData;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.ListTag;
Index: src/main/java/com/renyigesai/immortalers_delight/util/datautil/datasaveloadhelper/MagicalReverseMapSaveLoadHelper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.util.datautil.datasaveloadhelper;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.potion.immortaleffects.MagicalReverseEffect;\r\nimport com.renyigesai.immortalers_delight.util.datautil.EffectData;\r\nimport com.renyigesai.immortalers_delight.util.datautil.datastorage.MagicalReverseDataStorage;\r\nimport com.renyigesai.immortalers_delight.util.datautil.worlddata.MagicalReverseWorldData;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraftforge.event.level.LevelEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\nimport java.util.Map;\r\nimport java.util.UUID;\r\n\r\n// 使用自定义数据存储的示例类\r\n@Mod.EventBusSubscriber\r\npublic class MagicalReverseMapSaveLoadHelper {\r\n    // 存储自定义信息的方法\r\n    public static void saveEntityHasEffect (Level level, Map<UUID, EffectData> entitiesHasMagicalReverseEffect) {\r\n        if (level instanceof ServerLevel serverLevel) {\r\n            // 获取自定义世界数据实例\r\n            MagicalReverseWorldData data = MagicalReverseWorldData.get(serverLevel);\r\n            // 获取自定义数据存储实例\r\n            MagicalReverseDataStorage customData = data.getCustomData();\r\n            // 设置自定义信息\r\n            customData.setEntitiesHasMagicalReverseEffect(entitiesHasMagicalReverseEffect);\r\n            // 标记数据已更改，以便保存\r\n            data.setDirty();\r\n        }\r\n    }\r\n\r\n    // 读取自定义信息的方法\r\n    public static Map<UUID, EffectData> loadEntityHasEffect (Level level) {\r\n        if (level instanceof ServerLevel serverLevel) {\r\n            // 获取自定义世界数据实例\r\n            MagicalReverseWorldData data = MagicalReverseWorldData.get(serverLevel);\r\n            // 获取自定义数据存储实例\r\n            MagicalReverseDataStorage customData = data.getCustomData();\r\n            // 返回自定义信息\r\n            return customData.getEntitiesHasMagicalReverseEffect();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // 订阅世界保存事件，在此处保存游戏退出时的系统时间\r\n    @SubscribeEvent\r\n    public static void onWorldSave(LevelEvent.Save event) {\r\n        if (event.getLevel() instanceof ServerLevel serverLevel) {\r\n            saveEntityHasEffect(serverLevel, MagicalReverseEffect.getEntityMap());\r\n//            ImmortalersDelightMod.LOGGER.info(\"这里是世界保存，正在保存实体Map\");\r\n            // 输出读取到的 Map\r\n            for (Map.Entry<UUID, EffectData> entry : MagicalReverseEffect.getEntityMap().entrySet()) {\r\n                UUID uuid = entry.getKey();\r\n                EffectData effectData = entry.getValue();\r\n//                ImmortalersDelightMod.LOGGER.info(\"UUID: \" + uuid + \", Effect Level: \" + effectData.getAmplifier() +\r\n//                        \", Duration: \" + effectData.getTime() + \", Task ID \" + effectData.getTaskId());\r\n            }\r\n            MagicalReverseEffect.setPausing(true);\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datasaveloadhelper/MagicalReverseMapSaveLoadHelper.java b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datasaveloadhelper/MagicalReverseMapSaveLoadHelper.java
--- a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datasaveloadhelper/MagicalReverseMapSaveLoadHelper.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datasaveloadhelper/MagicalReverseMapSaveLoadHelper.java	
@@ -1,6 +1,5 @@
 package com.renyigesai.immortalers_delight.util.datautil.datasaveloadhelper;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.potion.immortaleffects.MagicalReverseEffect;
 import com.renyigesai.immortalers_delight.util.datautil.EffectData;
 import com.renyigesai.immortalers_delight.util.datautil.datastorage.MagicalReverseDataStorage;
Index: src/main/java/com/renyigesai/immortalers_delight/util/datautil/datasaveloadhelper/GasPoisonMapSaveLoadHelper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.util.datautil.datasaveloadhelper;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.potion.immortaleffects.GasPoisonEffect;\r\nimport com.renyigesai.immortalers_delight.util.datautil.EffectData;\r\nimport com.renyigesai.immortalers_delight.util.datautil.datastorage.GasPoisonDataStorage;\r\nimport com.renyigesai.immortalers_delight.util.datautil.worlddata.GasPoisonWorldData;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraftforge.event.level.LevelEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\nimport java.util.Map;\r\nimport java.util.UUID;\r\n\r\n// 使用自定义数据存储的示例类\r\n@Mod.EventBusSubscriber\r\npublic class GasPoisonMapSaveLoadHelper {\r\n    // 存储自定义信息的方法\r\n    public static void saveEntityHasEffect (Level level, Map<UUID, EffectData> entitiesHasGasPoisonEffect) {\r\n        if (level instanceof ServerLevel serverLevel) {\r\n            // 获取自定义世界数据实例\r\n            GasPoisonWorldData data = GasPoisonWorldData.get(serverLevel);\r\n            // 获取自定义数据存储实例\r\n            GasPoisonDataStorage customData = data.getCustomData();\r\n            // 设置自定义信息\r\n            customData.setEntitiesHasGasPoisonEffect(entitiesHasGasPoisonEffect);\r\n            // 标记数据已更改，以便保存\r\n            data.setDirty();\r\n        }\r\n    }\r\n\r\n    // 读取自定义信息的方法\r\n    public static Map<UUID, EffectData> loadEntityHasEffect (Level level) {\r\n        if (level instanceof ServerLevel serverLevel) {\r\n            // 获取自定义世界数据实例\r\n            GasPoisonWorldData data = GasPoisonWorldData.get(serverLevel);\r\n            // 获取自定义数据存储实例\r\n            GasPoisonDataStorage customData = data.getCustomData();\r\n            // 返回自定义信息\r\n            return customData.getEntitiesHasGasPoisonEffect();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // 订阅世界保存事件，在此处保存游戏退出时的系统时间\r\n    @SubscribeEvent\r\n    public static void onWorldSave(LevelEvent.Save event) {\r\n        if (event.getLevel() instanceof ServerLevel serverLevel) {\r\n            saveEntityHasEffect(serverLevel, GasPoisonEffect.getEntityMap());\r\n//            ImmortalersDelightMod.LOGGER.info(\"这里是世界保存，正在保存实体Map\");\r\n            // 输出读取到的 Map\r\n            for (Map.Entry<UUID, EffectData> entry : GasPoisonEffect.getEntityMap().entrySet()) {\r\n                UUID uuid = entry.getKey();\r\n                EffectData effectData = entry.getValue();\r\n//                ImmortalersDelightMod.LOGGER.info(\"UUID: \" + uuid + \", Effect Level: \" + effectData.getAmplifier() +\r\n//                        \", Duration: \" + effectData.getTime() + \", Task ID \" + effectData.getTaskId());\r\n            }\r\n            GasPoisonEffect.setPausing(true);\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datasaveloadhelper/GasPoisonMapSaveLoadHelper.java b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datasaveloadhelper/GasPoisonMapSaveLoadHelper.java
--- a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datasaveloadhelper/GasPoisonMapSaveLoadHelper.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datasaveloadhelper/GasPoisonMapSaveLoadHelper.java	
@@ -1,6 +1,5 @@
 package com.renyigesai.immortalers_delight.util.datautil.datasaveloadhelper;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.potion.immortaleffects.GasPoisonEffect;
 import com.renyigesai.immortalers_delight.util.datautil.EffectData;
 import com.renyigesai.immortalers_delight.util.datautil.datastorage.GasPoisonDataStorage;
Index: src/main/java/com/renyigesai/immortalers_delight/util/datautil/datasaveloadhelper/InebriatedMapSaveLoadHelper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.util.datautil.datasaveloadhelper;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.potion.immortaleffects.InebriatedEffect;\r\nimport com.renyigesai.immortalers_delight.util.datautil.EffectData;\r\nimport com.renyigesai.immortalers_delight.util.datautil.datastorage.InebriatedDataStorage;\r\nimport com.renyigesai.immortalers_delight.util.datautil.worlddata.InebriatedWorldData;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraftforge.event.level.LevelEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\nimport java.util.Map;\r\nimport java.util.UUID;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\n\r\n// 使用自定义数据存储的示例类\r\n@Mod.EventBusSubscriber\r\npublic class InebriatedMapSaveLoadHelper {\r\n    // 存储自定义信息的方法\r\n    public static void saveEntityHasEffect (Level level, Map<UUID, EffectData> entitiesHasInebriatedEffect) {\r\n        if (level instanceof ServerLevel serverLevel) {\r\n            // 获取自定义世界数据实例\r\n            InebriatedWorldData data = InebriatedWorldData.get(serverLevel);\r\n            // 获取自定义数据存储实例\r\n            InebriatedDataStorage customData = data.getCustomData();\r\n            Map<UUID,EffectData> copyMap = new ConcurrentHashMap<>(entitiesHasInebriatedEffect);\r\n            // 设置自定义信息\r\n            customData.setEntitiesHasInebriatedEffect(copyMap);\r\n            // 标记数据已更改，以便保存\r\n            data.setDirty();\r\n        }\r\n    }\r\n\r\n    // 读取自定义信息的方法\r\n    public static Map<UUID, EffectData> loadEntityHasEffect (Level level) {\r\n        if (level instanceof ServerLevel serverLevel) {\r\n            // 获取自定义世界数据实例\r\n            InebriatedWorldData data = InebriatedWorldData.get(serverLevel);\r\n            // 获取自定义数据存储实例\r\n            InebriatedDataStorage customData = data.getCustomData();\r\n            // 返回自定义信息\r\n            return customData.getEntitiesHasInebriatedEffect();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // 订阅世界保存事件，在此处保存游戏退出时的系统时间\r\n    @SubscribeEvent\r\n    public static void onWorldSave(LevelEvent.Save event) {\r\n        if (event.getLevel() instanceof ServerLevel serverLevel) {\r\n            saveEntityHasEffect(serverLevel, InebriatedEffect.getEntityMap());\r\n//            ImmortalersDelightMod.LOGGER.info(\"这里是世界保存，正在保存实体Map\");\r\n            // 输出读取到的 Map\r\n            for (Map.Entry<UUID, EffectData> entry : InebriatedEffect.getEntityMap().entrySet()) {\r\n                UUID uuid = entry.getKey();\r\n                EffectData effectData = entry.getValue();\r\n//                ImmortalersDelightMod.LOGGER.info(\"UUID: \" + uuid + \", Effect Level: \" + effectData.getAmplifier() +\r\n//                        \", Duration: \" + effectData.getTime() + \", Task ID \" + effectData.getTaskId());\r\n            }\r\n            InebriatedEffect.setPausing(true);\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datasaveloadhelper/InebriatedMapSaveLoadHelper.java b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datasaveloadhelper/InebriatedMapSaveLoadHelper.java
--- a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datasaveloadhelper/InebriatedMapSaveLoadHelper.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datasaveloadhelper/InebriatedMapSaveLoadHelper.java	
@@ -1,6 +1,5 @@
 package com.renyigesai.immortalers_delight.util.datautil.datasaveloadhelper;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.potion.immortaleffects.InebriatedEffect;
 import com.renyigesai.immortalers_delight.util.datautil.EffectData;
 import com.renyigesai.immortalers_delight.util.datautil.datastorage.InebriatedDataStorage;
Index: src/main/java/com/renyigesai/immortalers_delight/screen/EnchantalCoolerScreen.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.screen;\r\n\r\nimport com.mojang.blaze3d.systems.RenderSystem;\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport net.minecraft.client.gui.GuiGraphics;\r\nimport net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;\r\nimport net.minecraft.client.renderer.GameRenderer;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.entity.player.Inventory;\r\n\r\npublic class EnchantalCoolerScreen extends AbstractContainerScreen<EnchantalCoolerMenu> {\r\n\r\n    // GUI 纹理路径\r\n    private static final ResourceLocation TEXTURE =\r\n            new ResourceLocation(ImmortalersDelightMod.MODID, \"textures/gui/enchantal_cooler.png\");\r\n\r\n    public EnchantalCoolerScreen(EnchantalCoolerMenu menu, Inventory playerInventory, Component title) {\r\n        super(menu, playerInventory, title);\r\n        this.imageWidth = 176; // GUI 宽度\r\n        this.imageHeight = 166; // GUI 高度\r\n    }\r\n\r\n    @Override\r\n    protected void renderBg(GuiGraphics pGuiGraphics, float partialTicks, int mouseX, int mouseY) {\r\n        // 设置渲染系统\r\n        RenderSystem.setShader(GameRenderer::getPositionTexShader);\r\n        RenderSystem.setShaderColor(1.0F, 1.0F, 1.0F, 1.0F);\r\n        RenderSystem.setShaderTexture(0, TEXTURE);\r\n\r\n        // 计算 GUI 的左上角位置\r\n        int x = (width - imageWidth) / 2;\r\n        int y = (height - imageHeight) / 2;\r\n\r\n        // 绘制背景\r\n        pGuiGraphics.blit(TEXTURE, x, y, 0, 0, imageWidth, imageHeight);\r\n\r\n        // 绘制进度条\r\n        int width = menu.getBlockEntity().cookingTotalTime;\r\n        int progressWidth = (int) (24 * (width / 100.0f));\r\n        pGuiGraphics.blit(TEXTURE, x + 103, y + 26, 177, 19, progressWidth, 17); // 绘制进度条\r\n        int residualDye = menu.getBlockEntity().residualDye;\r\n        int pngNewY = 86 - 10 * residualDye;\r\n        int newY = y + 48 - 10 * residualDye;\r\n        pGuiGraphics.blit(TEXTURE, x + 27, newY, 176, pngNewY, 9, menu.getBlockEntity().residualDye*10);\r\n\r\n    }\r\n\r\n    @Override\r\n    public void render(GuiGraphics poseStack, int mouseX, int mouseY, float partialTicks) {\r\n        renderBackground(poseStack);\r\n\r\n        // 调用父类渲染方法\r\n        super.render(poseStack, mouseX, mouseY, partialTicks);\r\n\r\n        // 渲染物品栏提示\r\n        renderTooltip(poseStack, mouseX, mouseY);\r\n    }\r\n\r\n    @Override\r\n    protected void renderLabels(GuiGraphics p_281635_, int p_282681_, int p_283686_) {\r\n        super.renderLabels(p_281635_, p_282681_, p_283686_);\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/screen/EnchantalCoolerScreen.java b/src/main/java/com/renyigesai/immortalers_delight/screen/EnchantalCoolerScreen.java
--- a/src/main/java/com/renyigesai/immortalers_delight/screen/EnchantalCoolerScreen.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/screen/EnchantalCoolerScreen.java	
@@ -1,7 +1,7 @@
 package com.renyigesai.immortalers_delight.screen;
 
 import com.mojang.blaze3d.systems.RenderSystem;
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import net.minecraft.client.gui.GuiGraphics;
 import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
 import net.minecraft.client.renderer.GameRenderer;
Index: src/main/java/com/renyigesai/immortalers_delight/util/datautil/datasaveloadhelper/BaseImmortalMapSaveLoadHelper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.util.datautil.datasaveloadhelper;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.potion.immortaleffects.BaseImmortalEffect;\r\nimport com.renyigesai.immortalers_delight.util.datautil.EffectData;\r\nimport com.renyigesai.immortalers_delight.util.datautil.datastorage.BaseImmortalDataStorage;\r\nimport com.renyigesai.immortalers_delight.util.datautil.worlddata.BaseImmortalWorldData;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraftforge.event.level.LevelEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\nimport java.util.Map;\r\nimport java.util.UUID;\r\n\r\n// 使用自定义数据存储的示例类\r\n@Mod.EventBusSubscriber\r\npublic class BaseImmortalMapSaveLoadHelper {\r\n    // 存储自定义信息的方法\r\n    public static void saveEntityHasEffect (Level level, Map<UUID, EffectData> entitiesHasBaseImmortalEffect) {\r\n        if (level instanceof ServerLevel serverLevel) {\r\n            // 获取自定义世界数据实例\r\n            BaseImmortalWorldData data = BaseImmortalWorldData.get(serverLevel);\r\n            // 获取自定义数据存储实例\r\n            BaseImmortalDataStorage customData = data.getCustomData();\r\n            // 设置自定义信息\r\n            customData.setEntitiesHasBaseImmortalEffect(entitiesHasBaseImmortalEffect);\r\n            // 标记数据已更改，以便保存\r\n            data.setDirty();\r\n        }\r\n    }\r\n\r\n    // 读取自定义信息的方法\r\n    public static Map<UUID, EffectData> loadEntityHasEffect (Level level) {\r\n        if (level instanceof ServerLevel serverLevel) {\r\n            // 获取自定义世界数据实例\r\n            BaseImmortalWorldData data = BaseImmortalWorldData.get(serverLevel);\r\n            // 获取自定义数据存储实例\r\n            BaseImmortalDataStorage customData = data.getCustomData();\r\n            // 返回自定义信息\r\n            return customData.getEntitiesHasBaseImmortalEffect();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // 订阅世界保存事件，在此处保存游戏退出时的系统时间\r\n    @SubscribeEvent\r\n    public static void onWorldSave(LevelEvent.Save event) {\r\n        if (event.getLevel() instanceof ServerLevel serverLevel) {\r\n            saveEntityHasEffect(serverLevel, BaseImmortalEffect.getEntityMap());\r\n//            ImmortalersDelightMod.LOGGER.info(\"这里是世界保存，正在保存实体Map\");\r\n            // 输出读取到的 Map\r\n            for (Map.Entry<UUID, EffectData> entry : BaseImmortalEffect.getEntityMap().entrySet()) {\r\n                UUID uuid = entry.getKey();\r\n                EffectData effectData = entry.getValue();\r\n//                ImmortalersDelightMod.LOGGER.info(\"UUID: \" + uuid + \", Effect Level: \" + effectData.getAmplifier() +\r\n//                        \", Duration: \" + effectData.getTime() + \", Task ID \" + effectData.getTaskId());\r\n            }\r\n            BaseImmortalEffect.setPausing(true);\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datasaveloadhelper/BaseImmortalMapSaveLoadHelper.java b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datasaveloadhelper/BaseImmortalMapSaveLoadHelper.java
--- a/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datasaveloadhelper/BaseImmortalMapSaveLoadHelper.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/util/datautil/datasaveloadhelper/BaseImmortalMapSaveLoadHelper.java	
@@ -1,6 +1,5 @@
 package com.renyigesai.immortalers_delight.util.datautil.datasaveloadhelper;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
 import com.renyigesai.immortalers_delight.potion.immortaleffects.BaseImmortalEffect;
 import com.renyigesai.immortalers_delight.util.datautil.EffectData;
 import com.renyigesai.immortalers_delight.util.datautil.datastorage.BaseImmortalDataStorage;
Index: src/main/resources/assets/immortalers_delight/lang/en_us.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\r\n  \"creativetab_immortalers_delight_tab\": \"Immortalers Delight\",\r\n  \"item.immortalers_delight.evolutcorn\": \"Evolutcorn\",\r\n  \"item.immortalers_delight.evolutcorn_grains\": \"Evolutcorn Grains\",\r\n  \"item.immortalers_delight.roast_evolutcorn_chops\": \"Roast Evolutcorn Chops\",\r\n  \"item.immortalers_delight.ancient_fiber\": \"Ancient Fiber\",\r\n  \"item.immortalers_delight.roast_evolutcorn\": \"Bake Corn\",\r\n  \"item.immortalers_delight.bowl_of_millenian_bamboo\": \"Bowl Of Millenian Bamboo\",\r\n  \"item.immortalers_delight.cretaceous_zea_ball\": \"Cretaceous Zea Ball\",\r\n  \"item.immortalers_delight.colorful_grilled_skewers\": \"Colorful Grilled Skewers\",\r\n  \"item.immortalers_delight.popolutcorn\": \"Popolutcorn\",\r\n  \"item.immortalers_delight.zea_pancake_slice\": \"Zea Pancake Slice\",\r\n  \"item.immortalers_delight.evolutcorn_pie_crust\": \"Evolutcorn Pie Crust\",\r\n  \"item.immortalers_delight.evolutcorn_beer\": \"Evolutcorn Beer\",\r\n  \"item.immortalers_delight.pearlip_pie_slice\": \"Pearlip Pie Slice\",\r\n  \"item.immortalers_delight.peatic_musa_salad\": \"Peatic Musa Salad\",\r\n  \"item.immortalers_delight.pearlip\": \"Pearlip\",\r\n  \"item.immortalers_delight.pearlip_shell\": \"Pearlip Shell\",\r\n  \"item.immortalers_delight.pearlipearl\": \"Pearlipearl\",\r\n  \"item.immortalers_delight.pearlip_pumpkin_pie\": \"Pearlip Pumpkin Pie\",\r\n  \"item.immortalers_delight.pearlipearl_tart\": \"Pearlipearl Tart\",\r\n  \"item.immortalers_delight.pearlip_milk_shake\": \"Pearlip Milk Shake\",\r\n  \"item.immortalers_delight.pearlip_jelly\": \"Earlip Jelly\",\r\n  \"item.immortalers_delight.pearlipearl_eggsteam\": \"Pearlipearl Eggsteam\",\r\n  \"item.immortalers_delight.himekaido_cuts\": \"Himekaido Cuts\",\r\n  \"item.immortalers_delight.himekaido_seed\": \"Himekaido Seed\",\r\n  \"item.immortalers_delight.rotten_flesh_cuts\": \"Rotten Flesh Cuts\",\r\n  \"item.immortalers_delight.himekaido_jelly\": \"Himekaido Jelly\",\r\n  \"item.immortalers_delight.yogurt\": \"Yogurt\",\r\n  \"item.immortalers_delight.himekaido\": \"Himekaido\",\r\n  \"item.immortalers_delight.baked_poisonous_potato\": \"Baked Poisonous Potato\",\r\n  \"item.immortalers_delight.braised_spider_eyes_in_gravy\": \"Bowl Of Braised Spider Eyes in Gravy\",\r\n  \"item.immortalers_delight.tartare_chicken\": \"Tartare Chicken\",\r\n  \"item.immortalers_delight.dipped_rotten_flesh\": \"Dipped Rotten Flesh\",\r\n  \"item.immortalers_delight.crispy_yogurt_rotten_flesh\": \"Crispy Yogurt Rotten Flesh\",\r\n  \"item.immortalers_delight.meaty_rotten_tomato_broth\": \"Meaty Rotten Tomato Broth\",\r\n  \"item.immortalers_delight.stuffed_poisonous_potato\": \"Stuffed Poisonous Potato\",\r\n  \"item.immortalers_delight.pufferfish_roll\": \"Pufferfish Roll\",\r\n  \"item.immortalers_delight.bowl_of_stewed_rotten_meat_in_clay_pot\": \"Bowl of Stewed Rotten Meat in Clay Pot\",\r\n  \"item.immortalers_delight.golden_himekaido\": \"Golden Himekaido\",\r\n  \"item.immortalers_delight.enchanted_golden_himekaido\": \"Enchanted Golden Himekaido\",\r\n  \"item.immortalers_delight.himekaido_yogurt_pie_slice\": \"Himekaido Yogurt Pie Slice\",\r\n  \"item.immortalers_delight.dreumk_wine\": \"Dreumk Wine\",\r\n  \"item.immortalers_delight.contains_tea_leisamboo\": \"Contains Tea Leisamboo\",\r\n  \"item.immortalers_delight.empty_bamboo_cup\": \"Empty Bamboo Cup\",\r\n  \"item.immortalers_delight.leisamboo_tea\": \"Leisamboo Tea\",\r\n  \"item.immortalers_delight.iced_black_tea\": \"Iced Black Tea\",\r\n  \"item.immortalers_delight.pearlipearl_milk_tea\": \"Pearlipearl Milk Tea\",\r\n  \"item.immortalers_delight.pearlipearl_milk_green\": \"Pearlipearl Milk Green\",\r\n  \"item.immortalers_delight.stove_black_tea\": \"Stove Black Tea\",\r\n  \"item.immortalers_delight.leaf_green_tea\": \"Leaf Green Tea\",\r\n  \"item.immortalers_delight.british_yellow_tea\": \"British Yellow Tea\",\r\n  \"item.immortalers_delight.leaf_tea\": \"Leaf Tea\",\r\n  \"item.immortalers_delight.pitcher_pod_petal\": \"Pitcher Pod Ppetal\",\r\n  \"item.immortalers_delight.kwat_wheat_seeds\": \"Kwat Wheat Seeds\",\r\n  \"item.immortalers_delight.kwat_wheat\": \"Kwat Wheat\",\r\n  \"item.immortalers_delight.golden_fabric\": \"Golden Fabric\",\r\n  \"item.immortalers_delight.golden_fabric_veil\": \"golden Fabric Veil\",\r\n  \"item.immortalers_delight.clear_water_vodka\": \"Clear Water Vodka\",\r\n  \"item.immortalers_delight.raw_sniffer_slice\": \"Raw Sniffer Slice\",\r\n  \"item.immortalers_delight.cooked_sniffer_slice\": \"Cooked Sniffer Slice\",\r\n  \"item.immortalers_delight.raw_sniffer_steak\": \"Raw Sniffer Steak\",\r\n  \"item.immortalers_delight.cooked_sniffer_steak\": \"Cooked Sniffer Steak\",\r\n  \"item.immortalers_delight.rotating_roast_meat\": \"Rotating Roast Meat\",\r\n  \"item.immortalers_delight.sniffer_hide\": \"Sniffer Hide\",\r\n  \"item.immortalers_delight.vulcan_coktail\": \"Vulcan Coktail\",\r\n  \"item.immortalers_delight.kwat_wheat_dough\": \"Kwat Wheat Dough\",\r\n  \"item.immortalers_delight.kwat_wheat_paste\": \"Kwat Wheat Paste\",\r\n  \"item.immortalers_delight.kwat_wheat_doufu\": \"Kwat Wheat Doufu\",\r\n  \"item.immortalers_delight.fry_kwat_wheat_doufu\": \"Fry Kwat Wheat Doufu\",\r\n  \"item.immortalers_delight.jade_and_ruby_soup\": \"Jade And Ruby Soup\",\r\n  \"item.immortalers_delight.kwat_wheat_toast\": \"Kwat Wheat Toast\",\r\n  \"item.immortalers_delight.kwat_wheat_toast_slice\": \"Kwat Wheat Toast Slice\",\r\n  \"item.immortalers_delight.nether_cream_soup\": \"Nether Cream Soup\",\r\n  \"item.immortalers_delight.nether_cream_bread\": \"Nether Cream Bread\",\r\n  \"item.immortalers_delight.himekaido_boat\": \"Himekaido Boat\",\r\n  \"item.immortalers_delight.himekaido_chest_boat\": \"Himekaido Boat with Chest\",\r\n  \"item.immortalers_delight.torchflower_mustard\": \"Torchflower Mustard\",\r\n  \"item.immortalers_delight.hot_hi_soup\": \"Hot Hi Soup\",\r\n  \"item.immortalers_delight.incandescence_sushi\": \"Incandescence Sushi\",\r\n  \"item.immortalers_delight.torchflower_cookie\": \"Torchflower Cookie\",\r\n  \"item.immortalers_delight.torchflower_cake\": \"Torchflower Cake\",\r\n  \"item.immortalers_delight.torchflower_curry_rice\": \"Torchflower Curry Rice\",\r\n  \"item.immortalers_delight.extra_spicy_pasta\": \"Extra Spicy Pasta\",\r\n  \"item.immortalers_delight.himekaido_boat\": \"Himekaido Boat\",\r\n  \"item.immortalers_delight.himekaido_chest_boat\": \"Himekaido Boat with Chest\",\r\n  \"item.immortalers_delight.torchflower_mustard\": \"Torchflower Mustard\",\r\n  \"item.immortalers_delight.hot_hi_soup\": \"Hot Hi Soup\",\r\n  \"item.immortalers_delight.incandescence_sushi\": \"Incandescence Sushi\",\r\n  \"item.immortalers_delight.torchflower_cookie\": \"Torchflower Cookie\",\r\n  \"item.immortalers_delight.torchflower_cake\": \"Torchflower Cake\",\r\n  \"item.immortalers_delight.torchflower_curry_rice\": \"Torchflower Curry Rice\",\r\n  \"item.immortalers_delight.extra_spicy_pasta\": \"Extra Spicy Pasta\",\r\n  \"item.immortalers_delight.mashed_potatoes\": \"Mashed Potatoes\",\r\n  \"item.immortalers_delight.mashed_poisonous_potato\": \"Mashed Poisonous Potato\",\r\n  \"item.immortalers_delight.mashed_potato_with_jam\": \"Mashed Potato With Jam\",\r\n  \"item.immortalers_delight.mashed_poisonous_potato_with_jam\": \"Mashed Poisonous Potato With Jam\",\r\n  \"item.immortalers_delight.sutffed_kwat_wheat_doufu\": \"Sutffed Kwat Wheat Doufu\",\r\n  \"item.immortalers_delight.pitcher_plant_barbecue\": \"Itcher Plant Barbecue\",\r\n  \"item.immortalers_delight.leisamboo_tea_cake\": \"Leisamboo Tea Cake\",\r\n  \"item.immortalers_delight.ice_pearlip\": \"Ice Pearlip\",\r\n  \"item.immortalers_delight.chocolate_pearlip_sticks\": \"Chocolate Pearlip Sticks\",\r\n  \"item.immortalers_delight.pod_shell_burger_meat_cube\": \"Pod Shell Burger Meat Cube\",\r\n  \"item.immortalers_delight.nether_kvass\": \"Nether Kvass\",\r\n  \"item.immortalers_delight.purgatory_ale\": \"Purgatory Ale\",\r\n  \"block.immortalers_delight.pod_shell_burger_meat\": \"Pod Shell Burger Meat\",\r\n  \"block.immortalers_delight.himekaido_log\": \"Himekaido Log\",\r\n  \"block.immortalers_delight.stripped_himekaido_log\": \"Stripped Himekaido Log\",\r\n  \"block.immortalers_delight.himekaido_wood\": \"Himekaido Wood\",\r\n  \"block.immortalers_delight.stripped_himekaido_wood\": \"Stripped Himekaido Wood\",\r\n  \"block.immortalers_delight.himekaido_planks\": \"Himekaido Planks\",\r\n  \"block.immortalers_delight.himekaido_stairs\": \"Himekaido Stair\",\r\n  \"block.immortalers_delight.himekaido_slab\": \"Himekaido Slab\",\r\n  \"block.immortalers_delight.himekaido_door\": \"Himekaido Door\",\r\n  \"block.immortalers_delight.himekaido_trapdoor\": \"Himekaido Trapdoor\",\r\n  \"block.immortalers_delight.himekaido_fence\": \"Himekaido Fence\",\r\n  \"block.immortalers_delight.himekaido_fence_gate\": \"Himekaido Fence Gate\",\r\n  \"block.immortalers_delight.himekaido_cabinet\": \"Himekaido Cabinet\",\r\n  \"block.immortalers_delight.himekaido_pressure_plate\": \"Himekaido Pressure Plate\",\r\n  \"block.immortalers_delight.himekaido_button\": \"Himekaido Button\",\r\n  \"block.immortalers_delight.himekaido_sign\": \"Himekaido Sign\",\r\n  \"block.immortalers_delight.himekaido_hanging_sign\": \"Himekaido Hanging Sign\",\r\n  \"block.immortalers_delight.leisamboo_planks\": \"Leisamboo Planks\",\r\n  \"block.immortalers_delight.leisamboo_stairs\": \"Leisamboo Stair\",\r\n  \"block.immortalers_delight.leisamboo_slab\": \"Leisamboo Slab\",\r\n  \"block.immortalers_delight.leisamboo_door\": \"Leisamboo Door\",\r\n  \"block.immortalers_delight.leisamboo_trapdoor\": \"Leisamboo Trapdoor\",\r\n  \"block.immortalers_delight.leisamboo_fence\": \"Leisamboo Fence\",\r\n  \"block.immortalers_delight.leisamboo_fence_gate\": \"Leisamboo Fence Gate\",\r\n  \"block.immortalers_delight.leisamboo_cabinet\": \"Leisamboo Cabinet\",\r\n  \"block.immortalers_delight.leisamboo_pressure_plate\": \"Leisamboo Pressure Plate\",\r\n  \"block.immortalers_delight.leisamboo_button\": \"Leisamboo Button\",\r\n  \"block.immortalers_delight.leisamboo_sign\": \"Leisamboo Sign\",\r\n  \"block.immortalers_delight.leisamboo_hanging_sign\": \"Leisamboo Hanging Sign\",\r\n  \"block.immortalers_delight.evolutcorn\": \"Evolutcorn\",\r\n  \"block.immortalers_delight.zea_pancake\": \"Zea Pancake\",\r\n  \"block.immortalers_delight.pearlip_pie\": \"Pearlip Pie\",\r\n  \"block.immortalers_delight.millenian_bamboo\": \"Millenian Bamboo\",\r\n  \"block.immortalers_delight.himekaido_leaves\": \"Himekaido Leaves\",\r\n  \"block.immortalers_delight.himekaido_fruited_leaves\": \"Himekaido Fruited Leaves\",\r\n  \"block.immortalers_delight.himekaido_flowering_leaves\": \"Himekaido Flowering Leaves\",\r\n  \"block.immortalers_delight.himekaido_shrub\": \"Himekaido Shrub\",\r\n  \"block.immortalers_delight.stewed_rotten_meat_pot\": \"Stewed Rotten Meat Pot\",\r\n  \"block.immortalers_delight.braised_spider_eyes_block\": \"Braised Spider Eyes in Gravy\",\r\n  \"block.immortalers_delight.spoon_block.tips.1\": \"You need a bowl to eat it.\",\r\n  \"block.immortalers_delight.evolutcorn_grain_bag\": \"Evolutcorn Grains Bag\",\r\n  \"block.immortalers_delight.himekaido_crate\": \"Himekaido Crate\",\r\n  \"block.immortalers_delight.pearlip_crate\": \"Pearlip Crate\",\r\n  \"block.immortalers_delight.evolutcorn_block\": \"Evolutcorn Block\",\r\n  \"block.immortalers_delight.enchantal_cooler\": \"Enchantal Cooler\",\r\n  \"block.immortalers_delight.leisamboo_stalk\": \"Leisamboo\",\r\n  \"block.immortalers_delight.leisamboo_crop\": \"Leisamboo\",\r\n  \"block.immortalers_delight.himekaido_yogurt_pie\": \"Himekaido Yogurt Pie\",\r\n  \"block.immortalers_delight.kwat_wheat\": \"Kwat Wheat\",\r\n  \"block.immortalers_delight.nether_bread_cream_soup\": \"Nether Bread Cream Soup\",\r\n  \"block.immortalers_delight.oxidized_ancient_stove\": \"Oxidized Ancient Stove\",\r\n  \"block.immortalers_delight.ancient_stove\": \"Ancient Stove\",\r\n  \"block.immortalers_delight.ancient_wood_log\": \"Ancient Wood Log\",\r\n  \"block.immortalers_delight.ancient_wood\": \"Ancient Wood\",\r\n  \"block.immortalers_delight.stripped_ancient_wood\": \"Stripped Ancient Wood\",\r\n  \"block.immortalers_delight.stripped_ancient_wood_log\": \"Stripped Ancient Wood Log\",\r\n  \"block.immortalers_delight.ancient_wood_planks\": \"Ancient Wood Planks\",\r\n  \"block.immortalers_delight.ancient_wood_cabinet\": \"Ancient Wood Cabinet\",\r\n  \"block.immortalers_delight.ancient_wood_stairs\": \"Ancient Wood Stairs\",\r\n  \"block.immortalers_delight.ancient_wood_slab\": \"Ancient Wood Slab\",\r\n  \"block.immortalers_delight.ancient_wood_door\": \"Ancient Wood Door\",\r\n  \"block.immortalers_delight.ancient_wood_trapdoor\": \"Ancient  Wood Trapdoor\",\r\n  \"block.immortalers_delight.ancient_wood_fence\": \"Ancient Wood Fence\",\r\n  \"block.immortalers_delight.ancient_wood_fence_gate\": \"Ancient Wood Fence Gate\",\r\n  \"block.immortalers_delight.ancient_wood_pressure_plate\": \"Ancient Wood Pressure Plate\",\r\n  \"block.immortalers_delight.ancient_wood_button\": \"Ancient Wood Button\",\r\n  \"entity.immortalers_delight.immortal_chest_boat\": \"Boat with Chest\",\r\n  \"effect.immortalers_delight.incandescence\": \"Incandescence\",\r\n  \"effect.immortalers_delight.weak_poison\": \"Weak Poison\",\r\n  \"effect.immortalers_delight.weak_wither\": \"Weak Wither\",\r\n  \"effect.immortalers_delight.relieve_poison\": \"Relieve Poison\",\r\n  \"effect.immortalers_delight.resistance_to_undead\": \"Resistance to Undead\",\r\n  \"effect.immortalers_delight.resistance_to_arthropod\": \"Resistance to Arthropod\",\r\n  \"effect.immortalers_delight.resistance_to_abyssal\": \"Resistance to Abyssal\",\r\n  \"effect.immortalers_delight.resistance_to_illager\": \"Resistance to Illager\",\r\n  \"effect.immortalers_delight.magical_reverse\": \"Magical Reverse\",\r\n  \"effect.immortalers_delight.gas_poison\": \"Gas Poison\",\r\n  \"effect.immortalers_delight.inebriated\": \"Inebriated\",\r\n  \"effect.immortalers_delight.keep_a_fast\": \"Keep a Fast\",\r\n  \"effect.immortalers_delight.burn_the_boats\": \"Burn The Boats\",\r\n  \"effect.immortalers_delight.cultural_legacy\": \"Cultural Legacy\",\r\n  \"effect.immortalers_delight.warm_current_surges\": \"Warm Current Surges\",\r\n  \"effect.immortalers_delight.resistance_to_surroundings\": \"Mellow\",\r\n  \"advancements.immortalers_delight.immortalers_delight.title\": \"Immortalers Delight\",\r\n  \"advancements.immortalers_delight.immortalers_delight.descr\": \"An ancient taste, waiting to be unearthed.\",\r\n  \"advancements.immortalers_delight.it_is_more_unusual_than_unusual_food_s_delight.title\": \"Stranger than Unusual food's Delight\",\r\n  \"advancements.immortalers_delight.it_is_more_unusual_than_unusual_food_s_delight.descr\": \"So immortalers delight is the strangest meaning of delight through the ages?\",\r\n  \"advancements.immortalers_delight.ealdaec_gemhus.title\": \"Ealdæc Gemhūs\",\r\n  \"advancements.immortalers_delight.ealdaec_gemhus.descr\": \"Get the ancient seeds from the plains\",\r\n  \"advancements.immortalers_delight.treow_meregrot.title\": \"Trēow Meregrot\",\r\n  \"advancements.immortalers_delight.treow_meregrot.descr\": \"Get a black jewel from the jungle\",\r\n  \"advancements.immortalers_delight.wundor_forbodaeppel.title\": \"Wundor Forbodæppel\",\r\n  \"advancements.immortalers_delight.wundor_forbodaeppel.descr\": \"Get the miracle seed from the forest\",\r\n  \"advancement.immortalers_delight.get_himekaido_trees\": \"Spryt teon tō helpe hīe growan\",\r\n  \"advancement.immortalers_delight.get_himekaido_trees.desc\": \"Fertile land, extra fertilizers —— there is always a sacrifice to be made when pursuing excellence.\",\r\n  \"advancement.immortalers_delight.get_stewed_rotten_meat_pot\": \"Bewaria þīne clǽne\",\r\n  \"advancement.immortalers_delight.get_stewed_rotten_meat_pot.desc\": \"Although the patterns are beautiful, when it comes to tableware, cleanliness is of greater importance.\",\r\n  \"advancements.immortalers_delight.crimson_clouds.title\": \"Crimson Clouds\",\r\n  \"advancements.immortalers_delight.crimson_clouds.descr\": \"Unusual wheat seeds in Crimson Forest.\",\r\n  \"advancements.immortalers_delight.ice_extract.title\": \"Ice Extract\",\r\n  \"advancements.immortalers_delight.ice_extract.descr\": \"Get Enchantal Cooler.\",\r\n  \"advancements.immortalers_delight.the_eternal_flow.title\": \"The Eternal Flow\",\r\n  \"advancements.immortalers_delight.the_eternal_flow.descr\": \"Get Contains Tea Leisamboo at the Biver.\",\r\n  \"container.enchantal_cooler\": \"Enchantal Cooler\",\r\n  \"potion.potency.4\": \"V\",\r\n  \"potion.potency.5\": \"VI\",\r\n  \"potion.potency.6\": \"VII\",\r\n  \"potion.potency.7\": \"VIII\",\r\n  \"potion.potency.8\": \"IX\",\r\n  \"potion.potency.9\": \"X\",\r\n  \"farmersdelight.tooltip.golden_himekaido\": \"After consumption, immunizes and reverses harmful effects below grade II\",\r\n  \"farmersdelight.tooltip.enchanted_golden_himekaido\": \"Within 1 second after consumption, be immune to harmful effects below level V (including instant effects).\",\r\n  \"farmersdelight.tooltip.golden_fabric\": \"Made a veil to protect against the burning dust and haze\",\r\n  \"effect.immortalers_delight.incandescence.description\": \"Strength effects can be obtained or prolonged while eating.\",\r\n  \"effect.immortalers_delight.weak_poison.description\": \"Less damaging poisons that do less damage and do not reduce health below 50%. Every 40tick gives 1 magic damage, doubles the damage of each level, stops damage when the health is less than 50% of the maximum health, and the damage does not make the health less than 50%.\",\r\n  \"effect.immortalers_delight.weak_wither.description\": \"Less harmful decay, less damage and no death. Gives 1 blight damage every 50 ticks, doubles each level, stops damage when health is less than 1, and does not make health less than 1.\",\r\n  \"effect.immortalers_delight.relieve_poison.description\": \"Dissolves the toxic effects of lower levels, turning lower levels of decay into weak decay.\",\r\n  \"effect.immortalers_delight.resistance_to_undead.description\": \"Reduced damage caused by undead creatures, about 25% per level, not 100%\",\r\n  \"effect.immortalers_delight.resistance_to_arthropod.description\": \"Reduced damage caused by arthropod creatures, the proportion of damage reduction is about 25% per level, not 100%. Corresponding to Arthropod Killer: Damage taken by arthropod creatures spawners a short Speed IV effect.\",\r\n  \"effect.immortalers_delight.resistance_to_abyssal.description\": \"Reduced damage caused by aquatic organisms, the proportion of damage reduction is about 25% per level, not 100%. A short period of underwater breathing is derived when damaged by aquatic organisms.\",\r\n  \"effect.immortalers_delight.resistance_to_illager.description\": \"Relief of damage caused by disaster villagers, the proportion of damage reduction of about 25% per level, will not reach 100%.\\nDid you know: the peeved ghost does not belong to the villagers, although it will not be accidentally injured by the villagers\",\r\n  \"effect.immortalers_delight.magical_reverse.description\": \"Remove and attempt to reverse negative effects of a lower rank (reverses only apply to original and Farmer's Delight effects). The duration will not be extended.\",\r\n  \"effect.immortalers_delight.gas_poison.description\": \"Cannot be removed by milk. Every 32tick forces a 6% Max Health reduction, randomly spawns one of the following effects per second: blindness, nausea, weakness, slowness, hunger. The derived effect cannot be reversed by milk. Damage to monsters is limited to 1.2 per attack.\",\r\n  \"effect.immortalers_delight.inebriated.description\": \"Cannot be removed by milk. This parameter does not take effect when the duration is less than 3 minutes. Deal true damage of 8% Max health per 64tick, which does not stop damage below 8% health and stops damage when creatures fall below 8% health. All of the following effects: blindness, nausea, weakness, slowness, poisoning. The derived effect cannot be reversed by milk. Damage to monsters is limited to 1.6 per attack.\\nDid you know: drinking to get this effect will add up the time of the effect rather than taking the longest, please moderate alcohol consumption.\",\r\n  \"effect.immortalers_delight.keep_a_fast.description\": \"When this effect is achieved, the player's hunger is reduced to half of the original value, and the cost of hunger is reduced to one-tenth of [effect level +1] during its duration (similar to Stamina enchantment, does not affect actions such as regenerating health). Restores (doubles) the player's hunger at the end of the effect, and the spilled hunger is reclaimed to immediately restore the player's life, the percentage of the recovery increases with the effect level.\",\r\n  \"effect.immortalers_delight.burn_the_boats.description\": \"Grant Power III, Speed III, Urgency III, Jump III, and Resistance III for 15 seconds when health falls below a certain percentage. Causes the health bar to be partially covered with shields and flaming swords, and the covered part marks the health that triggers the effect.\",\r\n  \"effect.immortalers_delight.cultural_legacy.description\": \"Increase the Enchantment level of the Enchantment table when near the Enchantment Table, and gain a certain amount of experience at the end of the effect.\\nIt must take effect within the detection range of the bookshelf attached to the magic table, and the detection is about once every 4 seconds. A level 1 effect increases the enchantment level by 8 levels, and then each level increases the enchantment level by 4 levels, with a maximum effect of 8 levels, that is, a maximum of 36 enchantment levels.\\n\\nThis effect also allows the first and second enchantment options of the Enchanted table to reach level 30 (4 effects are required, Level 2 effects only allow the second enchantment to reach level 30), making it possible to consume level 2 or even level 1 for level 30 enchantment.\",\r\n  \"effect.immortalers_delight.warm_current_surges.description\": \"Warm Current Surges\",\r\n  \"death.attack.drunk\": \"%1$s Drunk on the asphalt\",\r\n  \"death.attack.drunk.item\": \"%1$s was killed by %2$s using %3$s\",\r\n  \"death.attack.drunk.player\": \"%1$ died whilst trying to escap %2$s\",\r\n  \"death.attack.gas\": \"%1$s It was gassed and turned into bacon\",\r\n  \"death.attack.gas.item\": \"%1$s was killed by %2$s using %3$s\",\r\n  \"death.attack.gas.player\": \"%1$ died whilst trying to escap %2$s\"\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/resources/assets/immortalers_delight/lang/en_us.json b/src/main/resources/assets/immortalers_delight/lang/en_us.json
--- a/src/main/resources/assets/immortalers_delight/lang/en_us.json	
+++ b/src/main/resources/assets/immortalers_delight/lang/en_us.json	
@@ -104,6 +104,12 @@
   "item.immortalers_delight.nether_kvass": "Nether Kvass",
   "item.immortalers_delight.purgatory_ale": "Purgatory Ale",
   "block.immortalers_delight.pod_shell_burger_meat": "Pod Shell Burger Meat",
+  "item.immortalers_delight.elixir_of_immortality": "Elixir of Immortality",
+  "item.immortalers_delight.pale_dew_wine": "Pale Dew Wine",
+  "item.immortalers_delight.scarlet_devils_cake": "Scarlet Devil's Cake",
+  "item.immortalers_delight.scarlet_devils_cake_slice": "Slice of Scarlet Devil's Cake",
+  "item.immortalers_delight.red_stuffed_bun": "Red Stuffed Bun",
+  "item.immortalers_delight.spicy_pudding": "Spicy Pudding",
   "block.immortalers_delight.himekaido_log": "Himekaido Log",
   "block.immortalers_delight.stripped_himekaido_log": "Stripped Himekaido Log",
   "block.immortalers_delight.himekaido_wood": "Himekaido Wood",
@@ -169,6 +175,7 @@
   "block.immortalers_delight.ancient_wood_fence_gate": "Ancient Wood Fence Gate",
   "block.immortalers_delight.ancient_wood_pressure_plate": "Ancient Wood Pressure Plate",
   "block.immortalers_delight.ancient_wood_button": "Ancient Wood Button",
+  "block.immortalers_delight.scarlet_devils_cake": "Scarlet Devil's Cake",
   "entity.immortalers_delight.immortal_chest_boat": "Boat with Chest",
   "effect.immortalers_delight.incandescence": "Incandescence",
   "effect.immortalers_delight.weak_poison": "Weak Poison",
@@ -213,6 +220,7 @@
   "potion.potency.7": "VIII",
   "potion.potency.8": "IX",
   "potion.potency.9": "X",
+  "farmersdelight.tooltip.elixir_of_immortality": "[One and Only]It can only be used once in each game. After that, the effect will deteriorate if it is used again.",
   "farmersdelight.tooltip.golden_himekaido": "After consumption, immunizes and reverses harmful effects below grade II",
   "farmersdelight.tooltip.enchanted_golden_himekaido": "Within 1 second after consumption, be immune to harmful effects below level V (including instant effects).",
   "farmersdelight.tooltip.golden_fabric": "Made a veil to protect against the burning dust and haze",
Index: src/main/java/com/renyigesai/immortalers_delight/client/renderer/ImmortalersBoatRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.client.renderer;\r\n\r\nimport com.google.common.collect.ImmutableMap;\r\nimport com.mojang.blaze3d.vertex.PoseStack;\r\nimport com.mojang.blaze3d.vertex.VertexConsumer;\r\nimport com.mojang.datafixers.util.Pair;\r\nimport com.mojang.math.Axis;\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport com.renyigesai.immortalers_delight.entities.ImmortalersBoat;\r\nimport com.renyigesai.immortalers_delight.entities.ImmortalersChestBoat;import com.mojang.blaze3d.vertex.PoseStack;\r\nimport com.mojang.blaze3d.vertex.VertexConsumer;\r\nimport com.mojang.math.Axis;\r\nimport net.minecraft.client.model.BoatModel;\r\nimport net.minecraft.client.model.ChestBoatModel;\r\nimport net.minecraft.client.model.ListModel;\r\nimport net.minecraft.client.model.WaterPatchModel;\r\nimport net.minecraft.client.model.geom.ModelLayerLocation;\r\nimport net.minecraft.client.model.geom.ModelLayers;\r\nimport net.minecraft.client.model.geom.ModelPart;\r\nimport net.minecraft.client.renderer.MultiBufferSource;\r\nimport net.minecraft.client.renderer.RenderType;\r\nimport net.minecraft.client.renderer.entity.EntityRenderer;\r\nimport net.minecraft.client.renderer.entity.EntityRendererProvider;\r\nimport net.minecraft.client.renderer.texture.OverlayTexture;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.util.Mth;\r\nimport net.minecraft.world.entity.vehicle.Boat;\r\nimport org.joml.Quaternionf;\r\n\r\npublic class ImmortalersBoatRenderer extends EntityRenderer<Boat> {\r\n    private static final ResourceLocation BOAT_TEXTURE = new ResourceLocation(ImmortalersDelightMod.MODID, \"textures/entity/boat/himekaido.png\");\r\n    private static final ResourceLocation CHEST_BOAT_TEXTURE = new ResourceLocation(ImmortalersDelightMod.MODID, \"textures/entity/chest_boat/himekaido.png\");\r\n\r\n    private final boolean hasChest;\r\n    private ListModel<Boat> boatModel;\r\n\r\n    public ImmortalersBoatRenderer(EntityRendererProvider.Context context, boolean hasChest) {\r\n        super(context);\r\n        this.shadowRadius = 0.8f;\r\n        this.hasChest = hasChest;\r\n        this.boatModel = this.createBoatModel(context, Boat.Type.OAK, hasChest);\r\n    }\r\n\r\n    private ListModel<Boat> createBoatModel(EntityRendererProvider.Context context, Boat.Type type, boolean bl) {\r\n        ModelLayerLocation modelLayerLocation = bl ? ModelLayers.createChestBoatModelName(type) : ModelLayers.createBoatModelName(type);\r\n        ModelPart modelPart = context.bakeLayer(modelLayerLocation);\r\n        return bl ? new ChestBoatModel(modelPart) : new BoatModel(modelPart);\r\n    }\r\n\r\n\r\n    @Override\r\n    public void render(Boat boat, float f, float g, PoseStack poseStack, MultiBufferSource multiBufferSource, int i) {\r\n        poseStack.pushPose();\r\n        poseStack.translate(0.0f, 0.375f, 0.0f);\r\n        poseStack.mulPose(Axis.YP.rotationDegrees(180.0f - f));\r\n        float h = (float)boat.getHurtTime() - g;\r\n        float j = boat.getDamage() - g;\r\n        if (j < 0.0f) {\r\n            j = 0.0f;\r\n        }\r\n        if (h > 0.0f) {\r\n            poseStack.mulPose(Axis.XP.rotationDegrees(Mth.sin(h) * h * j / 10.0f * (float)boat.getHurtDir()));\r\n        }\r\n        if (!Mth.equal(boat.getBubbleAngle(g), 0.0f)) {\r\n            poseStack.mulPose(new Quaternionf().setAngleAxis(boat.getBubbleAngle(g) * ((float)Math.PI / 180), 1.0f, 0.0f, 1.0f));\r\n        }\r\n        poseStack.scale(-1.0f, -1.0f, 1.0f);\r\n        poseStack.mulPose(Axis.YP.rotationDegrees(90.0f));\r\n        this.boatModel.setupAnim(boat, g, 0.0f, -0.1f, 0.0f, 0.0f);\r\n        VertexConsumer vertexConsumer = multiBufferSource.getBuffer(this.boatModel.renderType(this.hasChest ? CHEST_BOAT_TEXTURE : BOAT_TEXTURE));\r\n        this.boatModel.renderToBuffer(poseStack, vertexConsumer, i, OverlayTexture.NO_OVERLAY, 1.0f, 1.0f, 1.0f, 1.0f);\r\n        if (!boat.isUnderWater()) {\r\n            VertexConsumer vertexConsumer2 = multiBufferSource.getBuffer(RenderType.waterMask());\r\n            if (this.boatModel instanceof WaterPatchModel waterPatchModel) {\r\n                waterPatchModel.waterPatch().render(poseStack, vertexConsumer2, i, OverlayTexture.NO_OVERLAY);\r\n            }\r\n        }\r\n        poseStack.popPose();\r\n        super.render(boat, f, g, poseStack, multiBufferSource, i);\r\n    }\r\n\r\n    @Override\r\n    public ResourceLocation getTextureLocation(Boat boat) {\r\n        return this.hasChest ? CHEST_BOAT_TEXTURE : BOAT_TEXTURE;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/client/renderer/ImmortalersBoatRenderer.java b/src/main/java/com/renyigesai/immortalers_delight/client/renderer/ImmortalersBoatRenderer.java
--- a/src/main/java/com/renyigesai/immortalers_delight/client/renderer/ImmortalersBoatRenderer.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/client/renderer/ImmortalersBoatRenderer.java	
@@ -1,15 +1,9 @@
 package com.renyigesai.immortalers_delight.client.renderer;
 
-import com.google.common.collect.ImmutableMap;
 import com.mojang.blaze3d.vertex.PoseStack;
-import com.mojang.blaze3d.vertex.VertexConsumer;
-import com.mojang.datafixers.util.Pair;
-import com.mojang.math.Axis;
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
-import com.renyigesai.immortalers_delight.entities.ImmortalersBoat;
-import com.renyigesai.immortalers_delight.entities.ImmortalersChestBoat;import com.mojang.blaze3d.vertex.PoseStack;
 import com.mojang.blaze3d.vertex.VertexConsumer;
 import com.mojang.math.Axis;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import net.minecraft.client.model.BoatModel;
 import net.minecraft.client.model.ChestBoatModel;
 import net.minecraft.client.model.ListModel;
Index: src/main/resources/assets/immortalers_delight/lang/zh_cn.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\r\n  \"creativetab_immortalers_delight_tab\": \"千古乐事\",\r\n  \"item.immortalers_delight.evolutcorn\": \"白垩玉黍\",\r\n  \"item.immortalers_delight.evolutcorn_grains\": \"白垩玉黍粒\",\r\n  \"item.immortalers_delight.roast_evolutcorn_chops\": \"烤白垩玉黍粒\",\r\n  \"item.immortalers_delight.ancient_fiber\": \"远古纤维\",\r\n  \"item.immortalers_delight.roast_evolutcorn\": \"烤白垩玉黍\",\r\n  \"item.immortalers_delight.bowl_of_millenian_bamboo\": \"碗装千年竹\",\r\n  \"item.immortalers_delight.cretaceous_zea_ball\": \"玉黍饭团\",\r\n  \"item.immortalers_delight.colorful_grilled_skewers\": \"缤纷谷串\",\r\n  \"item.immortalers_delight.popolutcorn\": \"爆黍花\",\r\n  \"item.immortalers_delight.zea_pancake_slice\": \"玉黍烙切片\",\r\n  \"item.immortalers_delight.evolutcorn_pie_crust\": \"玉黍酥皮\",\r\n  \"item.immortalers_delight.evolutcorn_beer\": \"玉黍啤酒\",\r\n  \"item.immortalers_delight.pearlip_pie_slice\": \"珍珠棱蕉派切片\",\r\n  \"item.immortalers_delight.peatic_musa_salad\": \"热带沙拉\",\r\n  \"item.immortalers_delight.pearlip\": \"珍珠棱蕉\",\r\n  \"item.immortalers_delight.pearlip_shell\": \"珍珠棱蕉壳\",\r\n  \"item.immortalers_delight.pearlipearl\": \"棱珠\",\r\n  \"item.immortalers_delight.pearlip_pumpkin_pie\": \"珍珠棱蕉南瓜饼\",\r\n  \"item.immortalers_delight.pearlipearl_tart\": \"棱珠蛋挞\",\r\n  \"item.immortalers_delight.pearlip_milk_shake\": \"珍珠棱蕉奶昔\",\r\n  \"item.immortalers_delight.pearlip_jelly\": \"珍珠棱蕉果冻\",\r\n  \"item.immortalers_delight.pearlipearl_eggsteam\": \"蕉香蒸蛋\",\r\n  \"item.immortalers_delight.himekaido_cuts\": \"姬海棠果粒\",\r\n  \"item.immortalers_delight.himekaido_seed\": \"姬海棠种子\",\r\n  \"item.immortalers_delight.rotten_flesh_cuts\": \"腐肉碎\",\r\n  \"item.immortalers_delight.himekaido_jelly\": \"姬海棠果酱\",\r\n  \"item.immortalers_delight.yogurt\": \"酸奶\",\r\n  \"item.immortalers_delight.himekaido\": \"姬海棠果\",\r\n  \"item.immortalers_delight.baked_poisonous_potato\": \"烤毒马铃薯\",\r\n  \"item.immortalers_delight.braised_spider_eyes_in_gravy\": \"碗装四眼丸子\",\r\n  \"item.immortalers_delight.tartare_chicken\": \"鞑靼鸡肉\",\r\n  \"item.immortalers_delight.dipped_rotten_flesh\": \"酱蘸腐肉\",\r\n  \"item.immortalers_delight.crispy_yogurt_rotten_flesh\": \"腐肉酸奶脆\",\r\n  \"item.immortalers_delight.meaty_rotten_tomato_broth\": \"烂茄肉汤\",\r\n  \"item.immortalers_delight.stuffed_poisonous_potato\": \"填馅毒马铃薯\",\r\n  \"item.immortalers_delight.pufferfish_roll\": \"河豚寿司\",\r\n  \"item.immortalers_delight.bowl_of_stewed_rotten_meat_in_clay_pot\": \"碗装的瓦罐烂肉炖\",\r\n  \"item.immortalers_delight.golden_himekaido\": \"金姬海棠果\",\r\n  \"item.immortalers_delight.himekaido_yogurt_pie_slice\": \"姬海棠酸奶派切片\",\r\n  \"item.immortalers_delight.dreumk_wine\": \"醉梦姬\",\r\n  \"item.immortalers_delight.kwat_wheat_seeds\": \"瓦斯麦种子\",\r\n  \"item.immortalers_delight.kwat_wheat\": \"瓦斯麦\",\r\n  \"item.immortalers_delight.golden_fabric\": \"金丝织缕\",\r\n  \"item.immortalers_delight.golden_fabric_veil\": \"绯炵金纱\",\r\n  \"item.immortalers_delight.enchanted_golden_himekaido\": \"金魔法果\",\r\n  \"item.immortalers_delight.contains_tea_leisamboo\": \"含茶竹节\",\r\n  \"item.immortalers_delight.empty_bamboo_cup\": \"空竹杯\",\r\n  \"item.immortalers_delight.leisamboo_tea\": \"溪竹茶\",\r\n  \"item.immortalers_delight.iced_black_tea\": \"冰红茶\",\r\n  \"item.immortalers_delight.pearlipearl_milk_tea\": \"棱珠奶茶\",\r\n  \"item.immortalers_delight.pearlipearl_milk_green\": \"棱珠奶绿\",\r\n  \"item.immortalers_delight.stove_black_tea\": \"炉红茶\",\r\n  \"item.immortalers_delight.leaf_green_tea\": \"叶绿茶\",\r\n  \"item.immortalers_delight.british_yellow_tea\": \"英黄茶\",\r\n  \"item.immortalers_delight.leaf_tea\": \"树叶茶\",\r\n  \"item.immortalers_delight.clear_water_vodka\": \"清水伏特加\",\r\n  \"item.immortalers_delight.raw_sniffer_slice\": \"生嗅探兽肉片\",\r\n  \"item.immortalers_delight.cooked_sniffer_slice\": \"熟嗅探兽肉片\",\r\n  \"item.immortalers_delight.raw_sniffer_steak\": \"生嗅探兽肉排\",\r\n  \"item.immortalers_delight.cooked_sniffer_steak\": \"熟嗅探兽肉排\",\r\n  \"item.immortalers_delight.rotating_roast_meat\": \"旋转烤嗅探兽肉\",\r\n  \"item.immortalers_delight.sniffer_hide\": \"嗅探兽毛皮\",\r\n  \"item.immortalers_delight.pitcher_pod_petal\": \"瓶子草荚果瓣\",\r\n  \"item.immortalers_delight.vulcan_coktail\": \"火神鸡尾酒\",\r\n  \"item.immortalers_delight.kwat_wheat_dough\": \"瓦斯麦面团\",\r\n  \"item.immortalers_delight.kwat_wheat_paste\": \"瓦斯麦浆\",\r\n  \"item.immortalers_delight.kwat_wheat_doufu\": \"瓦斯麦豆腐\",\r\n  \"item.immortalers_delight.fry_kwat_wheat_doufu\": \"炸瓦斯麦豆腐\",\r\n  \"item.immortalers_delight.jade_and_ruby_soup\": \"翡翠红玉汤\",\r\n  \"item.immortalers_delight.kwat_wheat_toast\": \"瓦斯麦吐司\",\r\n  \"item.immortalers_delight.kwat_wheat_toast_slice\": \"瓦斯麦吐司片\",\r\n  \"item.immortalers_delight.nether_cream_soup\": \"下界奶油浓汤\",\r\n  \"item.immortalers_delight.nether_cream_bread\": \"下界奶油面包\",\r\n  \"item.immortalers_delight.himekaido_boat\": \"姬海棠木船\",\r\n  \"item.immortalers_delight.himekaido_chest_boat\": \"姬海棠木运输船\",\r\n  \"item.immortalers_delight.torchflower_mustard\": \"火花芥末\",\r\n  \"item.immortalers_delight.hot_hi_soup\": \"热嗨汤\",\r\n  \"item.immortalers_delight.incandescence_sushi\": \"火热寿司\",\r\n  \"item.immortalers_delight.torchflower_cookie\": \"火花芥末曲奇\",\r\n  \"item.immortalers_delight.torchflower_cake\": \"火把花饼\",\r\n  \"item.immortalers_delight.torchflower_curry_rice\": \"火把花咖喱饭\",\r\n  \"item.immortalers_delight.extra_spicy_pasta\": \"特辣意面\",\r\n  \"item.immortalers_delight.himekaido_boat\": \"姬海棠木船\",\r\n  \"item.immortalers_delight.himekaido_chest_boat\": \"姬海棠木运输船\",\r\n  \"item.immortalers_delight.torchflower_mustard\": \"火花芥末\",\r\n  \"item.immortalers_delight.hot_hi_soup\": \"热嗨汤\",\r\n  \"item.immortalers_delight.incandescence_sushi\": \"火热寿司\",\r\n  \"item.immortalers_delight.torchflower_cookie\": \"火花芥末曲奇\",\r\n  \"item.immortalers_delight.torchflower_cake\": \"火把花饼\",\r\n  \"item.immortalers_delight.torchflower_curry_rice\": \"火把花咖喱饭\",\r\n  \"item.immortalers_delight.mashed_potatoes\": \"马铃薯泥\",\r\n  \"item.immortalers_delight.mashed_poisonous_potato\": \"毒马铃薯泥\",\r\n  \"item.immortalers_delight.mashed_potato_with_jam\": \"果酱薯泥\",\r\n  \"item.immortalers_delight.mashed_poisonous_potato_with_jam\": \"果酱毒薯泥\",\r\n  \"item.immortalers_delight.extra_spicy_pasta\": \"特辣意面\",\r\n  \"item.immortalers_delight.sutffed_kwat_wheat_doufu\": \"酿瓦斯麦豆腐\",\r\n  \"item.immortalers_delight.pitcher_plant_barbecue\": \"瓶子草烤肉\",\r\n  \"item.immortalers_delight.leisamboo_tea_cake\": \"溪竹茶饼\",\r\n  \"item.immortalers_delight.ice_pearlip\": \"冻棱蕉\",\r\n  \"item.immortalers_delight.chocolate_pearlip_sticks\": \"巧克力棱蕉棒\",\r\n  \"item.immortalers_delight.pod_shell_burger_meat_cube\": \"荚壳汉堡肉切块\",\r\n  \"item.immortalers_delight.nether_kvass\": \"地狱格瓦斯\",\r\n  \"item.immortalers_delight.purgatory_ale\": \"炼狱麦酒\",\r\n  \"block.immortalers_delight.pod_shell_burger_meat\": \"荚壳汉堡肉\",\r\n  \"block.immortalers_delight.himekaido_log\": \"姬海棠原木\",\r\n  \"block.immortalers_delight.stripped_himekaido_log\": \"去皮姬海棠原木\",\r\n  \"block.immortalers_delight.himekaido_wood\": \"姬海棠木头\",\r\n  \"block.immortalers_delight.stripped_himekaido_wood\": \"去皮姬海棠木头\",\r\n  \"block.immortalers_delight.himekaido_planks\": \"姬海棠木板\",\r\n  \"block.immortalers_delight.himekaido_stairs\": \"姬海棠木楼梯\",\r\n  \"block.immortalers_delight.himekaido_slab\": \"姬海棠台阶\",\r\n  \"block.immortalers_delight.himekaido_door\": \"姬海棠木门\",\r\n  \"block.immortalers_delight.himekaido_trapdoor\": \"姬海棠木活板门\",\r\n  \"block.immortalers_delight.himekaido_fence\": \"姬海棠木栅栏\",\r\n  \"block.immortalers_delight.himekaido_fence_gate\": \"姬海棠木栅栏门\",\r\n  \"block.immortalers_delight.himekaido_cabinet\": \"姬海棠木厨柜\",\r\n  \"block.immortalers_delight.himekaido_pressure_plate\": \"姬海棠木压力板\",\r\n  \"block.immortalers_delight.himekaido_button\": \"姬海棠木按钮\",\r\n  \"block.immortalers_delight.himekaido_sign\": \"姬海棠木告示牌\",\r\n  \"block.immortalers_delight.himekaido_hanging_sign\": \"悬挂式姬海棠木告示牌\",\r\n  \"block.immortalers_delight.leisamboo_planks\": \"棱蕉木板\",\r\n  \"block.immortalers_delight.leisamboo_stairs\": \"棱蕉木楼梯\",\r\n  \"block.immortalers_delight.leisamboo_slab\": \"棱蕉台阶\",\r\n  \"block.immortalers_delight.leisamboo_door\": \"棱蕉木门\",\r\n  \"block.immortalers_delight.leisamboo_trapdoor\": \"棱蕉木活板门\",\r\n  \"block.immortalers_delight.leisamboo_fence\": \"棱蕉木栅栏\",\r\n  \"block.immortalers_delight.leisamboo_fence_gate\": \"棱蕉木栅栏门\",\r\n  \"block.immortalers_delight.leisamboo_cabinet\": \"棱蕉木厨柜\",\r\n  \"block.immortalers_delight.leisamboo_pressure_plate\": \"棱蕉木压力板\",\r\n  \"block.immortalers_delight.leisamboo_button\": \"棱蕉木按钮\",\r\n  \"block.immortalers_delight.leisamboo_sign\": \"棱蕉木告示牌\",\r\n  \"block.immortalers_delight.leisamboo_hanging_sign\": \"悬挂式棱蕉木告示牌\",\r\n  \"block.immortalers_delight.evolutcorn\": \"白垩玉黍\",\r\n  \"block.immortalers_delight.zea_pancake\": \"玉黍烙\",\r\n  \"block.immortalers_delight.pearlip_pie\": \"珍珠棱蕉派\",\r\n  \"block.immortalers_delight.millenian_bamboo\": \"千年竹\",\r\n  \"block.immortalers_delight.himekaido_leaves\": \"姬海棠树叶\",\r\n  \"block.immortalers_delight.himekaido_fruited_leaves\": \"结果的姬海棠树叶\",\r\n  \"block.immortalers_delight.himekaido_flowering_leaves\": \"盛开的姬海棠树叶\",\r\n  \"block.immortalers_delight.himekaido_shrub\": \"姬海棠灌木\",\r\n  \"block.immortalers_delight.stewed_rotten_meat_pot\": \"瓦罐烂肉炖\",\r\n  \"block.immortalers_delight.braised_spider_eyes_block\": \"四眼丸子\",\r\n  \"block.immortalers_delight.spoon_block.tips.1\": \"你需要一个碗以食用它。\",\r\n  \"block.immortalers_delight.evolutcorn_grain_bag\": \"白垩玉黍粒袋\",\r\n  \"block.immortalers_delight.himekaido_crate\": \"箱装姬海棠\",\r\n  \"block.immortalers_delight.pearlip_crate\": \"箱装珍珠棱蕉\",\r\n  \"block.immortalers_delight.evolutcorn_block\": \"白垩玉黍块\",\r\n  \"block.immortalers_delight.enchantal_cooler\": \"魔凝机\",\r\n  \"block.immortalers_delight.leisamboo_stalk\": \"溪竹\",\r\n  \"block.immortalers_delight.leisamboo_crop\": \"溪竹\",\r\n  \"block.immortalers_delight.himekaido_yogurt_pie\": \"姬海棠酸奶派\",\r\n  \"block.immortalers_delight.kwat_wheat\": \"瓦斯麦\",\r\n  \"block.immortalers_delight.nether_bread_cream_soup\": \"下界奶油面包浓汤\",\r\n  \"block.immortalers_delight.oxidized_ancient_stove\": \"氧化的古代炉灶\",\r\n  \"block.immortalers_delight.ancient_stove\": \"古代炉灶\",\r\n  \"block.immortalers_delight.ancient_wood_log\": \"古木原木\",\r\n  \"block.immortalers_delight.ancient_wood\": \"古木\",\r\n  \"block.immortalers_delight.stripped_ancient_wood\": \"去皮古木\",\r\n  \"block.immortalers_delight.stripped_ancient_wood_log\": \"去皮古木原木\",\r\n  \"block.immortalers_delight.ancient_wood_planks\": \"古木板\",\r\n  \"block.immortalers_delight.ancient_wood_cabinet\": \"古木橱柜\",\r\n  \"block.immortalers_delight.ancient_wood_stairs\": \"古木楼梯\",\r\n  \"block.immortalers_delight.ancient_wood_slab\": \"古木台阶\",\r\n  \"block.immortalers_delight.ancient_wood_door\": \"古木门\",\r\n  \"block.immortalers_delight.ancient_wood_trapdoor\": \"古木活板门\",\r\n  \"block.immortalers_delight.ancient_wood_fence\": \"古木栅栏\",\r\n  \"block.immortalers_delight.ancient_wood_fence_gate\": \"古木栅栏门\",\r\n  \"block.immortalers_delight.ancient_wood_pressure_plate\": \"古木压力板\",\r\n  \"block.immortalers_delight.ancient_wood_button\": \"古木按钮\",\r\n  \"entity.immortalers_delight.immortal_chest_boat\": \"运输船\",\r\n  \"effect.immortalers_delight.incandescence\": \"灼热\",\r\n  \"effect.immortalers_delight.weak_poison\": \"弱中毒\",\r\n  \"effect.immortalers_delight.weak_wither\": \"弱凋零\",\r\n  \"effect.immortalers_delight.relieve_poison\": \"解毒\",\r\n  \"effect.immortalers_delight.resistance_to_undead\": \"尸毒抵抗\",\r\n  \"effect.immortalers_delight.resistance_to_arthropod\": \"虫毒抵抗\",\r\n  \"effect.immortalers_delight.resistance_to_abyssal\": \"渊毒抵抗\",\r\n  \"effect.immortalers_delight.resistance_to_illager\": \"厄毒抵抗\",\r\n  \"effect.immortalers_delight.magical_reverse\": \"奇迹般的转变\",\r\n  \"effect.immortalers_delight.gas_poison\": \"绯烬烈灼\",\r\n  \"effect.immortalers_delight.inebriated\": \"酩酊\",\r\n  \"effect.immortalers_delight.keep_a_fast\": \"俭省\",\r\n  \"effect.immortalers_delight.burn_the_boats\": \"破釜\",\r\n  \"effect.immortalers_delight.cultural_legacy\": \"文化底蕴\",\r\n  \"effect.immortalers_delight.warm_current_surges\": \"燃起来了\",\r\n  \"effect.immortalers_delight.resistance_to_surroundings\": \"醇厚\",\r\n  \"advancements.immortalers_delight.immortalers_delight.title\": \"千古乐事\",\r\n  \"advancements.immortalers_delight.immortalers_delight.descr\": \"远古之味，静待出土。\",\r\n  \"advancements.immortalers_delight.it_is_more_unusual_than_unusual_food_s_delight.title\": \"这比奇食乐事更懂奇食\",\r\n  \"advancements.immortalers_delight.it_is_more_unusual_than_unusual_food_s_delight.descr\": \"原来千古乐事是千古以来最奇怪的乐事的意思吗？\",\r\n  \"advancements.immortalers_delight.ealdaec_gemhus.title\": \"古炊凡家\",\r\n  \"advancements.immortalers_delight.ealdaec_gemhus.descr\": \"千秋一粟。\",\r\n  \"advancements.immortalers_delight.treow_meregrot.title\": \"木上珍蚌\",\r\n  \"advancements.immortalers_delight.treow_meregrot.descr\": \"获得来自丛林的黑色宝珠。\",\r\n  \"advancements.immortalers_delight.wundor_forbodaeppel.title\": \"乐园禁果\",\r\n  \"advancements.immortalers_delight.wundor_forbodaeppel.descr\": \"获得来自森林的奇迹之籽\",\r\n  \"advancement.immortalers_delight.get_himekaido_trees\": \"拔苗助长\",\r\n  \"advancement.immortalers_delight.get_himekaido_trees.desc\": \"肥沃的土地、额外的肥料——追求卓越总要伴随牺牲。\",\r\n  \"advancement.immortalers_delight.get_stewed_rotten_meat_pot\": \"注意卫生\",\r\n  \"advancement.immortalers_delight.get_stewed_rotten_meat_pot.desc\": \"纹饰虽美，但作为餐具，还是洁净更重要。\",\r\n  \"advancements.immortalers_delight.crimson_clouds.title\": \"绯红烟云\",\r\n  \"advancements.immortalers_delight.crimson_clouds.descr\": \"在绯红森林获得不同寻常的小麦种子。\",\r\n  \"advancements.immortalers_delight.ice_extract.title\": \"冷翠\",\r\n  \"advancements.immortalers_delight.ice_extract.descr\": \"获得魔凝机。\",\r\n  \"advancements.immortalers_delight.the_eternal_flow.title\": \"千古一流\",\r\n  \"advancements.immortalers_delight.the_eternal_flow.descr\": \"在河流获得含茶竹节。\",\r\n  \"container.enchantal_cooler\": \"魔凝机\",\r\n  \"potion.potency.4\": \"V\",\r\n  \"potion.potency.5\": \"VI\",\r\n  \"potion.potency.6\": \"VII\",\r\n  \"potion.potency.7\": \"VIII\",\r\n  \"potion.potency.8\": \"IX\",\r\n  \"potion.potency.9\": \"X\",\r\n  \"farmersdelight.tooltip.golden_himekaido\": \"食用后，免疫并反转 II 级以下的有害效果\",\r\n  \"farmersdelight.tooltip.enchanted_golden_himekaido\": \"食用后 1 秒内，免疫并反转 V 级以下的有害效果(包括瞬时效果)\",\r\n  \"farmersdelight.tooltip.golden_fabric\": \"制成面纱以抵御绯烬尘霾\",\r\n  \"effect.immortalers_delight.incandescence.description\": \"进食时可以获得或延长力量效果。\",\r\n  \"effect.immortalers_delight.weak_poison.description\": \"更低危害的中毒，伤害更低且不会使得生命值低于50%。每40tick将给予1点魔法伤害，每级伤害值翻倍，在生命不大于生命上限的50%时会停止伤害，且该伤害不会令生命值低于50%。\",\r\n  \"effect.immortalers_delight.weak_wither.description\": \"更低危害的凋零，伤害更低且不会致死。每50tick给予1点凋零伤害，每等级翻倍，当生命值不大于1时会停止伤害，其伤害不会令生命值小于1。\",\r\n  \"effect.immortalers_delight.relieve_poison.description\": \"解除等级更低的中毒效果，将等级更低的凋零效果转变为弱凋零。\",\r\n  \"effect.immortalers_delight.resistance_to_undead.description\": \"减免亡灵生物造成的伤害，减伤比例约25%每级，不会达到100%\",\r\n  \"effect.immortalers_delight.resistance_to_arthropod.description\": \"减免节肢生物造成的伤害，减伤比例约25%每级，不会达到100%。与节肢杀手对应地：受到节肢生物伤害时会派生短时间速度IV效果。\",\r\n  \"effect.immortalers_delight.resistance_to_abyssal.description\": \"减免水生生物造成的伤害，减伤比例约25%每级，不会达到100%。在受到水生生物伤害时会派生短时间水下呼吸效果。\",\r\n  \"effect.immortalers_delight.resistance_to_illager.description\": \"减免灾厄村民造成的伤害，减伤比例约25%每级，不会达到100%。\\n你知道吗：恼鬼不属于灾厄村民，尽管它不会被灾厄村民误伤\",\r\n  \"effect.immortalers_delight.magical_reverse.description\": \"移除并尝试反转等级更低的负面效果（反转仅对原版和农夫乐事的效果生效）。持续时间不会被延长。\",\r\n  \"effect.immortalers_delight.gas_poison.description\": \"不可被牛奶解除。每32tick强制减扣6%最大生命值，每秒随机派生下列的一项效果：失明、反胃、虚弱、缓慢、饥饿。派生的效果也不可被牛奶解除。对怪物的伤害上限为每次1.2。\",\r\n  \"effect.immortalers_delight.inebriated.description\": \"不可被牛奶解除。在持续时长为3分钟以下时不生效。每64tick造成8%最大生命值的真实伤害，该伤害不会令生命值低于8%在生物生命值低于8%时停止伤害。派生下列的所有效果：失明、反胃、虚弱、缓慢、中毒。派生的效果也不可被牛奶解除。对怪物的伤害上限为每次1.6。\\n你知道吗：饮酒获得该效果会使得该效果的时间叠加而不是取最长，请节制饮酒。\",\r\n  \"effect.immortalers_delight.keep_a_fast.description\": \"获得该效果时将使得玩家的饥饿值被压缩到原有值的一半，且持续期间饥饿值的消耗将降为［效果等级+1］分之一（与耐久附魔相似，不影响回复生命等行为）。在效果结束时使玩家的饥饿值复原（翻倍），溢出的饥饿值将回收以立即为玩家恢复生命，回收的比例随效果等级提高。\",\r\n  \"effect.immortalers_delight.burn_the_boats.description\": \"在生命值低于一定比例时，给予生物15秒力量III、速度III、急迫III、跳跃提升III、抗性提升III。使得生命条部分被盾牌与燃火的剑覆盖，覆盖的部分标记了触发该效果的生命值。\",\r\n  \"effect.immortalers_delight.cultural_legacy.description\": \"在附魔台附近时，提升附魔台的附魔等级，效果结束时获得一定量经验。\\n需要在附魔台的书架检测范围内生效，检测约4秒一次。1级效果可以提升8级附魔等级，此后每级效果提升4级附魔等级，最高生效8级，即最多提升36级附魔等级。\\n该效果可令附魔台的第一、二条附魔选项也达到30级（需要4级效果，2级效果仅能使得第二条附魔达到30级），使得可以消耗2等级甚至1等级进行30级附魔。\",\r\n  \"effect.immortalers_delight.warm_current_surges.description\": \"燃起来了\",\r\n  \"death.attack.drunk\": \"%1$s 醉倒在柏油路上\",\r\n  \"death.attack.drunk.item\": \"%1$ 被 %2$s 杀死 %3$s\",\r\n  \"death.attack.drunk.player\": \"%1$ 在试图逃跑时死亡 %2$s\",\r\n  \"death.attack.gas\": \"%1$s 被瓦斯毒气熏成了腊肉\",\r\n  \"death.attack.gas.item\": \"%1$ 被 %2$s 杀死 %3$s\",\r\n  \"death.attack.gas.player\": \"%1$ 在试图逃跑时死亡 %2$s\"\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/resources/assets/immortalers_delight/lang/zh_cn.json b/src/main/resources/assets/immortalers_delight/lang/zh_cn.json
--- a/src/main/resources/assets/immortalers_delight/lang/zh_cn.json	
+++ b/src/main/resources/assets/immortalers_delight/lang/zh_cn.json	
@@ -104,6 +104,12 @@
   "item.immortalers_delight.nether_kvass": "地狱格瓦斯",
   "item.immortalers_delight.purgatory_ale": "炼狱麦酒",
   "block.immortalers_delight.pod_shell_burger_meat": "荚壳汉堡肉",
+  "item.immortalers_delight.elixir_of_immortality": "蓬莱之药",
+  "item.immortalers_delight.pale_dew_wine": "秋露白",
+  "item.immortalers_delight.scarlet_devils_cake": "红魔鬼蛋糕",
+  "item.immortalers_delight.scarlet_devils_cake_slice": "红魔鬼蛋糕切片",
+  "item.immortalers_delight.red_stuffed_bun": "大红包子",
+  "item.immortalers_delight.spicy_pudding": "辛烈布丁",
   "block.immortalers_delight.himekaido_log": "姬海棠原木",
   "block.immortalers_delight.stripped_himekaido_log": "去皮姬海棠原木",
   "block.immortalers_delight.himekaido_wood": "姬海棠木头",
@@ -169,6 +175,7 @@
   "block.immortalers_delight.ancient_wood_fence_gate": "古木栅栏门",
   "block.immortalers_delight.ancient_wood_pressure_plate": "古木压力板",
   "block.immortalers_delight.ancient_wood_button": "古木按钮",
+  "block.immortalers_delight.scarlet_devils_cake": "红魔鬼蛋糕",
   "entity.immortalers_delight.immortal_chest_boat": "运输船",
   "effect.immortalers_delight.incandescence": "灼热",
   "effect.immortalers_delight.weak_poison": "弱中毒",
@@ -213,6 +220,7 @@
   "potion.potency.7": "VIII",
   "potion.potency.8": "IX",
   "potion.potency.9": "X",
+  "farmersdelight.tooltip.elixir_of_immortality": "[独一]在每场游戏中仅能发挥一次效果，此后再次使用时效果将劣化。",
   "farmersdelight.tooltip.golden_himekaido": "食用后，免疫并反转 II 级以下的有害效果",
   "farmersdelight.tooltip.enchanted_golden_himekaido": "食用后 1 秒内，免疫并反转 V 级以下的有害效果(包括瞬时效果)",
   "farmersdelight.tooltip.golden_fabric": "制成面纱以抵御绯烬尘霾",
Index: src/main/java/com/renyigesai/immortalers_delight/client/model_layers/ModelLayers.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.renyigesai.immortalers_delight.client.model_layers;\r\n\r\nimport com.renyigesai.immortalers_delight.ImmortalersDelightMod;\r\nimport net.minecraft.client.model.geom.ModelLayerLocation;\r\nimport net.minecraft.resources.ResourceLocation;\r\n\r\npublic class ModelLayers {\r\n    public static final ModelLayerLocation HIMEKAIDO_BOAT_LAYER = new ModelLayerLocation(\r\n            new ResourceLocation(ImmortalersDelightMod.MODID, \"boat/himekaido\"), \"main\");\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/renyigesai/immortalers_delight/client/model_layers/ModelLayers.java b/src/main/java/com/renyigesai/immortalers_delight/client/model_layers/ModelLayers.java
--- a/src/main/java/com/renyigesai/immortalers_delight/client/model_layers/ModelLayers.java	
+++ b/src/main/java/com/renyigesai/immortalers_delight/client/model_layers/ModelLayers.java	
@@ -1,6 +1,6 @@
 package com.renyigesai.immortalers_delight.client.model_layers;
 
-import com.renyigesai.immortalers_delight.ImmortalersDelightMod;
+import com.renyigesai.immortalers_delight.util.ImmortalersDelightMod;
 import net.minecraft.client.model.geom.ModelLayerLocation;
 import net.minecraft.resources.ResourceLocation;
 
